import 'reflect-metadata';
import 'es6-shim';
import { MigrationJobTask, ScriptOrg, SFieldDescribe } from '../';
import { ISfdmuRunCustomAddonProcessedData } from '../../../addons/modules/sfdmu-run/custom-addons/package';
import { DATA_MEDIA_TYPE, OPERATION } from '../../components/common_components/enumerations';
import { ICsvChunk } from '../api_models';
import ScriptAddonManifestDefinition from '../script_models/scriptAddonManifestDefinition';
import { IMissingParentLookupRecordCsvRow, IOrgConnectionData } from './helper_interfaces';
type IProcessedData = ISfdmuRunCustomAddonProcessedData;
export declare class TaskData {
    constructor(task: MigrationJobTask);
    task: MigrationJobTask;
    sourceToTargetRecordMap: Map<any, any>;
    get fieldsToUpdateMap(): Map<string, SFieldDescribe>;
    get fieldsInQueryMap(): Map<string, SFieldDescribe>;
    get sFieldsInQuery(): SFieldDescribe[];
    get fieldsToUpdate(): string[];
    get sFieldsToUpdate(): SFieldDescribe[];
    get fieldsInQuery(): string[];
    get csvFilename(): string;
    get sourceCsvFilename(): string;
    getTargetCSVFilename(operation: OPERATION, fileNameSuffix?: string): string;
    get resourceString_csvFile(): string;
    get resourceString_org(): string;
    getResourceString_Step(mode: "forwards" | "backwards" | "target"): string;
    get prevTasks(): MigrationJobTask[];
    get nextTasks(): MigrationJobTask[];
    get isPersonAccountEnabled(): boolean;
    get isPersonAccountOrContact(): boolean;
    get fieldsToCompareSourceWithTarget(): Array<string>;
    get fieldsExcludedFromTargetQuery(): Array<string>;
    static getTargetCSVFilename(rootPath: string, sObjectName: string, operation: OPERATION, fileNameSuffix?: string): string;
}
export declare class TaskOrgData {
    constructor(task: MigrationJobTask, isSource: boolean);
    task: MigrationJobTask;
    isSource: boolean;
    extIdRecordsMap: Map<string, string>;
    idRecordsMap: Map<string, any>;
    get org(): ScriptOrg;
    get useBulkQueryApi(): boolean;
    get fieldsMap(): Map<string, SFieldDescribe>;
    get resourceString_Source_Target(): string;
    get allRecords(): boolean;
    get media(): DATA_MEDIA_TYPE;
    get records(): Array<any>;
}
export declare class ProcessedData implements IProcessedData {
    processPersonAccounts: boolean;
    clonedToSourceMap: Map<any, any>;
    fields: Array<SFieldDescribe>;
    recordsToUpdate: Array<any>;
    recordsToInsert: Array<any>;
    missingParentLookups: IMissingParentLookupRecordCsvRow[];
    insertedRecordsSourceToTargetMap: Map<any, any>;
    get lookupIdFields(): Array<SFieldDescribe>;
    get fieldNames(): Array<string>;
    get nonProcessedRecordsAmount(): number;
}
export declare class CachedCSVContent {
    constructor();
    csvDataCacheMap: Map<string, Map<string, any>>;
    updatedFilenames: Set<string>;
    idCounter: number;
    get nextId(): string;
    clear(): void;
}
export declare class CsvChunks {
    constructor(init?: Partial<CsvChunks>);
    chunks: Array<ICsvChunk>;
    header: Array<string>;
    fromArrayChunks(arrayChunks: Array<Array<any>>): CsvChunks;
    fromArray(array: Array<any>): CsvChunks;
}
export declare class ObjectFieldMapping {
    constructor(sourceSObjectName: string, targetSObjectName: string);
    targetSObjectName: string;
    sourceSObjectName: string;
    fieldMapping: Map<string, string>;
    get hasChange(): boolean;
}
export declare class AddonManifest {
    constructor(init?: Partial<AddonManifest>);
    addons: ScriptAddonManifestDefinition[];
}
export declare class OrgConnectionData implements IOrgConnectionData {
    instanceUrl: string;
    accessToken: string;
    apiVersion: string;
    proxyUrl: string;
    isFile: boolean;
}
export {};
