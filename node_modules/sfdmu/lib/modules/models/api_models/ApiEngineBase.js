"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const path = require("path");
const __1 = require("../");
const common_1 = require("../../components/common_components/common");
const enumerations_1 = require("../../components/common_components/enumerations");
const logger_1 = require("../../components/common_components/logger");
const statics_1 = require("../../components/common_components/statics");
const _1 = require("./");
class ApiEngineBase {
    get instanceUrl() {
        return this.connectionData.instanceUrl;
    }
    get accessToken() {
        return this.connectionData.accessToken;
    }
    get version() {
        return this.connectionData.apiVersion;
    }
    get proxyUrl() {
        return this.connectionData.proxyUrl;
    }
    get strOperation() {
        return __1.ScriptObject.getStrOperation(this.operation);
    }
    getBulkApiStrOperation() {
        return this.operation == enumerations_1.OPERATION.HardDelete ? "hardDelete" : this.strOperation.toLowerCase();
    }
    constructor(init) {
        this.numberJobRecordProcessed = 0;
        this.numberJobRecordsFailed = 0;
        this.numberJobTotalRecordsToProcess = 0;
        this.binaryDataCache = enumerations_1.DATA_CACHE_TYPES.InMemory;
        this.fieldsNotToWriteInTargetCSVFile = new Array();
        this.sourceQueryToTarget = (query, sourceObjectName) => ({ query, targetSObjectName: sourceObjectName });
        this.sourceRecordsToTarget = (records, sourceObjectName) => ({ records, targetSObjectName: sourceObjectName });
        this.targetRecordsToSource = (records, sourceObjectName) => ({ records, targetSObjectName: sourceObjectName });
        this.isChildJob = init.isChildJob;
        this.logger = init.logger;
        this.connectionData = init.connectionData;
        this.sObjectName = init.sObjectName;
        this.operation = init.operation;
        this.pollingIntervalMs = init.pollingIntervalMs;
        this.concurrencyMode = init.concurrencyMode;
        this.updateRecordId = init.updateRecordId;
        this.bulkApiV1BatchSize = init.bulkApiV1BatchSize;
        this.restApiBatchSize = init.restApiBatchSize;
        this.allOrNone = init.allOrNone;
        this.createTargetCSVFiles = init.createTargetCSVFiles;
        this.targetCSVFullFilename = init.targetCSVFullFilename;
        this.simulationMode = init.simulationMode;
        this.binaryDataCache = init.binaryDataCache;
        this.binaryCacheDirectory = init.binaryCacheDirectory;
        this.targetFieldMapping = init.targetFieldMapping;
        this.fieldsNotToWriteInTargetCSVFile = statics_1.CONSTANTS.FELDS_NOT_TO_OUTPUT_TO_TARGET_CSV.get(this.sObjectName) || new Array();
        if (init.targetFieldMapping) {
            Object.assign(this, init.targetFieldMapping);
        }
    }
    getEngineName() {
        return "REST API";
    }
    getIsRestApiEngine() {
        return this.getEngineName() == 'REST API';
    }
    getEngineClassType() {
        return ApiEngineBase;
    }
    async executeCRUD(allRecords, progressCallback) {
        this.oldSObjectName = this.sObjectName;
        let mappedRecords = this.sourceRecordsToTarget(allRecords, this.sObjectName);
        if (this.operation == enumerations_1.OPERATION.Delete || this.operation == enumerations_1.OPERATION.HardDelete) {
            mappedRecords.records = mappedRecords.records.map(record => {
                return {
                    Id: record["Id"]
                };
            });
        }
        else if (this.operation == enumerations_1.OPERATION.Insert) {
            mappedRecords.records = mappedRecords.records.map(record => {
                delete record["Id"];
                return record;
            });
        }
        this.sObjectName = mappedRecords.targetSObjectName;
        allRecords = mappedRecords.records;
        this.numberJobTotalRecordsToProcess = allRecords.length;
        if (!this.simulationMode) {
            await this.createCRUDApiJobAsync(allRecords);
        }
        else {
            await this.createCRUDSimulationJobAsync(allRecords);
        }
        let resultRecords = await this.processCRUDApiJobAsync(progressCallback);
        this.sObjectName = this.oldSObjectName;
        resultRecords = this.targetRecordsToSource(resultRecords, this.sObjectName).records;
        return resultRecords;
    }
    async executeCRUDMultithreaded(allRecords, progressCallback, threadsCount) {
        if (!threadsCount || threadsCount <= 1) {
            return await this.executeCRUD(allRecords, progressCallback);
        }
        let chunks = common_1.Common.chunkArray(allRecords, allRecords.length / threadsCount);
        let taskQueue = chunks.map(chunk => {
            return async () => {
                let ApiEngine = this.getEngineClassType();
                let tempApiEngine = new ApiEngine(this);
                tempApiEngine.isChildJob = true;
                let result = await tempApiEngine.executeCRUD(chunk, progressCallback);
                return result || new Array();
            };
        });
        let records = await common_1.Common.parallelExecAsync(taskQueue, this, threadsCount);
        let outputRecords = common_1.Common.flattenArrays(records);
        await this.writeToTargetCSVFileAsync(outputRecords, this.getTargetCsvColumns(outputRecords));
        return outputRecords;
    }
    async createCRUDApiJobAsync(allRecords) {
        return null;
    }
    async createCRUDSimulationJobAsync(allRecords) {
        let chunks = new __1.CsvChunks().fromArray(this.getSourceRecordsArray(allRecords));
        this.apiJobCreateResult = {
            chunks,
            apiInfo: new _1.ApiInfo({
                jobState: "Undefined",
                strOperation: this.strOperation,
                sObjectName: this.sObjectName,
                jobId: "SIMULATION",
                batchId: "SIMULATION"
            }),
            allRecords
        };
        return this.apiJobCreateResult;
    }
    async processCRUDApiJobAsync(progressCallback) {
        let allResultRecords = new Array();
        for (let index = 0; index < this.apiJobCreateResult.chunks.chunks.length; index++) {
            const csvCunk = this.apiJobCreateResult.chunks.chunks[index];
            let resultRecords = new Array();
            if (!this.simulationMode) {
                resultRecords = await this.processCRUDApiBatchAsync(csvCunk, progressCallback);
            }
            else {
                resultRecords = await this.processCRUDSimulationBatchAsync(csvCunk, progressCallback);
            }
            if (!resultRecords) {
                if (!this.isChildJob) {
                    await this.writeToTargetCSVFileAsync(new Array());
                }
                return null;
            }
            else {
                allResultRecords = allResultRecords.concat(resultRecords);
            }
        }
        if (!this.isChildJob) {
            await this.writeToTargetCSVFileAsync(allResultRecords, this.getTargetCsvColumns(allResultRecords));
        }
        return allResultRecords;
    }
    async processCRUDApiBatchAsync(csvChunk, progressCallback) {
        return null;
    }
    async processCRUDSimulationBatchAsync(csvChunk, progressCallback) {
        if (progressCallback) {
            progressCallback(new _1.ApiInfo({
                jobState: "OperationStarted"
            }));
        }
        if (this.operation == enumerations_1.OPERATION.Insert && this.updateRecordId) {
            csvChunk.records.forEach(record => {
                record["Id"] = common_1.Common.makeId(18);
            });
        }
        if (progressCallback) {
            progressCallback(new _1.ApiInfo({
                jobState: "OperationFinished"
            }));
        }
        return this.getResultRecordsArray(csvChunk.records);
    }
    getStrOperation() {
        return this.strOperation;
    }
    async writeToTargetCSVFileAsync(records, columns) {
        if (this.fieldsNotToWriteInTargetCSVFile.length > 0) {
            records.forEach(record => {
                this.fieldsNotToWriteInTargetCSVFile.forEach(fieldName => {
                    record[fieldName] = !!record[fieldName] ? record[fieldName] = `[${fieldName}]` : record[fieldName];
                });
            });
        }
        if (this.createTargetCSVFiles) {
            await common_1.Common.writeCsvFileAsync(this.targetCSVFullFilename, records, true, columns);
        }
    }
    getSourceRecordsArray(records) {
        if (this.operation == enumerations_1.OPERATION.Delete && !this.simulationMode) {
            return records.map(x => x["Id"]);
        }
        else {
            return records;
        }
    }
    getResultRecordsArray(records) {
        if (this.operation == enumerations_1.OPERATION.Delete) {
            return records.map(record => {
                if (!this.simulationMode) {
                    return {
                        Id: record
                    };
                }
                else {
                    delete record[statics_1.CONSTANTS.__ID_FIELD_NAME];
                    return record;
                }
            });
        }
        else {
            return records;
        }
    }
    loadBinaryDataFromCache(records) {
        if (records.length == 0) {
            return records;
        }
        if (this.binaryDataCache == enumerations_1.DATA_CACHE_TYPES.FileCache
            || this.binaryDataCache == enumerations_1.DATA_CACHE_TYPES.CleanFileCache) {
            let binaryFields = Object.keys(records[0]).filter(key => (String(records[0][key]) || '').startsWith(statics_1.CONSTANTS.BINARY_FILE_CACHE_RECORD_PLACEHOLDER_PREFIX));
            if (binaryFields.length > 0) {
                records.forEach(record => {
                    binaryFields.forEach(field => {
                        let binaryId = statics_1.CONSTANTS.BINARY_FILE_CACHE_RECORD_PLACEHOLDER_ID(record[field]);
                        if (binaryId) {
                            let cacheFilename = statics_1.CONSTANTS.BINARY_FILE_CACHE_TEMPLATE(binaryId);
                            let fullCacheFilename = path.join(this.binaryCacheDirectory, cacheFilename);
                            if (fs.existsSync(fullCacheFilename)) {
                                this.logger.infoVerbose(logger_1.RESOURCES.readingFromCacheFile, this.sObjectName, path.join('./', statics_1.CONSTANTS.BINARY_CACHE_SUB_DIRECTORY, cacheFilename));
                                let blob = fs.readFileSync(fullCacheFilename, 'utf-8');
                                record[field] = blob;
                            }
                        }
                    });
                });
            }
        }
    }
    getTargetCsvColumns(records) {
        const LAST_COLS = [
            "Id",
            statics_1.CONSTANTS.ERRORS_FIELD_NAME
        ];
        if (!records || records.length == 0) {
            return new Array();
        }
        let cols = Object.keys(records[0]).filter(key => LAST_COLS.indexOf(key) < 0);
        let lastCols = Object.keys(records[0]).filter(key => LAST_COLS.indexOf(key) >= 0);
        return cols.concat(lastCols);
    }
}
exports.default = ApiEngineBase;
//# sourceMappingURL=ApiEngineBase.js.map