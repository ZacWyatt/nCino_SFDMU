"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const path = require("path");
const __1 = require("../");
const common_1 = require("../../components/common_components/common");
const enumerations_1 = require("../../components/common_components/enumerations");
const logger_1 = require("../../components/common_components/logger");
const statics_1 = require("../../components/common_components/statics");
const migrationJobTask_1 = require("./migrationJobTask");
class MigrationJob {
    constructor(init) {
        this.tasks = new Array();
        this.queryTasks = new Array();
        this.deleteTasks = new Array();
        this.valueMapping = new Map();
        this.csvIssues = new Array();
        this.cachedCSVContent = new __1.CachedCSVContent();
        if (init) {
            Object.assign(this, init);
        }
    }
    get logger() {
        return this.script.logger;
    }
    get objects() {
        return this.script.objects;
    }
    setup() {
        let self = this;
        this.script.job = this;
        let lowerIndexForAnyObjects = 0;
        let lowerIndexForReadonlyObjects = 0;
        this.script.objects.forEach(objectToAdd => {
            let newTask = new __1.MigrationJobTask({
                scriptObject: objectToAdd,
                job: this
            });
            if (objectToAdd.allRecords
                || objectToAdd.isSpecialObject
                || objectToAdd.isObjectWithoutRelationships) {
                objectToAdd.processAllSource = true;
                objectToAdd.processAllTarget = true;
            }
            else {
                objectToAdd.processAllSource = false;
                if (objectToAdd.hasComplexExternalId || objectToAdd.hasAutonumberExternalId) {
                    objectToAdd.processAllTarget = true;
                }
                else {
                    objectToAdd.processAllTarget = false;
                }
            }
            if (objectToAdd.name == statics_1.CONSTANTS.RECORD_TYPE_SOBJECT_NAME) {
                this.tasks.unshift(newTask);
                lowerIndexForAnyObjects++;
                lowerIndexForReadonlyObjects++;
            }
            else if (this.script.keepObjectOrderWhileExecute) {
                this.tasks.push(newTask);
            }
            else if (objectToAdd.isReadonlyObject && !objectToAdd.isHierarchicalDeleteOperation) {
                this.tasks.splice(lowerIndexForReadonlyObjects, 0, newTask);
                lowerIndexForAnyObjects++;
            }
            else if (this.tasks.length == 0) {
                this.tasks.push(newTask);
            }
            else {
                let indexToInsert = this.tasks.length;
                for (var existedTaskIndex = this.tasks.length - 1; existedTaskIndex >= lowerIndexForAnyObjects; existedTaskIndex--) {
                    var existedTask = this.tasks[existedTaskIndex];
                    let isObjectToAdd_ParentLookup = existedTask.scriptObject.parentLookupObjects.some(x => x.name == objectToAdd.name);
                    if (isObjectToAdd_ParentLookup) {
                        indexToInsert = existedTaskIndex;
                    }
                }
                this.tasks.splice(indexToInsert, 0, newTask);
            }
        });
        if (this.script.keepObjectOrderWhileExecute) {
            this.queryTasks = this.tasks.map(task => task);
            this.deleteTasks = this.queryTasks;
        }
        else {
            let swapped = true;
            for (let iteration = 0; iteration < 10 && swapped; iteration++) {
                swapped = ___putMasterDetailsBefore();
            }
            this.tasks.forEach(task => {
                if (task.sourceData.allRecords
                    || task.scriptObject.isLimitedQuery) {
                    this.queryTasks.push(task);
                }
            });
            this.tasks.forEach(task => {
                if (this.queryTasks.indexOf(task) < 0) {
                    this.queryTasks.push(task);
                }
            });
            swapped = true;
            for (let iteration = 0; iteration < 10 && swapped; iteration++) {
                swapped = ___updateQueryTaskOrder();
            }
            this.deleteTasks = this.tasks.slice().reverse();
            ___applySpecialTaskOrder(this.deleteTasks, statics_1.CONSTANTS.SPECIAL_OBJECT_DELETE_ORDER);
            ___applySpecialTaskOrder(this.tasks, statics_1.CONSTANTS.SPECIAL_OBJECT_UPDATE_ORDER);
        }
        this.logger.objectMinimal({
            [this.logger.getResourceString(logger_1.RESOURCES.queryingOrder)]: this.queryTasks.map(x => x.sObjectName).join("; ")
        });
        this.logger.objectMinimal({
            [this.logger.getResourceString(logger_1.RESOURCES.deletingOrder)]: this.deleteTasks.map(x => x.sObjectName).join("; ")
        });
        this.logger.objectMinimal({
            [this.logger.getResourceString(logger_1.RESOURCES.executionOrder)]: this.tasks.map(x => x.sObjectName).join("; ")
        });
        this.script.addonRuntime.createSfdmuPluginJob();
        function ___applySpecialTaskOrder(tasks, specialOrderToApply) {
            for (let leftIndex = 0; leftIndex < tasks.length - 1; leftIndex++) {
                const leftTask = tasks[leftIndex];
                for (let rightIndex = leftIndex + 1; rightIndex < tasks.length; rightIndex++) {
                    const rightTask = tasks[rightIndex];
                    const childObjects = specialOrderToApply.get(rightTask.sObjectName);
                    if (childObjects && childObjects.includes(leftTask.sObjectName)) {
                        tasks.splice(rightIndex, 1);
                        tasks.splice(leftIndex, 0, rightTask);
                    }
                }
            }
        }
        function ___updateQueryTaskOrder() {
            let swapped = false;
            let tempTasks = [].concat(self.queryTasks);
            for (let leftIndex = 0; leftIndex < tempTasks.length - 1; leftIndex++) {
                const leftTask = tempTasks[leftIndex];
                for (let rightIndex = leftIndex + 1; rightIndex < tempTasks.length; rightIndex++) {
                    const rightTask = tempTasks[rightIndex];
                    let rightShouldBeBeforeTheLeft = statics_1.CONSTANTS.SPECIAL_OBJECT_QUERY_ORDER.get(rightTask.scriptObject.name)
                        && statics_1.CONSTANTS.SPECIAL_OBJECT_QUERY_ORDER.get(rightTask.scriptObject.name).indexOf(leftTask.scriptObject.name) >= 0
                        && (rightTask.scriptObject.allRecords || !leftTask.scriptObject.allRecords && !rightTask.scriptObject.allRecords);
                    let leftTaskIndex = self.queryTasks.indexOf(leftTask);
                    let rightTaskIndex = self.queryTasks.indexOf(rightTask);
                    if (rightShouldBeBeforeTheLeft && rightTaskIndex > leftTaskIndex) {
                        self.queryTasks.splice(rightTaskIndex, 1);
                        self.queryTasks.splice(leftTaskIndex, 0, rightTask);
                        swapped = true;
                        console.log(self.queryTasks.map(x => x.sObjectName).join());
                    }
                }
            }
            return swapped;
        }
        function ___putMasterDetailsBefore() {
            let swapped = false;
            let tempTasks = [].concat(self.tasks);
            for (let leftIndex = 0; leftIndex < tempTasks.length - 1; leftIndex++) {
                const leftTask = tempTasks[leftIndex];
                for (let rightIndex = leftIndex + 1; rightIndex < tempTasks.length; rightIndex++) {
                    const rightTask = tempTasks[rightIndex];
                    let rightIsParentMasterDetailOfLeft = leftTask.scriptObject.parentMasterDetailObjects.some(object => object.name == rightTask.sObjectName);
                    let leftTaskIndex = self.tasks.indexOf(leftTask);
                    let rightTaskIndex = self.tasks.indexOf(rightTask);
                    if (rightIsParentMasterDetailOfLeft && rightTaskIndex > leftTaskIndex) {
                        self.tasks.splice(rightTaskIndex, 1);
                        self.tasks.splice(leftTaskIndex, 0, rightTask);
                        swapped = true;
                    }
                }
            }
            return swapped;
        }
    }
    prepareJob() {
        this.createSourceTargetMappingFields();
    }
    async processCSVFilesAsync() {
        await this._loadValueMappingFileAsync();
        if (this.script.sourceOrg.media == enumerations_1.DATA_MEDIA_TYPE.File || this.script.hasUseSourceCSVFile) {
            await this._mergeUserGroupCSVfiles();
            this._copyCSVFilesToSourceSubDir();
            if (!this.script.importCSVFilesAsIs) {
                this.logger.infoMinimal(logger_1.RESOURCES.processingCsvFiles);
                await this._validateAndRepairSourceCSVFiles();
                this.logger.infoVerbose(logger_1.RESOURCES.validationCsvFileCompleted);
                if (this.script.validateCSVFilesOnly) {
                    throw new __1.SuccessExit();
                }
                this.clearCachedCSVData();
            }
            else {
                this.logger.infoMinimal(logger_1.RESOURCES.processingCsvFilesSkipped);
            }
        }
    }
    async getTotalRecordsCountAsync() {
        this.logger.infoVerbose(logger_1.RESOURCES.newLine);
        this.logger.headerMinimal(logger_1.RESOURCES.analysingData);
        for (let index = 0; index < this.tasks.length; index++) {
            const task = this.tasks[index];
            await task.getTotalRecordsCountAsync();
        }
    }
    async deleteOldRecordsAsync() {
        this.logger.infoVerbose(logger_1.RESOURCES.newLine);
        this.logger.headerMinimal(logger_1.RESOURCES.deletingTargetData);
        let deleted = false;
        for (let index = 0; index < this.deleteTasks.length; index++) {
            const task = this.deleteTasks[index];
            deleted = await task.deleteOldTargetRecords() || deleted;
        }
        if (deleted) {
            this.logger.infoVerbose(logger_1.RESOURCES.deletingDataCompleted);
        }
        else {
            this.logger.infoVerbose(logger_1.RESOURCES.deletingDataSkipped);
        }
    }
    async retrieveRecordsAsync() {
        this.logger.infoVerbose(logger_1.RESOURCES.newLine);
        this.logger.headerMinimal(this.logger.getResourceString(logger_1.RESOURCES.source) + ':');
        this.logger.headerVerbose(logger_1.RESOURCES.separator);
        let retrieved = false;
        this.logger.infoVerbose(logger_1.RESOURCES.newLine);
        this.logger.headerMinimal(logger_1.RESOURCES.retrievingData, this.logger.getResourceString(logger_1.RESOURCES.step1));
        for (let index = 0; index < this.queryTasks.length; index++) {
            const task = this.queryTasks[index];
            retrieved = await task.retrieveRecords("forwards", false) || retrieved;
        }
        if (!retrieved) {
            this.logger.infoNormal(logger_1.RESOURCES.noRecords);
        }
        this.logger.infoNormal(logger_1.RESOURCES.retrievingDataCompleted, this.logger.getResourceString(logger_1.RESOURCES.step1));
        retrieved = false;
        this.logger.infoVerbose(logger_1.RESOURCES.newLine);
        this.logger.headerMinimal(logger_1.RESOURCES.retrievingData, this.logger.getResourceString(logger_1.RESOURCES.step2));
        this.logger.infoNormal(logger_1.RESOURCES.pass1);
        this.logger.headerVerbose(logger_1.RESOURCES.separator);
        for (let index = 0; index < this.queryTasks.length; index++) {
            const task = this.queryTasks[index];
            retrieved = await task.retrieveRecords("backwards", false) || retrieved;
        }
        if (!retrieved) {
            this.logger.infoNormal(logger_1.RESOURCES.noRecords);
        }
        retrieved = false;
        this.logger.infoVerbose(logger_1.RESOURCES.newLine);
        this.logger.infoNormal(logger_1.RESOURCES.pass2);
        this.logger.headerVerbose(logger_1.RESOURCES.separator);
        for (let index = 0; index < this.queryTasks.length; index++) {
            const task = this.queryTasks[index];
            retrieved = await task.retrieveRecords("backwards", false) || retrieved;
        }
        if (!retrieved) {
            this.logger.infoNormal(logger_1.RESOURCES.noRecords);
        }
        retrieved = false;
        this.logger.infoVerbose(logger_1.RESOURCES.newLine);
        this.logger.infoNormal(logger_1.RESOURCES.pass3);
        this.logger.headerVerbose(logger_1.RESOURCES.separator);
        for (let index = 0; index < this.queryTasks.length; index++) {
            const task = this.queryTasks[index];
            retrieved = await task.retrieveRecords("forwards", true) || retrieved;
        }
        if (!retrieved) {
            this.logger.infoNormal(logger_1.RESOURCES.noRecords);
        }
        retrieved = false;
        this.logger.infoVerbose(logger_1.RESOURCES.newLine);
        this.logger.infoNormal(logger_1.RESOURCES.pass4);
        this.logger.headerVerbose(logger_1.RESOURCES.separator);
        for (let index = 0; index < this.queryTasks.length; index++) {
            const task = this.queryTasks[index];
            retrieved = await task.retrieveRecords("forwards", true) || retrieved;
        }
        if (!retrieved) {
            this.logger.infoNormal(logger_1.RESOURCES.noRecords);
        }
        retrieved = false;
        this.logger.infoVerbose(logger_1.RESOURCES.newLine);
        this.logger.headerMinimal(this.logger.getResourceString(logger_1.RESOURCES.target) + ':');
        this.logger.headerVerbose(logger_1.RESOURCES.separator);
        for (let index = 0; index < this.queryTasks.length; index++) {
            const task = this.queryTasks[index];
            retrieved = await task.retrieveRecords("target", false) || retrieved;
        }
        if (!retrieved) {
            this.logger.infoNormal(logger_1.RESOURCES.noRecords);
        }
        this.logger.infoNormal(logger_1.RESOURCES.retrievingDataCompleted, this.logger.getResourceString(logger_1.RESOURCES.step2));
        let processed = false;
        this.logger.infoVerbose(logger_1.RESOURCES.newLine);
        this.logger.headerNormal(logger_1.RESOURCES.processingAddon);
        for (let index = 0; index < this.queryTasks.length; index++) {
            const task = this.queryTasks[index];
            processed = await task.runAddonEventAsync(enumerations_1.ADDON_EVENTS.onBefore) || processed;
        }
        if (!processed) {
            this.logger.infoNormal(logger_1.RESOURCES.nothingToProcess);
        }
        this.logger.infoVerbose(logger_1.RESOURCES.newLine);
        this.logger.infoVerbose(logger_1.RESOURCES.newLine);
        this.logger.headerNormal(logger_1.RESOURCES.fetchingSummary);
        for (let index = 0; index < this.queryTasks.length; index++) {
            const task = this.queryTasks[index];
            this.logger.infoNormal(logger_1.RESOURCES.amuntOfRetrievedRecords, task.sObjectName, String(task.sourceData.idRecordsMap.size + "/" + task.targetData.idRecordsMap.size));
        }
        await this.runAddonEventAsync(enumerations_1.ADDON_EVENTS.onDataRetrieved);
    }
    async updateRecordsAsync() {
        let self = this;
        let noAbortPrompt = false;
        let totalProcessedRecordsAmount = 0;
        let totalProcessedRecordsByObjectsMap = new Map();
        let allMissingParentLookups = new Array();
        let tasksToProcess = this.script.hasDeleteFromSourceObjectOperation ? this.deleteTasks : this.tasks;
        this.logger.infoVerbose(logger_1.RESOURCES.newLine);
        this.logger.headerMinimal(logger_1.RESOURCES.updatingTarget, this.logger.getResourceString(logger_1.RESOURCES.step1));
        for (let index = 0; index < tasksToProcess.length; index++) {
            const task = tasksToProcess[index];
            let processedRecordsAmount = (await task.updateRecords("forwards", async (data) => {
                allMissingParentLookups = allMissingParentLookups.concat(data.missingParentLookups);
                if (noAbortPrompt) {
                    ___warn(data, task.sObjectName);
                    return;
                }
                await ___promptToAbort(data, task.sObjectName);
                noAbortPrompt = true;
            }));
            if (processedRecordsAmount > 0) {
                this.logger.infoNormal(logger_1.RESOURCES.updatingTargetObjectCompleted, task.sObjectName, String(processedRecordsAmount));
                this.logger.infoVerbose(logger_1.RESOURCES.newLine);
            }
            totalProcessedRecordsAmount += processedRecordsAmount;
            totalProcessedRecordsByObjectsMap.set(task.sObjectName, processedRecordsAmount);
        }
        this.logger.infoVerbose(logger_1.RESOURCES.newLine);
        if (totalProcessedRecordsAmount > 0)
            this.logger.infoNormal(logger_1.RESOURCES.updatingTargetCompleted, this.logger.getResourceString(logger_1.RESOURCES.step1), String(totalProcessedRecordsAmount));
        else
            this.logger.infoNormal(logger_1.RESOURCES.nothingUpdated);
        this.logger.infoVerbose(logger_1.RESOURCES.newLine);
        this.logger.headerMinimal(logger_1.RESOURCES.updatingTarget, this.logger.getResourceString(logger_1.RESOURCES.step2));
        totalProcessedRecordsAmount = 0;
        if (this.script.targetOrg.media == enumerations_1.DATA_MEDIA_TYPE.Org) {
            this.logger.infoVerbose(logger_1.RESOURCES.newLine);
            this.logger.infoNormal(logger_1.RESOURCES.pass1);
            this.logger.headerVerbose(logger_1.RESOURCES.separator);
            for (let index = 0; index < this.tasks.length; index++) {
                const task = this.tasks[index];
                let processedRecordsAmount = (await task.updateRecords("backwards", async (data) => {
                    allMissingParentLookups = allMissingParentLookups.concat(data.missingParentLookups);
                    if (noAbortPrompt) {
                        ___warn(data, task.sObjectName);
                        return;
                    }
                    await ___promptToAbort(data, task.sObjectName);
                    noAbortPrompt = true;
                }));
                if (processedRecordsAmount > 0) {
                    this.logger.infoNormal(logger_1.RESOURCES.updatingTargetObjectCompleted, task.sObjectName, String(processedRecordsAmount));
                    this.logger.infoVerbose(logger_1.RESOURCES.newLine);
                }
                totalProcessedRecordsAmount += processedRecordsAmount;
                totalProcessedRecordsByObjectsMap.set(task.sObjectName, totalProcessedRecordsByObjectsMap.get(task.sObjectName) + processedRecordsAmount);
            }
            this.logger.infoVerbose(logger_1.RESOURCES.newLine);
            this.logger.infoNormal(logger_1.RESOURCES.pass2);
            this.logger.headerVerbose(logger_1.RESOURCES.separator);
            for (let index = 0; index < this.tasks.length; index++) {
                const task = this.tasks[index];
                let processedRecordsAmount = (await task.updateRecords("backwards", async (data) => {
                    allMissingParentLookups = allMissingParentLookups.concat(data.missingParentLookups);
                    if (noAbortPrompt) {
                        ___warn(data, task.sObjectName);
                        return;
                    }
                    await ___promptToAbort(data, task.sObjectName);
                    noAbortPrompt = true;
                }));
                if (processedRecordsAmount > 0) {
                    this.logger.infoNormal(logger_1.RESOURCES.updatingTargetObjectCompleted, task.sObjectName, String(processedRecordsAmount));
                    this.logger.infoVerbose(logger_1.RESOURCES.newLine);
                }
                totalProcessedRecordsAmount += processedRecordsAmount;
                totalProcessedRecordsByObjectsMap.set(task.sObjectName, totalProcessedRecordsByObjectsMap.get(task.sObjectName) + processedRecordsAmount);
            }
        }
        this.logger.infoVerbose(logger_1.RESOURCES.newLine);
        if (totalProcessedRecordsAmount > 0)
            this.logger.infoNormal(logger_1.RESOURCES.updatingTargetCompleted, this.logger.getResourceString(logger_1.RESOURCES.step2), String(totalProcessedRecordsAmount));
        else
            this.logger.infoNormal(logger_1.RESOURCES.nothingUpdated);
        if (this.script.hasDeleteByHierarchyOperation) {
            this.logger.infoVerbose(logger_1.RESOURCES.newLine);
            this.logger.headerMinimal(logger_1.RESOURCES.deletingTarget, this.logger.getResourceString(logger_1.RESOURCES.step1));
            for (let index = 0; index < this.deleteTasks.length; index++) {
                this.logger.infoVerbose(logger_1.RESOURCES.newLine);
                const task = this.deleteTasks[index];
                if (task.scriptObject.isHierarchicalDeleteOperation) {
                    let processedRecordsAmount = await task.deleteRecords();
                    if (processedRecordsAmount > 0) {
                        this.logger.infoNormal(logger_1.RESOURCES.deletingRecordsCompleted, task.sObjectName, String(processedRecordsAmount));
                    }
                    totalProcessedRecordsAmount += processedRecordsAmount;
                    totalProcessedRecordsByObjectsMap.set(task.sObjectName, processedRecordsAmount);
                }
            }
            this.logger.infoVerbose(logger_1.RESOURCES.newLine);
            if (totalProcessedRecordsAmount > 0)
                this.logger.infoNormal(logger_1.RESOURCES.deletingDataCompleted, this.logger.getResourceString(logger_1.RESOURCES.step1), String(totalProcessedRecordsAmount));
            else
                this.logger.infoNormal(logger_1.RESOURCES.nothingToDelete2);
            this.logger.infoVerbose(logger_1.RESOURCES.newLine);
        }
        let processed = false;
        this.logger.infoVerbose(logger_1.RESOURCES.newLine);
        this.logger.headerNormal(logger_1.RESOURCES.processingAddon);
        for (let index = 0; index < this.queryTasks.length; index++) {
            const task = this.queryTasks[index];
            processed = await task.runAddonEventAsync(enumerations_1.ADDON_EVENTS.onAfter) || processed;
        }
        if (!processed) {
            this.logger.infoNormal(logger_1.RESOURCES.nothingToProcess);
        }
        this.logger.infoVerbose(logger_1.RESOURCES.newLine);
        this.logger.infoVerbose(logger_1.RESOURCES.newLine);
        this.logger.headerNormal(logger_1.RESOURCES.updatingSummary);
        for (let index = 0; index < this.queryTasks.length; index++) {
            const task = this.queryTasks[index];
            this.logger.infoNormal(logger_1.RESOURCES.updatingTotallyUpdated, task.sObjectName, String(totalProcessedRecordsByObjectsMap.get(task.sObjectName)));
        }
        this.logger.infoVerbose(logger_1.RESOURCES.newLine);
        await self.saveCSVFileAsync(statics_1.CONSTANTS.MISSING_PARENT_LOOKUP_RECORDS_ERRORS_FILENAME, allMissingParentLookups, true);
        async function ___promptToAbort(data, sObjectName) {
            await common_1.Common.abortWithPrompt(logger_1.RESOURCES.missingParentLookupsPrompt, self.script.promptOnMissingParentObjects, logger_1.RESOURCES.continueTheJob, "", async () => {
                await self.saveCSVFileAsync(statics_1.CONSTANTS.MISSING_PARENT_LOOKUP_RECORDS_ERRORS_FILENAME, allMissingParentLookups, true);
            }, sObjectName, String(data.missingParentLookups.length), statics_1.CONSTANTS.MISSING_PARENT_LOOKUP_RECORDS_ERRORS_FILENAME);
        }
        function ___warn(data, sObjectName) {
            self.logger.warn(logger_1.RESOURCES.missingParentLookupsPrompt, sObjectName, String(data.missingParentLookups.length), statics_1.CONSTANTS.MISSING_PARENT_LOOKUP_RECORDS_ERRORS_FILENAME);
        }
    }
    getTaskBySObjectName(sObjectName) {
        return this.tasks.filter(x => x.sObjectName == sObjectName)[0];
    }
    getTaskByFieldPath(fieldPath, prevTask) {
        let parts = (fieldPath || '').split('.');
        if (parts.length == 0) {
            return null;
        }
        if (!prevTask) {
            let objectTask = this.tasks.find(task => task.sObjectName == parts[0]);
            if (!objectTask) {
                return null;
            }
            else {
                parts.shift();
                return this.getTaskByFieldPath(parts.join('.'), objectTask);
            }
        }
        let fieldName = parts.length > 1 ? common_1.Common.getFieldNameId(null, parts[0]) : parts[0];
        let fieldDescribe = prevTask.scriptObject.fieldsInQueryMap.get(fieldName);
        if (!fieldDescribe) {
            return null;
        }
        if (fieldDescribe.lookup) {
            let fieldTask = this.tasks.find(task => task.sObjectName == fieldDescribe.referencedObjectType);
            if (!fieldTask) {
                return null;
            }
            parts.shift();
            return this.getTaskByFieldPath(parts.join('.'), fieldTask);
        }
        return {
            task: prevTask,
            field: fieldName
        };
    }
    async saveCSVFileAsync(fileName, data, alwaysCreateFile = true) {
        let filePath = path.join(this.script.reportsDirectory, fileName);
        this.logger.infoVerbose(logger_1.RESOURCES.writingCsvFile, filePath);
        await common_1.Common.writeCsvFileAsync(filePath, data, alwaysCreateFile);
    }
    async saveCachedCsvDataFiles() {
        let filePaths = [...this.cachedCSVContent.csvDataCacheMap.keys()];
        for (let i = 0; i < filePaths.length; i++) {
            const filePath = filePaths[i];
            if (this.cachedCSVContent.updatedFilenames.has(filePath)) {
                let csvData = this.cachedCSVContent.csvDataCacheMap.get(filePath);
                this.logger.infoVerbose(logger_1.RESOURCES.writingCsvFile, filePath);
                await common_1.Common.writeCsvFileAsync(filePath, [...csvData.values()], true);
            }
        }
    }
    clearCachedCSVData() {
        this.cachedCSVContent.clear();
    }
    createSourceTargetMappingFields() {
        let self = this;
        if (this.script.sourceTargetFieldMapping.size > 0) {
            this.script.objects.forEach(object => {
                object.fieldsInQueryMap.forEach(field => {
                    let parts = field.name.split('.');
                    if (field.isSimpleNotLookup || field.isSimpleReference) {
                        let ret = ___mapField(object.name, null, field);
                        if (ret.changed) {
                            field.m_targetName = ret.fieldName;
                        }
                    }
                    else if (field.is__r) {
                        let ret = ___mapField(object.name, null, field);
                        if (ret.changed) {
                            parts[0] = common_1.Common.getFieldName__r(null, ret.fieldName);
                        }
                        if (!field.isContainsComplex) {
                            if (!common_1.Common.isComplexField(parts[1])) {
                                let ret = ___mapField(field.parentLookupObject.name, parts[1]);
                                if (ret.changed) {
                                    parts[1] = ret.fieldName;
                                }
                            }
                        }
                        else {
                            parts = [].concat(parts[0], ___mapComplexField(field.parentLookupObject.name, parts.slice(1).join('.')));
                        }
                        field.m_targetName = parts.join('.');
                    }
                    else if (field.isComplex) {
                        field.m_targetName = ___mapComplexField(object.name, field.name);
                    }
                });
            });
        }
        function ___mapField(objectName, fieldName, field) {
            fieldName = common_1.Common.getFieldNameId(field, fieldName);
            let objectFieldMapping = self.script.sourceTargetFieldMapping.get(objectName) || new __1.ObjectFieldMapping("", "");
            let changed = false;
            objectFieldMapping.fieldMapping.forEach((value, key) => {
                if (fieldName == key) {
                    fieldName = value;
                    changed = true;
                }
            });
            return {
                fieldName,
                changed
            };
        }
        function ___mapComplexField(objectName, fieldName) {
            if (!objectName || !fieldName) {
                return fieldName;
            }
            let parentObject_level1 = self.script.objectsMap.get(objectName);
            if (!parentObject_level1 || !parentObject_level1.useFieldMapping) {
                return fieldName;
            }
            let fieldNames = common_1.Common.getFieldFromComplexField(fieldName).split(statics_1.CONSTANTS.COMPLEX_FIELDS_SEPARATOR);
            fieldNames = fieldNames.map(fieldName => {
                let parts = fieldName.split('.');
                let nameId = common_1.Common.getFieldNameId(null, parts[0]);
                let sField = parentObject_level1.targetSObjectDescribe.fieldsMap.get(nameId);
                if (!sField) {
                    return parts.join('.');
                }
                if (sField.isSimpleNotLookup || sField.isSimpleReference) {
                    let ret = ___mapField(objectName, nameId);
                    if (ret.changed) {
                        parts[0] = ret.fieldName;
                    }
                }
                if (parts.length == 1) {
                    return parts.join('.');
                }
                parts[0] = common_1.Common.getFieldName__r(null, parts[0]);
                let parentObject_level2 = self.script.objectsMap.get(sField.referencedObjectType);
                if (!parentObject_level2 || !parentObject_level2.useFieldMapping) {
                    return parts.join('.');
                }
                sField = parentObject_level2.targetSObjectDescribe.fieldsMap.get(parts[1]);
                if (!sField) {
                    return parts.join('.');
                }
                let ret = ___mapField(parentObject_level2.name, parts[1]);
                if (ret.changed) {
                    parts[1] = ret.fieldName;
                }
                return parts.join('.');
            });
            fieldName = common_1.Common.getComplexField(fieldNames.join(statics_1.CONSTANTS.COMPLEX_FIELDS_SEPARATOR));
            return fieldName;
        }
    }
    createDummyJobTask(sObjectName) {
        let scriptObject = new __1.ScriptObject(sObjectName);
        scriptObject.script = this.script;
        return new migrationJobTask_1.default({
            job: this,
            scriptObject
        });
    }
    async runAddonEventAsync(event) {
        return await this.script.addonManager.triggerAddonModuleMethodAsync(event);
    }
    async _loadValueMappingFileAsync() {
        let valueMappingFilePath = path.join(this.script.basePath, statics_1.CONSTANTS.VALUE_MAPPING_CSV_FILENAME);
        let csvRows = await common_1.Common.readCsvFileAsync(valueMappingFilePath);
        if (csvRows.length > 0) {
            this.logger.infoVerbose(logger_1.RESOURCES.readingValuesMappingFile, statics_1.CONSTANTS.VALUE_MAPPING_CSV_FILENAME);
            csvRows.forEach(row => {
                if (row["ObjectName"] && row["FieldName"]) {
                    let objectName = String(row["ObjectName"]).trim();
                    let fieldName = String(row["FieldName"]).trim();
                    let scriptObject = this.script.objectsMap.get(objectName);
                    if (scriptObject && scriptObject.hasUseValueMapping) {
                        let key = objectName + fieldName;
                        if (!this.valueMapping.has(key)) {
                            this.valueMapping.set(key, new Map());
                        }
                        this.valueMapping.get(key).set(String(row["RawValue"]).trim(), (String(row["Value"]) || "").trim());
                    }
                }
            });
        }
    }
    async _mergeUserGroupCSVfiles() {
        let filepath1 = path.join(this.script.basePath, "User.csv");
        let filepath2 = path.join(this.script.basePath, "Group.csv");
        let filepath3 = path.join(this.script.basePath, statics_1.CONSTANTS.USER_AND_GROUP_FILENAME + ".csv");
        await common_1.Common.mergeCsvFilesAsync(filepath1, filepath2, filepath3, true, "Id", "Name");
    }
    _copyCSVFilesToSourceSubDir() {
        this.tasks.filter(task => this.script.sourceOrg.isFileMedia || task.scriptObject.useSourceCSVFile)
            .forEach(task => {
            if (fs.existsSync(task.data.csvFilename)) {
                fs.copyFileSync(task.data.csvFilename, task.data.sourceCsvFilename);
            }
        });
    }
    async _validateAndRepairSourceCSVFiles() {
        let self = this;
        let thisTasks = this.tasks.filter(task => this.script.sourceOrg.isFileMedia || task.scriptObject.useSourceCSVFile);
        for (let index = 0; index < thisTasks.length; index++) {
            const task = thisTasks[index];
            this.csvIssues = this.csvIssues.concat(await task.validateCSV());
        }
        let noAbortPrompt = false;
        if (this.csvIssues.length > 0) {
            await ___promptToAbort();
            noAbortPrompt = true;
        }
        for (let index = 0; index < thisTasks.length; index++) {
            const task = thisTasks[index];
            this.csvIssues = this.csvIssues.concat(await task.repairCSV(this.cachedCSVContent, true));
        }
        for (let index = 0; index < thisTasks.length; index++) {
            const task = thisTasks[index];
            this.csvIssues = this.csvIssues.concat(await task.repairCSV(this.cachedCSVContent, false));
        }
        await this.saveCachedCsvDataFiles();
        this.logger.infoVerbose(logger_1.RESOURCES.csvFilesWereUpdated, String(this.cachedCSVContent.updatedFilenames.size));
        if (this.csvIssues.length > 0) {
            if (!noAbortPrompt) {
                await ___promptToAbort();
            }
            else {
                await self.saveCSVFileAsync(statics_1.CONSTANTS.CSV_ISSUES_ERRORS_FILENAME, self.csvIssues);
                this.logger.warn(logger_1.RESOURCES.incorrectCsvFiles, String(this.csvIssues.length), statics_1.CONSTANTS.CSV_ISSUES_ERRORS_FILENAME);
            }
        }
        else {
            this.logger.infoVerbose(logger_1.RESOURCES.correctCsvFiles);
        }
        async function ___promptToAbort() {
            await common_1.Common.abortWithPrompt(logger_1.RESOURCES.incorrectCsvFiles, self.script.promptOnIssuesInCSVFiles, logger_1.RESOURCES.continueTheJob, "", async () => {
                await self.saveCSVFileAsync(statics_1.CONSTANTS.CSV_ISSUES_ERRORS_FILENAME, self.csvIssues);
            }, String(self.csvIssues.length), statics_1.CONSTANTS.CSV_ISSUES_ERRORS_FILENAME);
        }
    }
}
exports.default = MigrationJob;
//# sourceMappingURL=migrationJob.js.map