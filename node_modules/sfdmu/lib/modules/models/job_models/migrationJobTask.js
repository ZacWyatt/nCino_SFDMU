"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const casual = require("casual");
const deepClone = require("deep.clone");
const fs = require("fs");
const soql_parser_js_1 = require("soql-parser-js");
const __1 = require("../");
const bulkApiV1_0Engine_1 = require("../../components/api_engines/bulkApiV1_0Engine");
const bulkApiV2_0Engine_1 = require("../../components/api_engines/bulkApiV2_0Engine");
const restApiEngine_1 = require("../../components/api_engines/restApiEngine");
const common_1 = require("../../components/common_components/common");
const enumerations_1 = require("../../components/common_components/enumerations");
const logger_1 = require("../../components/common_components/logger");
const mockGenerator_1 = require("../../components/common_components/mockGenerator");
const sfdx_1 = require("../../components/common_components/sfdx");
const statics_1 = require("../../components/common_components/statics");
const sfieldDescribe_1 = require("../sf_models/sfieldDescribe");
const alasql = require("alasql");
mockGenerator_1.MockGenerator.createCustomGenerators(casual);
class MigrationJobTask {
    constructor(init) {
        this.sourceTotalRecorsCount = 0;
        this.targetTotalRecorsCount = 0;
        this.data = new __1.TaskData(this);
        this.sourceData = new __1.TaskOrgData(this, true);
        this.targetData = new __1.TaskOrgData(this, false);
        this.tempData = {
            filteredQueryValueCache: new Map()
        };
        this._targetFieldMapping = {
            sourceQueryToTarget: this._mapSourceQueryToTarget.bind(this),
            sourceRecordsToTarget: this._mapSourceRecordsToTarget.bind(this),
            targetRecordsToSource: this._mapTargetRecordsToSource.bind(this),
            transformQuery: this._transformQuery.bind(this)
        };
        this._sourceFieldMapping = {
            transformQuery: this._transformQuery.bind(this)
        };
        if (init) {
            Object.assign(this, init);
        }
    }
    get sObjectName() {
        return this.scriptObject && this.scriptObject.name;
    }
    get script() {
        return this.scriptObject.script;
    }
    get logger() {
        return this.script.logger;
    }
    get operation() {
        return this.scriptObject.operation;
    }
    get externalId() {
        return this.scriptObject.externalId;
    }
    get complexExternalId() {
        return common_1.Common.getComplexField(this.scriptObject.externalId);
    }
    async validateCSV() {
        let csvIssues = new Array();
        if (!fs.existsSync(this.data.sourceCsvFilename)) {
            if (!this.script.excludeIdsFromCSVFiles) {
                csvIssues.push({
                    "Date update": common_1.Common.formatDateTime(new Date()),
                    "sObject name": this.sObjectName,
                    "Field name": null,
                    "Field value": null,
                    "Parent SObject name": null,
                    "Parent field name": null,
                    "Parent field value": null,
                    "Error": this.logger.getResourceString(logger_1.RESOURCES.missingCsvFile)
                });
            }
            await common_1.Common.writeCsvFileAsync(this.data.sourceCsvFilename, [], true);
        }
        let csvColumnsRow = await common_1.Common.readCsvFileAsync(this.data.sourceCsvFilename, 1);
        if (csvColumnsRow.length == 0) {
            return csvIssues;
        }
        [...this.data.fieldsToUpdateMap.keys()].forEach(fieldName => {
            const columnExists = Object.keys(csvColumnsRow[0]).some(columnName => {
                columnName = columnName.trim();
                let nameParts = columnName.split('.');
                return columnName == fieldName
                    || nameParts.some(namePart => namePart == fieldName);
            });
            if (!columnExists) {
                const sField = this.data.fieldsInQueryMap.get(fieldName);
                if (!(sField && (sField.isSimpleReference || fieldName == "Id")
                    && this.script.excludeIdsFromCSVFiles)) {
                    csvIssues.push({
                        "Date update": common_1.Common.formatDateTime(new Date()),
                        "sObject name": this.sObjectName,
                        "Field name": fieldName,
                        "Field value": null,
                        "Parent SObject name": null,
                        "Parent field name": null,
                        "Parent field value": null,
                        "Error": this.logger.getResourceString(logger_1.RESOURCES.missingColumnsInCsvFile)
                    });
                }
            }
        });
        return csvIssues;
    }
    async repairCSV(cachedCSVContent, fixColumns) {
        let self = this;
        let csvIssues = new Array();
        let currentFileMap = await common_1.Common.readCsvFileOnceAsync(cachedCSVContent.csvDataCacheMap, this.data.sourceCsvFilename, null, null, false, false);
        if (currentFileMap.size == 0) {
            return csvIssues;
        }
        let firstRow = currentFileMap.values().next().value;
        if (fixColumns) {
            ___trimColumnNames(firstRow);
            if (this.scriptObject.useCSVValuesMapping && this.job.valueMapping.size > 0) {
                ___mapCSVValues(firstRow);
            }
            if (!firstRow.hasOwnProperty("Id")) {
                ___addMissingIdColumn();
            }
        }
        else {
            if (!firstRow.hasOwnProperty("Id") || this.script.excludeIdsFromCSVFiles) {
                let child__rSFields = this.scriptObject.externalIdSFieldDescribe.child__rSFields;
                for (let fieldIndex = 0; fieldIndex < child__rSFields.length; fieldIndex++) {
                    const childIdSField = child__rSFields[fieldIndex].idSField;
                    await ___updateChildOriginalIdColumnsAsync(childIdSField);
                }
            }
            for (let fieldIndex = 0; fieldIndex < this.data.fieldsInQuery.length; fieldIndex++) {
                const sField = this.data.fieldsInQueryMap.get(this.data.fieldsInQuery[fieldIndex]);
                if (sField.lookup && (!firstRow.hasOwnProperty(sField.fullName__r) || !firstRow.hasOwnProperty(sField.nameId))) {
                    await ___addMissingLookupColumnsAsync(sField);
                }
            }
            ___fixOldRecordTypeColumns();
        }
        return csvIssues;
        function ___mapCSVValues(firstRow) {
            self.logger.infoNormal(logger_1.RESOURCES.mappingCsvValues, self.sObjectName);
            let fields = Object.keys(firstRow);
            let csvRows = [...currentFileMap.values()];
            fields.forEach(field => {
                let key = self.sObjectName + field;
                let valuesMap = self.job.valueMapping.get(key);
                if (valuesMap && valuesMap.size > 0) {
                    csvRows.forEach((csvRow) => {
                        let rawValue = (String(csvRow[field]) || "").trim();
                        if (valuesMap.has(rawValue)) {
                            csvRow[field] = valuesMap.get(rawValue);
                        }
                    });
                }
            });
            cachedCSVContent.updatedFilenames.add(self.data.sourceCsvFilename);
        }
        function ___trimColumnNames(firstRow) {
            let columnsToUpdate = new Array();
            Object.keys(firstRow).forEach(field => {
                if (field != field.trim()) {
                    columnsToUpdate.push(field);
                }
            });
            if (columnsToUpdate.length > 0) {
                let csvRows = [...currentFileMap.values()];
                columnsToUpdate.forEach(column => {
                    let newColumn = column.trim();
                    csvRows.forEach((csvRow) => {
                        csvRow[newColumn] = csvRow[column];
                        delete csvRow[column];
                    });
                });
                cachedCSVContent.updatedFilenames.add(self.data.sourceCsvFilename);
            }
        }
        function ___addMissingIdColumn() {
            [...currentFileMap.keys()].forEach(id => {
                let csvRow = currentFileMap.get(id);
                csvRow["Id"] = id;
            });
            cachedCSVContent.updatedFilenames.add(self.data.sourceCsvFilename);
        }
        function ___fixOldRecordTypeColumns() {
            if (self.sObjectName != statics_1.CONSTANTS.RECORD_TYPE_SOBJECT_NAME) {
                let sField = [...self.data.fieldsInQueryMap.values()].find(field => {
                    return field.lookup && field.parentLookupObject.name == statics_1.CONSTANTS.RECORD_TYPE_SOBJECT_NAME;
                });
                if (sField) {
                    let oldColumnName = statics_1.CONSTANTS.OLD_DEFAULT_RECORD_TYPE_ID_FIELD_R_NAME;
                    let newColumnName = sField.fullName__r;
                    let isUpdated = false;
                    [...currentFileMap.values()].forEach(row => {
                        if (row.hasOwnProperty(oldColumnName)) {
                            isUpdated = true;
                            row[newColumnName] = row[oldColumnName];
                            delete row[oldColumnName];
                        }
                    });
                    if (isUpdated) {
                        cachedCSVContent.updatedFilenames.add(self.data.sourceCsvFilename);
                    }
                }
            }
            else {
                let oldColumnNames = self.scriptObject.externalId.split(statics_1.CONSTANTS.COMPLEX_FIELDS_SEPARATOR);
                let newColumnName = self.scriptObject.complexExternalId;
                let isUpdated = false;
                [...currentFileMap.values()].forEach(row => {
                    if (!row.hasOwnProperty(newColumnName)) {
                        isUpdated = true;
                        row[newColumnName] = oldColumnNames.map(name => {
                            let value = row[name];
                            if (value) {
                                delete row[name];
                                return value;
                            }
                        }).filter(value => !!value).join(statics_1.CONSTANTS.COMPLEX_FIELDS_SEPARATOR);
                    }
                });
                if (isUpdated) {
                    cachedCSVContent.updatedFilenames.add(self.data.sourceCsvFilename);
                }
            }
        }
        async function ___addMissingLookupColumnsAsync(sField) {
            let columnName__r = sField.fullOriginalName__r;
            let columnNameId = sField.nameId;
            let parentExternalId = sField.parentLookupObject.complexOriginalExternalId;
            let parentTask = self.job.getTaskBySObjectName(sField.parentLookupObject.name);
            if (parentTask) {
                let parentFileMap = await common_1.Common.readCsvFileOnceAsync(cachedCSVContent.csvDataCacheMap, parentTask.data.sourceCsvFilename);
                let parentCSVRowsMap = new Map();
                [...parentFileMap.values()].forEach(parentCsvRow => {
                    let key = parentTask.getRecordValue(parentCsvRow, parentExternalId);
                    if (key) {
                        parentCSVRowsMap.set(key, parentCsvRow);
                    }
                });
                [...currentFileMap.keys()].forEach(id => {
                    let csvRow = currentFileMap.get(id);
                    if (!csvRow.hasOwnProperty(columnNameId)) {
                        if (!csvRow.hasOwnProperty(columnName__r)) {
                            cachedCSVContent.updatedFilenames.add(self.data.sourceCsvFilename);
                            csvRow[columnNameId] = cachedCSVContent.nextId;
                            csvRow[columnName__r] = cachedCSVContent.nextId;
                            return;
                        }
                        let desiredExternalIdValue = parentTask.getRecordValue(csvRow, columnName__r);
                        if (desiredExternalIdValue) {
                            cachedCSVContent.updatedFilenames.add(self.data.sourceCsvFilename);
                            let parentCsvRow = parentCSVRowsMap.get(desiredExternalIdValue);
                            if (!parentCsvRow) {
                                if (!self.script.excludeIdsFromCSVFiles) {
                                    csvIssues.push({
                                        "Date update": common_1.Common.formatDateTime(new Date()),
                                        "sObject name": self.sObjectName,
                                        "Field name": columnName__r,
                                        "Field value": desiredExternalIdValue,
                                        "Parent SObject name": sField.parentLookupObject.name,
                                        "Parent field name": parentExternalId,
                                        "Parent field value": null,
                                        "Error": self.logger.getResourceString(logger_1.RESOURCES.missingParentLookupRecords)
                                    });
                                }
                                csvRow[columnNameId] = cachedCSVContent.nextId;
                                parentCsvRow = {
                                    "Id": csvRow[columnNameId],
                                    [parentExternalId]: desiredExternalIdValue
                                };
                                parentFileMap.set(csvRow[columnNameId], parentCsvRow);
                                parentCSVRowsMap.set(desiredExternalIdValue, parentCsvRow);
                                cachedCSVContent.updatedFilenames.add(parentTask.data.sourceCsvFilename);
                            }
                            else {
                                csvRow[columnNameId] = parentCsvRow["Id"];
                            }
                        }
                        else {
                            csvRow[columnNameId] = null;
                        }
                    }
                    else if (!csvRow.hasOwnProperty(columnName__r)) {
                        if (!csvRow.hasOwnProperty(columnNameId)) {
                            cachedCSVContent.updatedFilenames.add(self.data.sourceCsvFilename);
                            csvRow[columnNameId] = cachedCSVContent.nextId;
                            csvRow[columnName__r] = cachedCSVContent.nextId;
                            return;
                        }
                        let idValue = csvRow[columnNameId];
                        if (idValue) {
                            cachedCSVContent.updatedFilenames.add(self.data.sourceCsvFilename);
                            let parentCsvRow = parentFileMap.get(idValue);
                            if (!parentCsvRow) {
                                if (!self.script.excludeIdsFromCSVFiles) {
                                    csvIssues.push({
                                        "Date update": common_1.Common.formatDateTime(new Date()),
                                        "sObject name": self.sObjectName,
                                        "Field name": columnNameId,
                                        "Field value": idValue,
                                        "Parent SObject name": sField.parentLookupObject.name,
                                        "Parent field name": "Id",
                                        "Parent field value": null,
                                        "Error": self.logger.getResourceString(logger_1.RESOURCES.missingParentLookupRecords)
                                    });
                                }
                                csvRow[columnName__r] = cachedCSVContent.nextId;
                                parentCsvRow = {
                                    "Id": idValue,
                                    [parentExternalId]: csvRow[columnName__r]
                                };
                                parentFileMap.set(idValue, parentCsvRow);
                                parentCSVRowsMap.set(csvRow[columnName__r], parentCsvRow);
                                cachedCSVContent.updatedFilenames.add(parentTask.data.sourceCsvFilename);
                            }
                            else {
                                cachedCSVContent.updatedFilenames.add(self.data.sourceCsvFilename);
                                csvRow[columnName__r] = parentCsvRow[parentExternalId];
                            }
                        }
                        else {
                            csvRow[columnName__r] = null;
                        }
                    }
                });
            }
        }
        async function ___updateChildOriginalIdColumnsAsync(childIdSField) {
            let columnChildOriginalName__r = childIdSField.fullOriginalName__r;
            let columnChildIdName__r = childIdSField.fullIdName__r;
            let columnChildNameId = childIdSField.nameId;
            let parentOriginalExternalIdColumnName = self.scriptObject.complexOriginalExternalId;
            if (parentOriginalExternalIdColumnName != "Id") {
                let childTask = self.job.getTaskBySObjectName(childIdSField.scriptObject.name);
                if (childTask) {
                    let childFileMap = await common_1.Common.readCsvFileOnceAsync(cachedCSVContent.csvDataCacheMap, childTask.data.sourceCsvFilename);
                    if (childFileMap.size > 0) {
                        let childCSVFirstRow = childFileMap.values().next().value;
                        if (childCSVFirstRow.hasOwnProperty(columnChildOriginalName__r)) {
                            let parentCSVExtIdMap = new Map();
                            [...currentFileMap.values()].forEach(csvRow => {
                                let key = self.getRecordValue(csvRow, parentOriginalExternalIdColumnName);
                                if (key) {
                                    parentCSVExtIdMap.set(key, csvRow);
                                }
                            });
                            [...childFileMap.values()].forEach(csvRow => {
                                let extIdValue = self.getRecordValue(csvRow, columnChildOriginalName__r);
                                if (extIdValue && parentCSVExtIdMap.has(extIdValue)) {
                                    csvRow[columnChildNameId] = parentCSVExtIdMap.get(extIdValue)["Id"];
                                    csvRow[columnChildIdName__r] = csvRow[columnChildNameId];
                                    cachedCSVContent.updatedFilenames.add(childTask.data.sourceCsvFilename);
                                }
                            });
                        }
                    }
                }
            }
        }
    }
    getRecordValue(record, propName) {
        if (!record)
            return null;
        return record[propName];
    }
    getCSVFilename(rootPath, pattern) {
        return common_1.Common.getCSVFilename(rootPath, this.sObjectName, pattern);
    }
    createQuery(fieldNames, removeLimits = false, parsedQuery, useFieldMapping = false, isTargetQuery = false) {
        let self = this;
        parsedQuery = parsedQuery || this.scriptObject.parsedQuery;
        let tempQuery = deepClone.deepCloneSync(parsedQuery, {
            absolute: true,
        });
        if (!fieldNames)
            tempQuery.fields = this.data.fieldsInQuery.map(fieldName => (0, soql_parser_js_1.getComposedField)(fieldName));
        else
            tempQuery.fields = fieldNames.map(fieldName => (0, soql_parser_js_1.getComposedField)(fieldName));
        if (removeLimits) {
            tempQuery.limit = undefined;
            tempQuery.offset = undefined;
            tempQuery.orderBy = undefined;
        }
        if (isTargetQuery) {
            ___filterTargetQuery(tempQuery);
        }
        else if (this.scriptObject.sourceRecordsFilter) {
            try {
                const additionalWhereClause = (0, soql_parser_js_1.parseQuery)(`SELECT Id FROM ${this.sObjectName} WHERE ${this.scriptObject.sourceRecordsFilter}`).where;
                tempQuery.where = common_1.Common.mergeWhereClauses(tempQuery.where, additionalWhereClause);
            }
            catch (ex) {
                self.logger.warn(logger_1.RESOURCES.skippedSourceRecordsFilterWarning, ex.message);
            }
        }
        let query = (0, soql_parser_js_1.composeQuery)(tempQuery);
        if (useFieldMapping) {
            query = this._mapSourceQueryToTarget(query, parsedQuery.sObject).query;
        }
        return query;
        function ___filterTargetQuery(tempQuery) {
            if (!tempQuery)
                return;
            if (tempQuery['sObject']) {
                tempQuery = tempQuery;
                if (self.scriptObject.queryAllTarget) {
                    tempQuery.where = null;
                    tempQuery.limit = null;
                    tempQuery.offset = null;
                    tempQuery.orderBy = null;
                    return;
                }
                if (tempQuery.where && tempQuery.where.left) {
                    if ((tempQuery.where.left.field || '').toLowerCase() == 'isdeleted') {
                        tempQuery.where = null;
                        return;
                    }
                }
                ___filterTargetQuery(tempQuery.where);
                return;
            }
            tempQuery = tempQuery;
            if (!tempQuery)
                return;
            if (tempQuery.right) {
                if ((tempQuery.right.left.field || '').toLowerCase() == 'isdeleted') {
                    tempQuery.right = null;
                    tempQuery.operator = null;
                }
                else {
                    ___filterTargetQuery(tempQuery.right);
                }
            }
        }
    }
    createShortQueryString(longString) {
        let parts = longString.split("FROM");
        return (this.script.logfullquery ? parts[0] : (parts[0].substr(0, statics_1.CONSTANTS.SHORT_QUERY_STRING_MAXLENGTH) +
            (parts[0].length > statics_1.CONSTANTS.SHORT_QUERY_STRING_MAXLENGTH ? "..." : ""))) +
            " FROM "
            + parts[1].substr(0, statics_1.CONSTANTS.SHORT_QUERY_STRING_MAXLENGTH) +
            (parts[1].length > statics_1.CONSTANTS.SHORT_QUERY_STRING_MAXLENGTH ? "..." : "");
    }
    createDeleteQuery() {
        if (!this.scriptObject.parsedDeleteQuery) {
            return this.createQuery(["Id"], true, null);
        }
        else {
            return this.createQuery(["Id"], true, this.scriptObject.parsedDeleteQuery);
        }
    }
    async getTotalRecordsCountAsync() {
        if (this.sourceData.media == enumerations_1.DATA_MEDIA_TYPE.Org) {
            let queryOrNumber = this.createQuery(['COUNT(Id) CNT'], true);
            try {
                let apiSf = new sfdx_1.Sfdx(this.sourceData.org);
                let ret = await apiSf.queryOrgAsync(queryOrNumber, false);
                this.sourceTotalRecorsCount = Number.parseInt(ret[0]["CNT"]);
                if (this.scriptObject.parsedQuery.limit) {
                    this.sourceTotalRecorsCount = Math.min(this.sourceTotalRecorsCount, this.scriptObject.parsedQuery.limit);
                }
                this.logger.infoNormal(logger_1.RESOURCES.totalRecordsAmountByQueryString, this.sObjectName, String(this.sourceTotalRecorsCount), this.sourceData.resourceString_Source_Target);
            }
            catch (ex) {
                this.sourceTotalRecorsCount = this.scriptObject.parsedQuery.limit || 0;
            }
        }
        if (this.targetData.media == enumerations_1.DATA_MEDIA_TYPE.Org) {
            let queryOrNumber = this.createQuery(['COUNT(Id) CNT'], true, null, true);
            try {
                let apiSf = new sfdx_1.Sfdx(this.targetData.org);
                let ret = await apiSf.queryOrgAsync(queryOrNumber, false);
                this.targetTotalRecorsCount = Number.parseInt(ret[0]["CNT"]);
                if (this.scriptObject.parsedQuery.limit) {
                    this.targetTotalRecorsCount = Math.min(this.targetTotalRecorsCount, this.scriptObject.parsedQuery.limit);
                }
                this.logger.infoNormal(logger_1.RESOURCES.totalRecordsAmountByQueryString, this.sObjectName, String(this.targetTotalRecorsCount), this.targetData.resourceString_Source_Target);
            }
            catch (ex) {
                this.targetTotalRecorsCount = this.scriptObject.parsedQuery.limit || 0;
            }
        }
    }
    async deleteOldTargetRecords() {
        if (!(this.targetData.media == enumerations_1.DATA_MEDIA_TYPE.Org
            && this.scriptObject.operation != enumerations_1.OPERATION.Readonly
            && this.scriptObject.deleteOldData)) {
            this.logger.infoNormal(logger_1.RESOURCES.nothingToDelete, this.sObjectName);
            return false;
        }
        this.logger.infoNormal(logger_1.RESOURCES.deletingTargetSObjectRecords, this.sObjectName);
        let soql = this.createDeleteQuery();
        let apiSf = new sfdx_1.Sfdx(this.targetData.org);
        let queryResult = await apiSf.queryOrgAsync(soql, this.targetData.useBulkQueryApi, null, this.script.pollingQueryTimeoutMs);
        if (queryResult.length == 0) {
            this.logger.infoNormal(logger_1.RESOURCES.nothingToDelete, this.sObjectName);
            return false;
        }
        this.logger.infoVerbose(logger_1.RESOURCES.amountOfRecordsToDelete, this.sObjectName, String(queryResult.length));
        let recordsToDelete = queryResult.map(x => {
            return {
                Id: x["Id"]
            };
        });
        this.createApiEngine(this.targetData.org, enumerations_1.OPERATION.Delete, recordsToDelete.length, true);
        let resultRecords = await this.apiEngine.executeCRUDMultithreaded(recordsToDelete, this.apiProgressCallback, this.getParallelThreadCount());
        if (resultRecords == null) {
            this._apiOperationError(enumerations_1.OPERATION.Delete);
        }
        this.logger.infoVerbose(logger_1.RESOURCES.deletingRecordsCompleted, this.sObjectName);
        return true;
    }
    async deleteRecords() {
        let recordsToDelete = this.sourceData.records.map(sourceRecord => {
            let targetRecord = this.data.sourceToTargetRecordMap.get(sourceRecord);
            if (targetRecord) {
                return {
                    Id: targetRecord["Id"]
                };
            }
        }).filter(record => !!record);
        this.logger.infoVerbose(logger_1.RESOURCES.amountOfRecordsToDelete, this.sObjectName, String(recordsToDelete.length));
        if (recordsToDelete.length == 0) {
            return 0;
        }
        this.createApiEngine(this.targetData.org, enumerations_1.OPERATION.Delete, recordsToDelete.length, true);
        let resultRecords = await this.apiEngine.executeCRUDMultithreaded(recordsToDelete, this.apiProgressCallback, this.getParallelThreadCount());
        if (resultRecords == null) {
            this._apiOperationError(enumerations_1.OPERATION.Delete);
        }
        this.logger.infoVerbose(logger_1.RESOURCES.deletingRecordsCompleted, this.sObjectName);
        return resultRecords.length;
    }
    async retrieveRecords(queryMode, reversed) {
        let hasRecords = false;
        let records = new Array();
        if (this.operation == enumerations_1.OPERATION.Delete
            && !this.scriptObject.isDeletedFromSourceOperation) {
            return hasRecords;
        }
        ;
        if (queryMode != "target") {
            if ((this.sourceData.media == enumerations_1.DATA_MEDIA_TYPE.File || this.scriptObject.useSourceCSVFile) && queryMode == "forwards") {
                if (!reversed) {
                    let query = this.createQuery();
                    this.logger.infoNormal(logger_1.RESOURCES.queryingAll, this.sObjectName, this.sourceData.resourceString_Source_Target, this.data.resourceString_csvFile, this.data.getResourceString_Step(queryMode));
                    let sfdx = new sfdx_1.Sfdx(this.targetData.org);
                    records = await sfdx.queryOrgOrCsvAsync(query, false, this.data.sourceCsvFilename, this.targetData.fieldsMap, this.scriptObject.useQueryAll, this.script.pollingQueryTimeoutMs);
                    hasRecords = true;
                }
            }
            else if (this.sourceData.media == enumerations_1.DATA_MEDIA_TYPE.Org) {
                if (this.scriptObject.processAllSource && queryMode == "forwards" && !reversed) {
                    let query = this.createQuery();
                    this.logger.infoNormal(logger_1.RESOURCES.queryingAll, this.sObjectName, this.sourceData.resourceString_Source_Target, this.data.resourceString_org, this.data.getResourceString_Step(queryMode));
                    this.logger.infoVerbose(logger_1.RESOURCES.queryString, this.sObjectName, this.createShortQueryString(query));
                    let sfdx = new sfdx_1.Sfdx(this.sourceData.org, this._sourceFieldMapping);
                    records = await sfdx.queryOrgOrCsvAsync(query, this.sourceData.useBulkQueryApi, undefined, undefined, this.scriptObject.useQueryAll, this.script.pollingQueryTimeoutMs);
                    hasRecords = true;
                }
                else if (!this.scriptObject.processAllSource) {
                    let queries = this._createFilteredQueries(queryMode, reversed);
                    if (queries.length > 0) {
                        this.logger.infoNormal(logger_1.RESOURCES.queryingIn, this.sObjectName, this.sourceData.resourceString_Source_Target, this.data.resourceString_org, this.data.getResourceString_Step(queryMode));
                        records = await this._retrieveFilteredRecords(queries, this.sourceData, this._sourceFieldMapping, this.scriptObject.useQueryAll, this.script.pollingQueryTimeoutMs);
                        hasRecords = true;
                    }
                }
            }
            if (hasRecords) {
                let newRecordsCount = this._setExternalIdMap(records, this.sourceData.extIdRecordsMap, this.sourceData.idRecordsMap);
                this.logger.infoNormal(logger_1.RESOURCES.queryingFinished, this.sObjectName, this.sourceData.resourceString_Source_Target, String(newRecordsCount));
            }
            if (this.sourceData.media == enumerations_1.DATA_MEDIA_TYPE.Org && queryMode == "forwards"
                && !this.sourceData.allRecords) {
                records = new Array();
                let inValues = new Array();
                for (let fieldIndex = 0; fieldIndex < this.data.fieldsInQuery.length; fieldIndex++) {
                    const describe = this.data.fieldsInQueryMap.get(this.data.fieldsInQuery[fieldIndex]);
                    if (describe.isSimpleSelfReference) {
                        this.sourceData.records.forEach(sourceRec => {
                            if (sourceRec[describe.name]) {
                                inValues.push(sourceRec[describe.name]);
                            }
                        });
                    }
                }
                if (inValues.length > 0) {
                    this.logger.infoNormal(logger_1.RESOURCES.queryingSelfReferenceRecords, this.sObjectName, this.sourceData.resourceString_Source_Target);
                    inValues = common_1.Common.distinctStringArray(inValues);
                    let sfdx = new sfdx_1.Sfdx(this.sourceData.org, this._sourceFieldMapping);
                    let queries = common_1.Common.createFieldInQueries(this.data.fieldsInQuery, "Id", this.sObjectName, inValues);
                    for (let queryIndex = 0; queryIndex < queries.length; queryIndex++) {
                        const query = queries[queryIndex];
                        this.logger.infoVerbose(logger_1.RESOURCES.queryString, this.sObjectName, this.createShortQueryString(query));
                        records = records.concat(await sfdx.queryOrgOrCsvAsync(query, undefined, undefined, undefined, this.scriptObject.useQueryAll, this.script.pollingQueryTimeoutMs));
                    }
                    if (queries.length > 0) {
                        let newRecordsCount = this._setExternalIdMap(records, this.sourceData.extIdRecordsMap, this.sourceData.idRecordsMap);
                        this.logger.infoNormal(logger_1.RESOURCES.queryingFinished, this.sObjectName, this.sourceData.resourceString_Source_Target, String(newRecordsCount));
                    }
                }
            }
        }
        if (this.scriptObject.isDeletedFromSourceOperation) {
            return hasRecords;
        }
        if (queryMode == "target") {
            hasRecords = false;
            if (this.targetData.media == enumerations_1.DATA_MEDIA_TYPE.Org && this.operation != enumerations_1.OPERATION.Insert) {
                let fieldsInQuery = this.data.fieldsInQuery.filter(field => this.data.fieldsExcludedFromTargetQuery.indexOf(field) < 0);
                let query = this.createQuery(fieldsInQuery, undefined, undefined, undefined, true);
                records = new Array();
                if (this.scriptObject.processAllTarget) {
                    this.logger.infoNormal(logger_1.RESOURCES.queryingAll, this.sObjectName, this.targetData.resourceString_Source_Target, this.data.resourceString_org, this.data.getResourceString_Step(queryMode));
                    this.logger.infoVerbose(logger_1.RESOURCES.queryString, this.sObjectName, this.createShortQueryString(query));
                    let sfdx = new sfdx_1.Sfdx(this.targetData.org, this._targetFieldMapping);
                    records = await sfdx.queryOrgOrCsvAsync(query, this.targetData.useBulkQueryApi, undefined, undefined, undefined, this.script.pollingQueryTimeoutMs);
                    hasRecords = true;
                }
                else {
                    let queries = this._createFilteredQueries(queryMode, reversed, fieldsInQuery);
                    if (queries.length > 0) {
                        this.logger.infoNormal(logger_1.RESOURCES.queryingIn, this.sObjectName, this.targetData.resourceString_Source_Target, this.data.resourceString_org, this.data.getResourceString_Step(queryMode));
                        records = await this._retrieveFilteredRecords(queries, this.targetData, this._targetFieldMapping, undefined, this.script.pollingQueryTimeoutMs);
                        hasRecords = true;
                    }
                }
            }
            if (hasRecords) {
                let newRecordsCount = this._setExternalIdMap(records, this.targetData.extIdRecordsMap, this.targetData.idRecordsMap, true);
                this.logger.infoNormal(logger_1.RESOURCES.queryingFinished, this.sObjectName, this.targetData.resourceString_Source_Target, String(newRecordsCount));
            }
        }
        return hasRecords;
    }
    async updateRecords(updateMode, warnUserCallbackAsync) {
        let self = this;
        this.updateMode = updateMode;
        if (this.scriptObject.isDeletedFromSourceOperation) {
            if (updateMode != "forwards") {
                return 0;
            }
            return (await ___deleteSourceRecords());
        }
        if (this.targetData.media == enumerations_1.DATA_MEDIA_TYPE.File) {
            if (this.operation != enumerations_1.OPERATION.Delete && updateMode == "forwards") {
                this.logger.infoNormal(logger_1.RESOURCES.writingToFile, this.sObjectName, this.data.csvFilename);
                let records = await ___filterRecords(this.sourceData.records);
                records = ___mockRecords(records);
                self.mapRecords(records);
                records = ___removeCSVFileColumns(records);
                await ___writeToTargetCSVFile(records);
                await common_1.Common.writeCsvFileAsync(self.data.csvFilename, records, true);
                return records.length;
            }
            return 0;
        }
        let totalProcessedRecordsAmount = 0;
        let totalNonProcessedRecordsAmount = 0;
        if (this.operation != enumerations_1.OPERATION.Readonly && this.operation != enumerations_1.OPERATION.Delete) {
            let data = await ___createUpdateData(false);
            if (data.missingParentLookups.length > 0) {
                await warnUserCallbackAsync(data);
            }
            totalProcessedRecordsAmount += (await ___updateData(data));
            totalNonProcessedRecordsAmount += data.nonProcessedRecordsAmount;
            if (this.data.isPersonAccountOrContact) {
                this.logger.infoVerbose(logger_1.RESOURCES.updatePersonAccountsAndContacts, this.sObjectName);
                data = await ___createUpdateData(true);
                if (data.missingParentLookups.length > 0) {
                    await warnUserCallbackAsync(data);
                }
                totalProcessedRecordsAmount += (await ___updateData(data));
                totalNonProcessedRecordsAmount += data.nonProcessedRecordsAmount;
                if ((this.operation == enumerations_1.OPERATION.Insert || this.operation == enumerations_1.OPERATION.Upsert) && this.sObjectName == "Account") {
                    await ___insertPersonContactsFromPersonAccounts(data);
                }
            }
            if (totalNonProcessedRecordsAmount > 0) {
                this.logger.infoNormal(logger_1.RESOURCES.skippedUpdatesWarning, this.sObjectName, String(totalNonProcessedRecordsAmount));
            }
        }
        return totalProcessedRecordsAmount;
        async function ___createUpdateData(processPersonAccounts) {
            let processedData = new __1.ProcessedData();
            processedData.processPersonAccounts = processPersonAccounts;
            processedData.fields = self.data.sFieldsToUpdate.filter((field) => {
                if (updateMode == "forwards")
                    return field.isSimpleNotLookup || field.isSimpleReference && self.data.prevTasks.indexOf(field.parentLookupObject.task) >= 0;
                else
                    return field.isSimpleReference;
            }).concat(new sfieldDescribe_1.default({
                name: statics_1.CONSTANTS.__ID_FIELD_NAME
            }), updateMode == "forwards" ? self.scriptObject.getExtraFieldsToUpdate().map(name => {
                return new sfieldDescribe_1.default({
                    name
                });
            }) : []);
            if (self.operation != enumerations_1.OPERATION.Insert) {
                processedData.fields.push(self.data.sFieldsInQuery.filter(field => field.nameId == "Id")[0]);
            }
            processedData.fields = processedData.fields.filter(x => !!x);
            if (self.data.isPersonAccountOrContact) {
                if (!processPersonAccounts) {
                    processedData.fields = self.sObjectName == "Account" ?
                        processedData.fields.filter((field) => {
                            return !field.person && statics_1.CONSTANTS.FIELDS_TO_EXCLUDE_FROM_UPDATE_FOR_BUSINESS_ACCOUNT.indexOf(field.nameId) < 0;
                        }) : processedData.fields.filter(field => {
                        return statics_1.CONSTANTS.FIELDS_TO_EXCLUDE_FROM_UPDATE_FOR_BUSINESS_CONTACT.indexOf(field.nameId) < 0;
                    });
                }
                else if (self.sObjectName == "Account") {
                    processedData.fields = processedData.fields.filter(field => {
                        return statics_1.CONSTANTS.FIELDS_TO_EXCLUDE_FROM_UPDATE_FOR_PERSON_ACCOUNT.indexOf(field.nameId) < 0;
                    });
                }
                else {
                    return processedData;
                }
            }
            let notUpdateableFields = processedData.fields.filter(field => {
                return field.isDescribed && !field.updateable && field.name != "Id";
            }).map(field => field.nameId);
            let fieldsToCompareRecords = self.data.fieldsToCompareSourceWithTarget;
            let notIsertableFields = fieldsToCompareRecords.filter(field => !processedData.fields.some(f => f.nameId == field));
            notUpdateableFields = notUpdateableFields.concat(notIsertableFields);
            let doNotDeleteIdFieldOnInsert = self.scriptObject.idFieldIsMapped;
            let fieldNamesToClone = processedData.fieldNames.concat(notIsertableFields);
            if (processedData.fields.some(field => field.name != "Id" && field.name != statics_1.CONSTANTS.__ID_FIELD_NAME)) {
                let tempClonedToSourceMap = common_1.Common.cloneArrayOfObjects(self.sourceData.records, fieldNamesToClone);
                let ___IdToClonedMap = new Map();
                [...tempClonedToSourceMap.keys()].forEach(cloned => {
                    ___IdToClonedMap.set(cloned[statics_1.CONSTANTS.__ID_FIELD_NAME], cloned);
                });
                if (self.data.isPersonAccountOrContact) {
                    if (!processPersonAccounts) {
                        tempClonedToSourceMap.forEach((source, cloned) => {
                            if (!source["IsPersonAccount"]) {
                                ___updateLookupIdFields(processedData, source, cloned);
                                ___updatePrsonAccountFields(processedData, source, cloned, false);
                                processedData.clonedToSourceMap.set(cloned, source);
                            }
                        });
                    }
                    else {
                        tempClonedToSourceMap.forEach((source, cloned) => {
                            if (!!source["IsPersonAccount"]) {
                                ___updateLookupIdFields(processedData, source, cloned);
                                ___updatePrsonAccountFields(processedData, source, cloned, true);
                                processedData.clonedToSourceMap.set(cloned, source);
                            }
                        });
                    }
                }
                else {
                    tempClonedToSourceMap.forEach((source, cloned) => {
                        ___updateLookupIdFields(processedData, source, cloned);
                        processedData.clonedToSourceMap.set(cloned, source);
                    });
                }
                tempClonedToSourceMap = processedData.clonedToSourceMap;
                processedData.clonedToSourceMap = new Map();
                let clonedRecords = await ___filterRecords([...tempClonedToSourceMap.keys()]);
                clonedRecords = ___mockRecords(clonedRecords);
                clonedRecords = ___truncateRecords(clonedRecords);
                self.mapRecords(clonedRecords);
                clonedRecords.forEach(cloned => {
                    let initialCloned = ___IdToClonedMap.get(cloned[statics_1.CONSTANTS.__ID_FIELD_NAME]);
                    let source = tempClonedToSourceMap.get(initialCloned);
                    processedData.clonedToSourceMap.set(cloned, source);
                });
                processedData.recordsToInsert = [...processedData.clonedToSourceMap.keys()];
                self.processedData = processedData;
                await self.runAddonEventAsync(enumerations_1.ADDON_EVENTS.onBeforeUpdate);
                processedData.recordsToInsert = new Array();
                processedData.clonedToSourceMap.forEach((source, cloned) => {
                    source[statics_1.CONSTANTS.__IS_PROCESSED_FIELD_NAME] = typeof source[statics_1.CONSTANTS.__IS_PROCESSED_FIELD_NAME] == "undefined" ? false : source[statics_1.CONSTANTS.__IS_PROCESSED_FIELD_NAME];
                    cloned[statics_1.CONSTANTS.__SOURCE_ID_FIELD_NAME] = source["Id"];
                    delete cloned[statics_1.CONSTANTS.__ID_FIELD_NAME];
                    let target = self.data.sourceToTargetRecordMap.get(source);
                    if (target && self.data.task.scriptObject.skipExistingRecords) {
                        source[statics_1.CONSTANTS.__IS_PROCESSED_FIELD_NAME] = true;
                    }
                    else if (target && updateMode == "backwards") {
                        if (target["Id"] && (___compareRecords(target, cloned, fieldsToCompareRecords) || self.scriptObject.skipRecordsComparison)) {
                            cloned["Id"] = target["Id"];
                            ___removeRecordFields(cloned, notUpdateableFields);
                            processedData.recordsToUpdate.push(cloned);
                            source[statics_1.CONSTANTS.__IS_PROCESSED_FIELD_NAME] = true;
                        }
                    }
                    else if (!target && self.operation == enumerations_1.OPERATION.Upsert || self.operation == enumerations_1.OPERATION.Insert) {
                        if (!doNotDeleteIdFieldOnInsert) {
                            delete cloned["Id"];
                        }
                        ___removeRecordFields(cloned, notIsertableFields);
                        processedData.recordsToInsert.push(cloned);
                        source[statics_1.CONSTANTS.__IS_PROCESSED_FIELD_NAME] = true;
                    }
                    else if (target && (self.operation == enumerations_1.OPERATION.Upsert || self.operation == enumerations_1.OPERATION.Update)) {
                        if (target["Id"] && (___compareRecords(target, cloned, fieldsToCompareRecords) || self.scriptObject.skipRecordsComparison)) {
                            cloned["Id"] = target["Id"];
                            ___removeRecordFields(cloned, notUpdateableFields);
                            processedData.recordsToUpdate.push(cloned);
                            source[statics_1.CONSTANTS.__IS_PROCESSED_FIELD_NAME] = true;
                        }
                    }
                });
                processedData.recordsToInsert = __filterInserts(processedData.recordsToInsert);
                processedData.recordsToUpdate = __filterUpdates(processedData.recordsToUpdate);
                __finalDataTransformation(processedData.recordsToInsert);
                __finalDataTransformation(processedData.recordsToUpdate);
            }
            return processedData;
        }
        async function ___deleteSourceRecords() {
            self.logger.infoNormal(logger_1.RESOURCES.deletingSourceSObjectRecords, self.sObjectName);
            if (self.sourceData.records.length == 0) {
                self.logger.infoNormal(logger_1.RESOURCES.nothingToDelete, self.sObjectName);
                return 0;
            }
            self.logger.infoVerbose(logger_1.RESOURCES.amountOfRecordsToDelete, self.sObjectName, String(self.sourceData.records.length));
            let recordsToDelete = self.sourceData.records.map(record => {
                return {
                    Id: record["Id"]
                };
            });
            self.createApiEngine(self.sourceData.org, enumerations_1.OPERATION.Delete, recordsToDelete.length, true);
            let resultRecords = await self.apiEngine.executeCRUDMultithreaded(recordsToDelete, self.apiProgressCallback, self.getParallelThreadCount());
            if (resultRecords == null) {
                self._apiOperationError(enumerations_1.OPERATION.Delete);
            }
            self.logger.infoVerbose(logger_1.RESOURCES.deletingRecordsCompleted, self.sObjectName);
            return resultRecords.length;
        }
        async function ___updateData(data) {
            let totalProcessedAmount = 0;
            let targetFilenameSuffix = data.processPersonAccounts ? statics_1.CONSTANTS.CSV_TARGET_FILE_PERSON_ACCOUNTS_SUFFIX : "";
            if (data.recordsToInsert.length > 0) {
                self.logger.infoVerbose(logger_1.RESOURCES.amountOfRecordsTo, self.sObjectName, self.logger.getResourceString(logger_1.RESOURCES.insert), String((data.recordsToInsert.length)));
                self.createApiEngine(self.targetData.org, enumerations_1.OPERATION.Insert, data.recordsToInsert.length, true, targetFilenameSuffix);
                let targetRecords = await self.apiEngine.executeCRUDMultithreaded(data.recordsToInsert, self.apiProgressCallback, self.getParallelThreadCount());
                if (targetRecords == null) {
                    self._apiOperationError(enumerations_1.OPERATION.Insert);
                }
                totalProcessedAmount += targetRecords.length;
                self._setExternalIdMap(targetRecords, self.targetData.extIdRecordsMap, self.targetData.idRecordsMap);
                targetRecords.forEach(target => {
                    let source = data.clonedToSourceMap.get(target);
                    if (source) {
                        self.data.sourceToTargetRecordMap.set(source, target);
                        data.insertedRecordsSourceToTargetMap.set(source, target);
                    }
                });
            }
            if (data.recordsToUpdate.length > 0) {
                self.logger.infoVerbose(logger_1.RESOURCES.amountOfRecordsTo, self.sObjectName, self.logger.getResourceString(logger_1.RESOURCES.update), String((data.recordsToUpdate.length)));
                self.createApiEngine(self.targetData.org, enumerations_1.OPERATION.Update, data.recordsToUpdate.length, false, targetFilenameSuffix);
                let targetRecords = await self.apiEngine.executeCRUDMultithreaded(data.recordsToUpdate, self.apiProgressCallback, self.getParallelThreadCount());
                if (targetRecords == null) {
                    self._apiOperationError(enumerations_1.OPERATION.Update);
                }
                totalProcessedAmount += targetRecords.length;
                targetRecords.forEach(target => {
                    let source = data.clonedToSourceMap.get(target);
                    if (source && !self.data.sourceToTargetRecordMap.has(source)) {
                        self.data.sourceToTargetRecordMap.set(source, target);
                    }
                });
            }
            await self.runAddonEventAsync(enumerations_1.ADDON_EVENTS.onAfterUpdate);
            return totalProcessedAmount;
        }
        async function ___insertPersonContactsFromPersonAccounts(personAccountsInsertData) {
            let contactTask = self.job.tasks.filter(task => task.sObjectName == "Contact")[0];
            if (contactTask) {
                let targetPersonAccountIdTosourceContactMap = new Map();
                let targetAccountIds = new Array();
                contactTask.sourceData.records.forEach(sourceContact => {
                    let accountId = sourceContact["AccountId"];
                    if (accountId && !contactTask.data.sourceToTargetRecordMap.has(sourceContact)) {
                        let sourceAccount = self.sourceData.idRecordsMap.get(accountId);
                        let targetAccount = personAccountsInsertData.insertedRecordsSourceToTargetMap.get(sourceAccount);
                        if (targetAccount) {
                            let targetAccountId = targetAccount["Id"];
                            if (targetAccountId) {
                                targetPersonAccountIdTosourceContactMap.set(targetAccountId, sourceContact);
                                targetAccountIds.push(targetAccountId);
                            }
                        }
                    }
                });
                let queries = common_1.Common.createFieldInQueries(contactTask.data.fieldsInQuery, "AccountId", contactTask.sObjectName, targetAccountIds);
                if (queries.length > 0) {
                    self.logger.infoNormal(logger_1.RESOURCES.queryingIn2, self.sObjectName, self.logger.getResourceString(logger_1.RESOURCES.personContact));
                    let records = await self._retrieveFilteredRecords(queries, self.targetData, self._targetFieldMapping, undefined, self.script.pollingQueryTimeoutMs);
                    if (records.length > 0) {
                        contactTask._setExternalIdMap(records, contactTask.targetData.extIdRecordsMap, contactTask.targetData.idRecordsMap, true);
                        let newRecordsCount = 0;
                        records.forEach(targetContact => {
                            let accountId = targetContact["AccountId"];
                            let sourceContact = targetPersonAccountIdTosourceContactMap.get(accountId);
                            if (sourceContact && !contactTask.data.sourceToTargetRecordMap.has(sourceContact)) {
                                contactTask.data.sourceToTargetRecordMap.set(sourceContact, targetContact);
                                sourceContact[statics_1.CONSTANTS.__IS_PROCESSED_FIELD_NAME] = true;
                                newRecordsCount++;
                            }
                        });
                        self.logger.infoNormal(logger_1.RESOURCES.queryingFinished, self.sObjectName, self.logger.getResourceString(logger_1.RESOURCES.personContact), String(newRecordsCount));
                        return newRecordsCount;
                    }
                }
            }
            return 0;
        }
        function ___updatePrsonAccountFields(processedData, source, cloned, isPersonRecord) {
            if (self.sObjectName == "Account") {
                if (isPersonRecord) {
                    if (!cloned["FirstName"] && !cloned["LastName"]
                        && processedData.fieldNames.indexOf("FirstName") >= 0) {
                        let parts = (source["Name"] || '').split(' ');
                        cloned["FirstName"] = parts[0] || '';
                        cloned["LastName"] = parts[1] || '';
                        cloned["FirstName"] = !cloned["FirstName"] && !cloned["LastName"] ? common_1.Common.makeId(10) : cloned["FirstName"];
                    }
                }
                else {
                    if (processedData.fieldNames.indexOf("Name") >= 0) {
                        cloned["Name"] = cloned["Name"] || `${source["FirstName"]} ${source["LastName"]}`;
                        cloned["Name"] = !(cloned["Name"] || '').trim() ? common_1.Common.makeId(10) : cloned["Name"];
                    }
                }
            }
        }
        function ___updateLookupIdFields(processedData, source, cloned) {
            processedData.lookupIdFields.forEach(idField => {
                cloned[idField.nameId] = null;
                let found = false;
                let parentId = source[idField.nameId];
                if (parentId) {
                    let parentTask = idField.parentLookupObject.task;
                    let parentRecord = parentTask.sourceData.idRecordsMap.get(parentId);
                    if (parentRecord) {
                        let targetRecord = parentTask.data.sourceToTargetRecordMap.get(parentRecord);
                        if (targetRecord) {
                            let id = targetRecord["Id"];
                            if (id) {
                                cloned[idField.nameId] = id;
                                found = true;
                            }
                        }
                    }
                }
                if (parentId && !found) {
                    let csvRow = {
                        "Date update": common_1.Common.formatDateTime(new Date()),
                        "Record Id": source["Id"],
                        "Lookup field name": idField.nameId,
                        "Lookup reference field name": idField.fullName__r,
                        "sObject name": idField.scriptObject.name,
                        "Parent SObject name": idField.parentLookupObject.name,
                        "Parent ExternalId field name": idField.parentLookupObject.externalId,
                        "Missing parent External Id value": source[idField.fullName__r] || source[idField.nameId]
                    };
                    processedData.missingParentLookups.push(csvRow);
                }
            });
        }
        async function ___filterRecords(records) {
            return new Promise(async (resolve) => {
                self.tempRecords = records;
                await self.runAddonEventAsync(enumerations_1.ADDON_EVENTS.filterRecordsAddons);
                records = self.tempRecords;
                if (!self.scriptObject.targetRecordsFilter) {
                    resolve(records);
                    return;
                }
                try {
                    alasql(`SELECT * FROM ? WHERE ${self.scriptObject.targetRecordsFilter}`, [records], function (selectedRecords) {
                        resolve(selectedRecords);
                    });
                }
                catch (ex) {
                    self.logger.warn(logger_1.RESOURCES.skippedTargetRecordsFilterWarning, ex.message);
                    resolve(records);
                }
            });
        }
        function ___removeRecordFields(record, fieldsToRemove) {
            if (fieldsToRemove.length == 0)
                return;
            fieldsToRemove.forEach(field => {
                delete record[field];
            });
        }
        function ___removeCSVFileColumns(records) {
            let fieldNamesToRemove = self.script.excludeIdsFromCSVFiles ? self.data.sFieldsInQuery.filter(field => {
                return (field.name == "Id" || field.isSimpleReference) && !field.isOriginalExternalIdField
                    || field.is__r && field.name.endsWith('.Id') && field.parentLookupObject.externalId == "Id" && field.parentLookupObject.originalExternalId != "Id";
            }).map(field => field.name) : new Array();
            fieldNamesToRemove = fieldNamesToRemove.concat(statics_1.CONSTANTS.__ID_FIELD_NAME, statics_1.CONSTANTS.__IS_PROCESSED_FIELD_NAME);
            records.forEach(record => {
                fieldNamesToRemove.forEach(fieldName => delete record[fieldName]);
            });
            return records;
        }
        async function ___writeToTargetCSVFile(records) {
            if (self.script.createTargetCSVFiles) {
                await common_1.Common.writeCsvFileAsync(self.data.getTargetCSVFilename(self.operation), records, true);
            }
        }
        function __filterInserts(records) {
            if (self.sObjectName == "AccountContactRelation") {
                let contactTask = self.job.tasks.filter(task => task.sObjectName == "Contact")[0];
                if (contactTask) {
                    records = records.filter(record => {
                        let targetContact = contactTask.targetData.idRecordsMap.get(record["ContactId"]);
                        if (targetContact && targetContact["AccountId"] == record["AccountId"]) {
                            return false;
                        }
                        return true;
                    });
                }
            }
            return records;
        }
        function __filterUpdates(records) {
            return records;
        }
        function __finalDataTransformation(records) {
            if (self.script.sourceOrg.isOrgMedia) {
                records.forEach(record => {
                    Object.keys(record).forEach(fieldName => {
                        if (record[fieldName] == null) {
                            record[fieldName] = '#N/A';
                        }
                    });
                });
            }
        }
        function ___truncateRecords(records) {
            if (records.length == 0) {
                return records;
            }
            if (self.script.allowFieldTruncation) {
                let sfieldsToTruncate = self.data.sFieldsToUpdate.filter(field => field.isTextual
                    && Object.keys(records[0]).indexOf(field.name) >= 0);
                records.forEach(record => {
                    sfieldsToTruncate.forEach(field => {
                        if (field.length > 0) {
                            record[field.name] = record[field.name] && String(record[field.name]).substr(0, field.length);
                        }
                    });
                });
            }
            return records;
        }
        function ___mockRecords(records) {
            let updatedRecords = new Array();
            if (records.length == 0) {
                return updatedRecords;
            }
            let recordIds = records.map(x => x["Id"]);
            let recordFields = Object.keys(records[0]);
            if (self.scriptObject.updateWithMockData && self.scriptObject.mockFields.length > 0) {
                let fieldNameToMockFieldMap = new Map();
                self.data.sFieldsToUpdate.forEach(fieldDescribe => {
                    let mockField = ___getMockPatternByFieldName(fieldDescribe.name);
                    if ((recordFields.indexOf(mockField.name) >= 0
                        || mockField.name == statics_1.CONSTANTS.MOCK_ALL_FIELDS_PATTERN && recordFields.indexOf(fieldDescribe.name))
                        && mockField.pattern) {
                        let fn = mockField.pattern;
                        let mockFieldNameToUse = mockField.name == statics_1.CONSTANTS.MOCK_ALL_FIELDS_PATTERN ? fieldDescribe.name : mockField.name;
                        if (statics_1.CONSTANTS.SPECIAL_MOCK_COMMANDS.some(x => fn.startsWith(x + "("))) {
                            fn = fn.replace(/\(/, `('${mockFieldNameToUse}',`).replace(/\)/, ', value)');
                        }
                        mockField.excludedRegex = mockField.excludedRegex || '';
                        mockField.includedRegex = mockField.includedRegex || '';
                        fieldNameToMockFieldMap.set(mockFieldNameToUse, {
                            fn,
                            regExcl: mockField.excludedRegex.split(statics_1.CONSTANTS.MOCK_PATTERN_ENTIRE_ROW_FLAG)[0].trim(),
                            regIncl: mockField.includedRegex.split(statics_1.CONSTANTS.MOCK_PATTERN_ENTIRE_ROW_FLAG)[0].trim(),
                            disallowMockAllRecord: mockField.excludedRegex.indexOf(statics_1.CONSTANTS.MOCK_PATTERN_ENTIRE_ROW_FLAG) >= 0,
                            allowMockAllRecord: mockField.includedRegex.indexOf(statics_1.CONSTANTS.MOCK_PATTERN_ENTIRE_ROW_FLAG) >= 0,
                        });
                    }
                });
                mockGenerator_1.MockGenerator.resetCounter();
                records.forEach((originalRecord, index) => {
                    let updatedRecord = Object.assign({}, originalRecord);
                    let doNotMock = false;
                    let mockAllRecord = false;
                    let fieldsToMockMap = new Map();
                    [...fieldNameToMockFieldMap.keys()].forEach(fieldName => {
                        if (!doNotMock) {
                            let mockField = fieldNameToMockFieldMap.get(fieldName);
                            let value = updatedRecord[fieldName];
                            let excluded = !!mockField.regExcl && ___testRegex(mockField.regExcl, value);
                            let included = !!mockField.regIncl && ___testRegex(mockField.regIncl, value);
                            if (included && mockField.allowMockAllRecord) {
                                mockAllRecord = true;
                            }
                            if (excluded && mockField.disallowMockAllRecord) {
                                doNotMock = true;
                            }
                            else {
                                if (mockAllRecord || (!mockField.regExcl || !excluded) && (!mockField.regIncl || included)) {
                                    fieldsToMockMap.set(fieldName, true);
                                }
                            }
                        }
                    });
                    if (!doNotMock) {
                        [...fieldNameToMockFieldMap.keys()].forEach(fieldName => {
                            if (mockAllRecord || fieldsToMockMap.has(fieldName)) {
                                const mockField = fieldNameToMockFieldMap.get(fieldName);
                                const value = updatedRecord[fieldName];
                                value == value;
                                if (mockField.fn == "ids") {
                                    updatedRecord[fieldName] = recordIds[index];
                                }
                                else {
                                    updatedRecord[fieldName] = eval(`casual.${mockField.fn}`);
                                }
                            }
                        });
                    }
                    updatedRecords.push(updatedRecord);
                });
            }
            else {
                return records;
            }
            return updatedRecords;
        }
        function ___testRegex(expr, value) {
            switch (expr) {
                case statics_1.CONSTANTS.SPECIAL_MOCK_PATTERNS.get(enumerations_1.SPECIAL_MOCK_PATTERN_TYPES.haveAnyValue):
                    return !!value;
                case statics_1.CONSTANTS.SPECIAL_MOCK_PATTERNS.get(enumerations_1.SPECIAL_MOCK_PATTERN_TYPES.missingValue):
                    return !value;
                default:
                    return new RegExp(expr, 'ig').test(String(value));
            }
        }
        function ___getMockPatternByFieldName(fieldName) {
            return self.scriptObject.mockFields.filter(field => (field.name == fieldName
                || field.name == statics_1.CONSTANTS.MOCK_ALL_FIELDS_PATTERN)
                && !field.excludeNames.includes(fieldName))[0] || new __1.ScriptMockField();
        }
        function ___compareRecords(target, cloned, fieldsToCompareRecords) {
            if (target && !cloned || cloned && !target || self.scriptObject.idFieldIsMapped) {
                return true;
            }
            return Object.keys(cloned)
                .filter(key => fieldsToCompareRecords.length == 0 || fieldsToCompareRecords.indexOf(key) >= 0)
                .some(key => {
                if (key != "Id" && key != statics_1.CONSTANTS.__ID_FIELD_NAME && key != statics_1.CONSTANTS.__SOURCE_ID_FIELD_NAME) {
                    return target[key] != cloned[key];
                }
                return false;
            });
        }
    }
    createApiEngine(org, operation, amountOfRecordsToProcess, updateRecordId, targetFilenameSuffix) {
        let engine;
        if ((amountOfRecordsToProcess > this.script.bulkThreshold && !this.script.alwaysUseRestApiToUpdateRecords)
            && statics_1.CONSTANTS.NOT_SUPPORTED_OBJECTS_IN_BULK_API.indexOf(this.sObjectName) < 0) {
            if (this.scriptObject.hardDelete == true && operation == enumerations_1.OPERATION.Delete) {
                operation = enumerations_1.OPERATION.HardDelete;
            }
            switch (this.script.bulkApiVersionNumber) {
                case 2:
                    engine = new bulkApiV2_0Engine_1.BulkApiV2_0Engine({
                        logger: this.logger,
                        connectionData: org.connectionData,
                        sObjectName: this.sObjectName,
                        operation,
                        pollingIntervalMs: this.script.pollingIntervalMs,
                        concurrencyMode: this.script.concurrencyMode,
                        updateRecordId,
                        targetCSVFullFilename: this.data.getTargetCSVFilename(operation, targetFilenameSuffix),
                        createTargetCSVFiles: this.script.createTargetCSVFiles,
                        targetFieldMapping: this._targetFieldMapping,
                        simulationMode: this.script.simulationMode,
                        binaryDataCache: this.script.binaryDataCache
                    });
                    break;
                default:
                    engine = new bulkApiV1_0Engine_1.BulkApiV1_0Engine({
                        logger: this.logger,
                        connectionData: org.connectionData,
                        sObjectName: this.sObjectName,
                        operation,
                        pollingIntervalMs: this.script.pollingIntervalMs,
                        concurrencyMode: this.script.concurrencyMode,
                        updateRecordId,
                        bulkApiV1BatchSize: this.scriptObject.batchSizes.bulkV1BatchSize,
                        targetCSVFullFilename: this.data.getTargetCSVFilename(operation, targetFilenameSuffix),
                        createTargetCSVFiles: this.script.createTargetCSVFiles,
                        targetFieldMapping: this._targetFieldMapping,
                        simulationMode: this.script.simulationMode,
                        binaryDataCache: this.script.binaryDataCache
                    });
                    break;
            }
        }
        else {
            engine = new restApiEngine_1.RestApiEngine({
                logger: this.logger,
                connectionData: org.connectionData,
                sObjectName: this.sObjectName,
                operation,
                pollingIntervalMs: this.script.pollingIntervalMs,
                concurrencyMode: this.script.concurrencyMode,
                updateRecordId,
                restApiBatchSize: this.scriptObject.batchSizes.restBatchSize,
                allOrNone: this.script.allOrNone,
                targetCSVFullFilename: this.data.getTargetCSVFilename(operation, targetFilenameSuffix),
                createTargetCSVFiles: this.script.createTargetCSVFiles,
                targetFieldMapping: this._targetFieldMapping,
                simulationMode: this.script.simulationMode,
                binaryDataCache: this.script.binaryDataCache,
                binaryCacheDirectory: this.script.binaryCacheDirectory
            });
        }
        this.setApiEngine(engine);
        return this.apiEngine;
    }
    getParallelThreadCount() {
        return this.apiEngine.getIsRestApiEngine() ?
            (this.scriptObject.parallelRestJobs || this.scriptObject.script.parallelRestJobs)
            : (this.scriptObject.parallelBulkJobs || this.scriptObject.script.parallelBulkJobs);
    }
    async runAddonEventAsync(event) {
        return await this.script.addonManager.triggerAddonModuleMethodAsync(event, this.sObjectName);
    }
    setApiEngine(engine) {
        this.apiEngine = engine;
        this.apiProgressCallback = this.apiProgressCallback || this._apiProgressCallback.bind(this);
    }
    mapRecords(records) {
        if (records.length == 0 || !this.scriptObject.useValuesMapping) {
            return;
        }
        this.logger.infoNormal(logger_1.RESOURCES.mappingValues, this.sObjectName);
        let fields = Object.keys(records[0]);
        fields.forEach(field => {
            let key = this.sObjectName + field;
            let valuesMap = this.job.valueMapping.get(key);
            if (valuesMap && valuesMap.size > 0) {
                let sourceExtIdMap;
                let nameId;
                let describe = this.data.sFieldsInQuery.filter(f => {
                    return f.name == field;
                })[0];
                if (describe && describe.is__r) {
                    let parentTask = this.job.getTaskBySObjectName(describe.parentLookupObject.name);
                    if (parentTask) {
                        sourceExtIdMap = parentTask.sourceData.extIdRecordsMap;
                        nameId = describe.nameId;
                    }
                }
                let regexp;
                let regexpReplaceValue;
                valuesMap.forEach((newValue, rawValue) => {
                    try {
                        if (new RegExp(statics_1.CONSTANTS.FIELDS_MAPPING_REGEX_PATTERN).test(rawValue)) {
                            let pattern = rawValue.replace(new RegExp(statics_1.CONSTANTS.FIELDS_MAPPING_REGEX_PATTERN), '$1');
                            regexpReplaceValue = newValue;
                            regexp = regexpReplaceValue && new RegExp(pattern, 'gi');
                        }
                    }
                    catch (ex) { }
                });
                records.forEach((record) => {
                    let newValue;
                    let rawValue = (record[field] == undefined ? "" : String(record[field])).trim();
                    if (regexp) {
                        try {
                            if (regexp.test(rawValue)) {
                                const replaceValue = __eval(rawValue, regexpReplaceValue);
                                newValue = rawValue.replace(regexp, replaceValue);
                            }
                        }
                        catch (ex) { }
                    }
                    newValue = newValue ? valuesMap.get(String(newValue)) || newValue : valuesMap.get(rawValue) || rawValue;
                    newValue = newValue == 'TRUE' || newValue == 'true' ? true :
                        newValue == 'FALSE' || newValue == 'false' ? false :
                            newValue == 'null' || newValue == 'NULL' || newValue == 'undefined' || newValue == '#N/A' || newValue == undefined ? null : newValue;
                    newValue = __eval(rawValue, newValue);
                    if (new RegExp(statics_1.CONSTANTS.FIELDS_MAPPING_EVAL_PATTERN, 'i').test(newValue)) {
                        let expr = newValue.replace(new RegExp(statics_1.CONSTANTS.FIELDS_MAPPING_EVAL_PATTERN, 'i'), '$1');
                        expr = expr.replace(new RegExp(statics_1.CONSTANTS.FIELD_MAPPING_EVAL_PATTERN_ORIGINAL_VALUE, 'gi'), rawValue);
                        try {
                            newValue = eval(expr);
                        }
                        catch (ex) { }
                    }
                    if (typeof newValue != 'undefined') {
                        record[field] = newValue;
                    }
                    if (nameId && record.hasOwnProperty(nameId)) {
                        let newValueId = sourceExtIdMap.get(newValue);
                        if (newValueId) {
                            record[nameId] = newValueId;
                        }
                    }
                });
            }
        });
        function __eval(rawValue, newValue) {
            if (new RegExp(statics_1.CONSTANTS.FIELDS_MAPPING_EVAL_PATTERN, 'i').test(newValue)) {
                let expr = newValue.replace(new RegExp(statics_1.CONSTANTS.FIELDS_MAPPING_EVAL_PATTERN, 'i'), '$1');
                expr = expr.replace(new RegExp(statics_1.CONSTANTS.FIELD_MAPPING_EVAL_PATTERN_ORIGINAL_VALUE, 'gi'), rawValue);
                try {
                    newValue = eval(expr);
                }
                catch (ex) { }
            }
            return newValue;
        }
    }
    _apiProgressCallback(apiResult) {
        let verbosity = logger_1.LOG_MESSAGE_VERBOSITY.VERBOSE;
        let logMessageType = logger_1.LOG_MESSAGE_TYPE.STRING;
        switch (apiResult.messageImportance) {
            case enumerations_1.MESSAGE_IMPORTANCE.Silent:
                verbosity = logger_1.LOG_MESSAGE_VERBOSITY.NONE;
                break;
            case enumerations_1.MESSAGE_IMPORTANCE.Normal:
                verbosity = logger_1.LOG_MESSAGE_VERBOSITY.NORMAL;
                break;
            case enumerations_1.MESSAGE_IMPORTANCE.High:
                verbosity = logger_1.LOG_MESSAGE_VERBOSITY.MINIMAL;
                break;
            case enumerations_1.MESSAGE_IMPORTANCE.Warn:
                verbosity = logger_1.LOG_MESSAGE_VERBOSITY.MINIMAL;
                logMessageType = logger_1.LOG_MESSAGE_TYPE.WARN;
                break;
            case enumerations_1.MESSAGE_IMPORTANCE.Error:
                verbosity = logger_1.LOG_MESSAGE_VERBOSITY.MINIMAL;
                logMessageType = logger_1.LOG_MESSAGE_TYPE.ERROR;
                break;
        }
        switch (apiResult.resultStatus) {
            case enumerations_1.RESULT_STATUSES.Information:
                if (apiResult.informationMessageData.length > 0) {
                    let resourceString = this.logger.getResourceString.apply(this.logger, [apiResult.informationMessageData[0], ...apiResult.informationMessageData.slice(1)]);
                    this.logger.log.apply(this.logger, [resourceString, logMessageType, verbosity]);
                }
                break;
            case enumerations_1.RESULT_STATUSES.ApiOperationStarted:
                let simulationModeResourceString = this.script.simulationMode ? this.logger.getResourceString(logger_1.RESOURCES.simulationMode) : "";
                this.logger.log(logger_1.RESOURCES.apiOperationStarted, logMessageType, verbosity, this.sObjectName, this.apiEngine.getStrOperation(), this.apiEngine.getEngineName(), simulationModeResourceString);
                break;
            case enumerations_1.RESULT_STATUSES.ApiOperationFinished:
                this.logger.log(logger_1.RESOURCES.apiOperationFinished, logMessageType, verbosity, this.sObjectName, this.apiEngine.getStrOperation());
                break;
            case enumerations_1.RESULT_STATUSES.JobCreated:
                this.logger.log(logger_1.RESOURCES.apiOperationJobCreated, logMessageType, verbosity, apiResult.jobId, this.apiEngine.getStrOperation(), this.sObjectName);
                break;
            case enumerations_1.RESULT_STATUSES.BatchCreated:
                this.logger.log(logger_1.RESOURCES.apiOperationBatchCreated, logMessageType, verbosity, apiResult.batchId, this.apiEngine.getStrOperation(), this.sObjectName);
                break;
            case enumerations_1.RESULT_STATUSES.DataUploaded:
                this.logger.log(logger_1.RESOURCES.apiOperationDataUploaded, logMessageType, verbosity, apiResult.batchId, this.apiEngine.getStrOperation(), this.sObjectName);
                break;
            case enumerations_1.RESULT_STATUSES.InProgress:
                this.logger.log(logger_1.RESOURCES.apiOperationInProgress, logMessageType, verbosity, apiResult.batchId, this.apiEngine.getStrOperation(), this.sObjectName, String(apiResult.numberRecordsProcessed), String(apiResult.numberRecordsFailed));
                break;
            case enumerations_1.RESULT_STATUSES.Completed:
                this.logger.log(logMessageType != logger_1.LOG_MESSAGE_TYPE.WARN ? logger_1.RESOURCES.apiOperationCompleted : logger_1.RESOURCES.apiOperationWarnCompleted, logMessageType, verbosity, apiResult.batchId, this.apiEngine.getStrOperation(), this.sObjectName, String(apiResult.numberRecordsProcessed), String(apiResult.numberRecordsFailed));
                break;
            case enumerations_1.RESULT_STATUSES.ProcessError:
            case enumerations_1.RESULT_STATUSES.FailedOrAborted:
                if (apiResult.errorMessage)
                    this.logger.log(logger_1.RESOURCES.apiOperationFailedWithMessage, logMessageType, verbosity, this.sObjectName, this.apiEngine.getStrOperation(), apiResult.errorMessage);
                else
                    this.logger.log(logger_1.RESOURCES.apiOperationFailed, logMessageType, verbosity, this.sObjectName, this.apiEngine.getStrOperation());
                break;
        }
    }
    _apiOperationError(operation) {
        throw new __1.CommandExecutionError(this.logger.getResourceString(logger_1.RESOURCES.apiOperationFailed, this.sObjectName, enumerations_1.OPERATION[operation] || this.apiEngine.getStrOperation()));
    }
    _createFilteredQueries(queryMode, reversed, fieldNames) {
        let queries = new Array();
        let fieldsToQueryMap = new Map();
        let isSource = queryMode != "target";
        if (reversed) {
            if (statics_1.CONSTANTS.OBJECTS_NOT_TO_USE_IN_FILTERED_QUERYIN_CLAUSE.indexOf(this.sObjectName) < 0) {
                let fields = common_1.Common.flatMap(this.data.sFieldsInQuery
                    .filter(field => field.child__rSFields.length > 0), (field) => {
                    return field.child__rSFields.map(f => f.idSField);
                });
                let values = new Array();
                fields.forEach((field) => {
                    values = values.concat(field.scriptObject.task.sourceData.records
                        .map((value) => value[field.nameId])
                        .filter(value => !!value));
                });
                values = common_1.Common.distinctStringArray(values);
                fieldsToQueryMap.set(new sfieldDescribe_1.default({
                    name: "Id"
                }), values);
            }
        }
        else {
            this.data.sFieldsInQuery.forEach(field => {
                if (isSource) {
                    if (field.isSimpleReference
                        && field.parentLookupObject.isInitialized
                        && statics_1.CONSTANTS.OBJECTS_NOT_TO_USE_IN_FILTERED_QUERYIN_CLAUSE.indexOf(field.referencedObjectType) < 0) {
                        if (queryMode != "forwards") {
                            if (this.data.prevTasks.indexOf(field.parentLookupObject.task) >= 0) {
                                fieldsToQueryMap.set(field, [...field.parentLookupObject.task.sourceData.idRecordsMap.keys()]);
                            }
                        }
                        else {
                            if (this.data.nextTasks.indexOf(field.parentLookupObject.task) >= 0) {
                                fieldsToQueryMap.set(field, [...field.parentLookupObject.task.sourceData.idRecordsMap.keys()]);
                            }
                        }
                    }
                }
                else {
                    if (field.isSimpleNotLookup && field.isExternalIdField) {
                        fieldsToQueryMap.set(field, [...this.sourceData.extIdRecordsMap.keys()]);
                    }
                }
            });
        }
        let where;
        if (isSource && this.scriptObject.isLimitedQuery && !reversed) {
            where = common_1.Common.extractWhereClause(this.scriptObject.query);
        }
        fieldsToQueryMap.forEach((inValues, field) => {
            let valueCache = this.tempData.filteredQueryValueCache.get(field.name);
            if (!valueCache) {
                valueCache = new Set();
                this.tempData.filteredQueryValueCache.set(field.name, valueCache);
            }
            inValues = inValues.filter(inValue => !valueCache.has(inValue));
            if (inValues.length > 0) {
                inValues.forEach(inValue => {
                    valueCache.add(inValue);
                });
                common_1.Common.createFieldInQueries(fieldNames || this.data.fieldsInQuery, field.name, this.sObjectName, inValues, where).forEach(query => {
                    queries.push(query);
                });
            }
        });
        return queries;
    }
    _setExternalIdMap(records, extIdToRecordIdMap, recordIdToRecordMap, isTarget = false) {
        let newRecordsCount = 0;
        records.forEach(record => {
            if (record["Id"]) {
                let externalIdValue = this.getRecordValue(record, this.complexExternalId);
                if (externalIdValue) {
                    extIdToRecordIdMap.set(externalIdValue, record["Id"]);
                }
                if (!recordIdToRecordMap.has(record["Id"])) {
                    recordIdToRecordMap.set(record["Id"], record);
                    record[statics_1.CONSTANTS.__ID_FIELD_NAME] = record["Id"];
                    if (isTarget) {
                        let extIdValue = this.getRecordValue(record, this.complexExternalId);
                        if (extIdValue) {
                            let sourceId = this.sourceData.extIdRecordsMap.get(extIdValue);
                            if (sourceId) {
                                let sourceRecord = this.sourceData.idRecordsMap.get(sourceId);
                                this.data.sourceToTargetRecordMap.set(sourceRecord, record);
                            }
                        }
                    }
                    newRecordsCount++;
                }
            }
            else {
                record[statics_1.CONSTANTS.__ID_FIELD_NAME] = common_1.Common.makeId(18);
            }
        });
        return newRecordsCount;
    }
    async _retrieveFilteredRecords(queries, orgData, targetFieldMapping, useQueryAll, pollingQueryTimeoutMs) {
        let sfdx = new sfdx_1.Sfdx(orgData.org, targetFieldMapping);
        let records = new Array();
        for (let index = 0; index < queries.length; index++) {
            const query = queries[index];
            this.logger.infoVerbose(logger_1.RESOURCES.queryString, this.sObjectName, this.createShortQueryString(query));
            records = records.concat(await sfdx.queryOrgOrCsvAsync(query, false, undefined, undefined, useQueryAll, pollingQueryTimeoutMs));
        }
        return records;
    }
    _transformQuery(query, sourceSObjectName) {
        let sourceParsedQuery = (0, soql_parser_js_1.parseQuery)(query);
        sourceSObjectName = sourceParsedQuery.sObject;
        let scriptObject = this.script.objectsMap.get(sourceSObjectName);
        let extraObjectDescr = this.script.extraSObjectDescriptions.get(sourceSObjectName);
        let fields = [];
        sourceParsedQuery.fields.forEach((f) => {
            let field = f;
            let rawValue = String(field["rawValue"] || field.field);
            let fieldToAdd = rawValue;
            if (scriptObject) {
                let describe = scriptObject.fieldsInQueryMap.get(rawValue);
                describe = describe || [...scriptObject.fieldsInQueryMap.values()]
                    .filter(field => field.__rNames.filter(x => x == rawValue)[0])
                    .filter(x => !!x)[0];
                if (describe) {
                    if (describe.isPolymorphicField && describe.is__r) {
                        fieldToAdd = describe.getPolymorphicQueryField(rawValue);
                    }
                }
            }
            if (extraObjectDescr && statics_1.CONSTANTS.OBJECTS_TO_FERIFY_IN_QUERY_TRANSFORM.indexOf(sourceSObjectName) >= 0) {
                if (!extraObjectDescr.fieldsMap.has(rawValue)) {
                    fieldToAdd = '';
                }
            }
            if (fieldToAdd) {
                fields.push((0, soql_parser_js_1.getComposedField)(fieldToAdd));
            }
        });
        sourceParsedQuery.fields = fields;
        query = (0, soql_parser_js_1.composeQuery)(sourceParsedQuery);
        return {
            targetSObjectName: sourceSObjectName,
            query
        };
    }
    _mapSourceQueryToTarget(query, sourceSObjectName) {
        let mapping = this.script.sourceTargetFieldMapping.get(sourceSObjectName);
        if (mapping && mapping.hasChange) {
            let scriptObject = this.script.objectsMap.get(sourceSObjectName);
            if (scriptObject) {
                let targetParsedQuery = (0, soql_parser_js_1.parseQuery)(query);
                targetParsedQuery.sObject = mapping.targetSObjectName;
                let fields = [];
                targetParsedQuery.fields.forEach((f) => {
                    let field = f;
                    let rawValue = String(field["rawValue"] || field.field);
                    let describe = scriptObject.fieldsInQueryMap.get(rawValue);
                    if (describe) {
                        let targetField = describe.targetName + (field["alias"] ? " " + field["alias"] : "");
                        fields.push((0, soql_parser_js_1.getComposedField)(targetField));
                        if (rawValue == "Id") {
                            fields.unshift((0, soql_parser_js_1.getComposedField)(rawValue));
                        }
                    }
                    else {
                        let targetField = rawValue + (field["alias"] ? " " + field["alias"] : "");
                        fields.push((0, soql_parser_js_1.getComposedField)(targetField));
                    }
                });
                fields = common_1.Common.distinctArray(fields, 'field');
                targetParsedQuery.fields = fields;
                if (targetParsedQuery.where) {
                    let left = targetParsedQuery.where.left;
                    let right = targetParsedQuery.where.right;
                    while (left) {
                        let describe = scriptObject.fieldsInQueryMap.get(left.field);
                        if (describe) {
                            left.field = describe.targetName;
                        }
                        left = right && right.left;
                        right = right && right.right;
                    }
                }
                query = (0, soql_parser_js_1.composeQuery)(targetParsedQuery);
                this.logger.infoNormal(logger_1.RESOURCES.mappingQuery, this.sObjectName, mapping.targetSObjectName, this.createShortQueryString(query));
                return {
                    targetSObjectName: mapping.targetSObjectName,
                    query
                };
            }
        }
        return {
            targetSObjectName: sourceSObjectName,
            query
        };
    }
    _mapSourceRecordsToTarget(records, sourceSObjectName) {
        let mapping = this.script.sourceTargetFieldMapping.get(sourceSObjectName);
        if (mapping && mapping.hasChange && records) {
            let scriptObject = this.script.objectsMap.get(sourceSObjectName);
            if (scriptObject) {
                this.logger.infoNormal(logger_1.RESOURCES.mappingSourceRecords, this.sObjectName, mapping.targetSObjectName);
                let fieldMapping = scriptObject.sourceToTargetFieldNameMap;
                records.forEach(record => {
                    fieldMapping.forEach((newProp, oldProp) => {
                        if (newProp != oldProp && record.hasOwnProperty(oldProp)) {
                            if (oldProp != "Id") {
                                record[newProp] = record[oldProp];
                                delete record[oldProp];
                            }
                            else {
                                record[newProp] = record[statics_1.CONSTANTS.__SOURCE_ID_FIELD_NAME];
                            }
                        }
                    });
                    delete record[statics_1.CONSTANTS.__SOURCE_ID_FIELD_NAME];
                });
                return {
                    targetSObjectName: mapping.targetSObjectName,
                    records
                };
            }
        }
        records.forEach(record => {
            delete record[statics_1.CONSTANTS.__SOURCE_ID_FIELD_NAME];
        });
        return {
            targetSObjectName: sourceSObjectName,
            records
        };
    }
    _mapTargetRecordsToSource(records, sourceSObjectName) {
        let mapping = this.script.sourceTargetFieldMapping.get(sourceSObjectName);
        if (mapping && mapping.hasChange && records) {
            let scriptObject = this.script.objectsMap.get(sourceSObjectName);
            if (scriptObject) {
                this.logger.infoNormal(logger_1.RESOURCES.mappingTargetRecords, this.sObjectName, mapping.targetSObjectName);
                let fieldMapping = scriptObject.sourceToTargetFieldNameMap;
                records.forEach(record => {
                    fieldMapping.forEach((newProp, oldProp) => {
                        if (newProp != oldProp && record.hasOwnProperty(newProp)) {
                            if (oldProp != "Id") {
                                record[oldProp] = record[newProp];
                            }
                            delete record[newProp];
                        }
                    });
                });
                return {
                    targetSObjectName: mapping.targetSObjectName,
                    records
                };
            }
        }
        return {
            targetSObjectName: sourceSObjectName,
            records
        };
    }
}
exports.default = MigrationJobTask;
//# sourceMappingURL=migrationJobTask.js.map