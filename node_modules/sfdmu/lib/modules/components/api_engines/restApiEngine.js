"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RestApiEngine = void 0;
const models_1 = require("../../models");
const api_models_1 = require("../../models/api_models");
const common_1 = require("../common_components/common");
const enumerations_1 = require("../common_components/enumerations");
const logger_1 = require("../common_components/logger");
const sfdx_1 = require("../common_components/sfdx");
const statics_1 = require("../common_components/statics");
class RestApiEngine extends api_models_1.ApiEngineBase {
    constructor(init) {
        super(init);
    }
    getEngineName() {
        return "REST API";
    }
    async createCRUDApiJobAsync(allRecords) {
        this._fixRecords(allRecords);
        let connection = sfdx_1.Sfdx.createOrgConnection(this.connectionData);
        let chunks;
        if (!this.restApiBatchSize) {
            chunks = new models_1.CsvChunks().fromArray(this.getSourceRecordsArray(allRecords));
        }
        else {
            let recordChunks = common_1.Common.chunkArray(this.getSourceRecordsArray(allRecords), this.restApiBatchSize);
            chunks = new models_1.CsvChunks().fromArrayChunks(recordChunks);
        }
        this.apiJobCreateResult = {
            chunks,
            apiInfo: new api_models_1.ApiInfo({
                jobState: "Undefined",
                strOperation: this.strOperation,
                sObjectName: this.sObjectName,
                jobId: "REST",
                batchId: "REST"
            }),
            allRecords,
            connection
        };
        return this.apiJobCreateResult;
    }
    async processCRUDApiBatchAsync(csvChunk, progressCallback) {
        let self = this;
        return new Promise((resolve, reject) => {
            self.loadBinaryDataFromCache(csvChunk.records);
            if (progressCallback) {
                progressCallback(new api_models_1.ApiInfo({
                    jobState: "OperationStarted"
                }));
            }
            let connection = this.apiJobCreateResult.connection;
            let apiInfo = this.apiJobCreateResult.apiInfo;
            let records = csvChunk.records;
            let apiFunctionName;
            switch (this.operation) {
                case enumerations_1.OPERATION.Insert:
                    apiFunctionName = "create";
                    break;
                case enumerations_1.OPERATION.Update:
                    apiFunctionName = "update";
                    break;
                case enumerations_1.OPERATION.Delete:
                    apiFunctionName = "del";
                    break;
                default:
                    if (progressCallback) {
                        progressCallback(new api_models_1.ApiInfo({
                            jobState: "Failed",
                            errorMessage: this.logger.getResourceString(logger_1.RESOURCES.invalidApiOperation),
                            jobId: apiInfo.jobId,
                            batchId: apiInfo.batchId
                        }));
                    }
                    resolve(null);
                    return;
            }
            progressCallback(new api_models_1.ApiInfo({
                jobState: "Open",
                jobId: apiInfo.jobId
            }));
            connection.sobject(this.sObjectName)[apiFunctionName](records, {
                allOrNone: this.allOrNone,
                allowRecursive: true,
                headers: statics_1.CONSTANTS.SFORCE_API_CALL_HEADERS
            }, async function (error, resultRecords) {
                if (error) {
                    if (progressCallback) {
                        progressCallback(new api_models_1.ApiInfo({
                            jobState: "Failed",
                            errorMessage: error.message,
                            jobId: apiInfo.jobId,
                            batchId: apiInfo.batchId
                        }));
                    }
                    resolve(null);
                }
                records = self.getResultRecordsArray(records);
                records.forEach((record, index) => {
                    if (resultRecords[index].success) {
                        record[statics_1.CONSTANTS.ERRORS_FIELD_NAME] = null;
                        if (self.operation == enumerations_1.OPERATION.Insert && self.updateRecordId) {
                            record["Id"] = resultRecords[index].id;
                        }
                        self.numberJobRecordProcessed++;
                    }
                    else {
                        record[statics_1.CONSTANTS.ERRORS_FIELD_NAME] = resultRecords[index].errors[0].message;
                        self.numberJobRecordsFailed++;
                        self.numberJobRecordProcessed++;
                    }
                });
                if (progressCallback) {
                    if (self.numberJobRecordsFailed > 0) {
                        progressCallback(new api_models_1.ApiInfo({
                            jobState: "JobComplete",
                            numberRecordsProcessed: self.numberJobRecordProcessed,
                            numberRecordsFailed: self.numberJobRecordsFailed,
                            jobId: apiInfo.jobId,
                            batchId: apiInfo.batchId
                        }));
                    }
                    if (self.numberJobRecordProcessed == self.numberJobTotalRecordsToProcess) {
                        progressCallback(new api_models_1.ApiInfo({
                            jobState: "OperationFinished",
                            numberRecordsProcessed: self.numberJobRecordProcessed,
                            numberRecordsFailed: self.numberJobRecordsFailed,
                            jobId: apiInfo.jobId,
                            batchId: apiInfo.batchId
                        }));
                    }
                    else {
                        progressCallback(new api_models_1.ApiInfo({
                            jobState: "InProgress",
                            numberRecordsProcessed: self.numberJobRecordProcessed,
                            numberRecordsFailed: self.numberJobRecordsFailed,
                            jobId: apiInfo.jobId,
                            batchId: apiInfo.batchId
                        }));
                    }
                }
                resolve(records);
            });
        });
    }
    getEngineClassType() {
        return RestApiEngine;
    }
    _fixRecords(allRecords) {
        allRecords.forEach(record => {
            Object.keys(record).forEach(key => {
                if (record[key] === '#N/A') {
                    record[key] = null;
                }
            });
        });
    }
}
exports.RestApiEngine = RestApiEngine;
//# sourceMappingURL=restApiEngine.js.map