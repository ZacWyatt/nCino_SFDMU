"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BulkApiV1_0Engine = void 0;
const models_1 = require("../../models");
const api_models_1 = require("../../models/api_models");
const common_1 = require("../common_components/common");
const enumerations_1 = require("../common_components/enumerations");
const sfdx_1 = require("../common_components/sfdx");
const statics_1 = require("../common_components/statics");
class BulkApiV1_0Engine extends api_models_1.ApiEngineBase {
    constructor(init) {
        super(init);
    }
    getEngineName() {
        return "Bulk API V1.0";
    }
    getEngineClassType() {
        return BulkApiV1_0Engine;
    }
    async createCRUDApiJobAsync(allRecords) {
        this._fixRecords(allRecords);
        let connection = sfdx_1.Sfdx.createOrgConnection(this.connectionData);
        connection.bulk.pollTimeout = statics_1.CONSTANTS.POLL_TIMEOUT;
        let job = connection.bulk.createJob(this.sObjectName, this.getBulkApiStrOperation(), {
            concurrencyMode: this.concurrencyMode
        });
        let recordChunks = common_1.Common.chunkArray(allRecords, this.bulkApiV1BatchSize);
        let chunks = new models_1.CsvChunks().fromArrayChunks(recordChunks);
        this.apiJobCreateResult = {
            chunks,
            apiInfo: new api_models_1.ApiInfo({
                jobState: "Undefined",
                strOperation: this.getStrOperation(),
                sObjectName: this.sObjectName,
                job,
                jobId: job.id,
            }),
            allRecords,
            connection
        };
        return this.apiJobCreateResult;
    }
    async processCRUDApiBatchAsync(csvChunk, progressCallback) {
        let self = this;
        return new Promise((resolve, reject) => {
            if (progressCallback) {
                progressCallback(new api_models_1.ApiInfo({
                    jobState: "OperationStarted"
                }));
            }
            let pollTimer;
            let numberBatchRecordsProcessed = 0;
            let job = this.apiJobCreateResult.apiInfo.job;
            let connection = this.apiJobCreateResult.connection;
            let records = csvChunk.records;
            let batch = job.createBatch();
            batch.execute(records, { headers: statics_1.CONSTANTS.SFORCE_API_CALL_HEADERS });
            batch.on("error", function (batchInfo) {
                if (pollTimer) {
                    clearInterval(pollTimer);
                }
                if (progressCallback) {
                    progressCallback(new api_models_1.ApiInfo({
                        jobState: "Failed",
                        errorMessage: batchInfo.stateMessage,
                        jobId: job.id,
                        batchId: batch.id
                    }));
                }
                resolve(null);
                return;
            });
            batch.on("queue", function (batchInfo) {
                batch.poll(self.pollingIntervalMs, statics_1.CONSTANTS.POLL_TIMEOUT);
                if (progressCallback) {
                    progressCallback(new api_models_1.ApiInfo({
                        jobState: "Open",
                        jobId: job.id
                    }));
                    progressCallback(new api_models_1.ApiInfo({
                        jobState: "UploadStart",
                        jobId: job.id,
                        batchId: batch.id
                    }));
                }
                pollTimer = setInterval(function () {
                    connection.bulk.job(job.id).batch(batch.id).check((error, results) => {
                        if (error) {
                            clearInterval(pollTimer);
                            if (progressCallback) {
                                progressCallback(new api_models_1.ApiInfo({
                                    jobState: "Failed",
                                    errorMessage: error,
                                    jobId: job.id,
                                    batchId: batch.id
                                }));
                            }
                            resolve(null);
                            return;
                        }
                        let processed = +results.numberRecordsProcessed;
                        let failed = +results.numberRecordsFailed;
                        if (numberBatchRecordsProcessed != processed) {
                            if (numberBatchRecordsProcessed == 0) {
                                progressCallback(new api_models_1.ApiInfo({
                                    jobState: "UploadComplete",
                                    jobId: job.id,
                                    batchId: batch.id
                                }));
                            }
                            numberBatchRecordsProcessed = processed;
                            let progress = new api_models_1.ApiInfo({
                                jobState: "InProgress",
                                numberRecordsProcessed: self.numberJobRecordProcessed + processed,
                                numberRecordsFailed: self.numberJobRecordsFailed + failed,
                                jobId: job.id,
                                batchId: batch.id
                            });
                            if (progressCallback) {
                                progressCallback(progress);
                            }
                        }
                    });
                }, self.pollingIntervalMs);
            });
            batch.on("response", async function (resultRecords) {
                clearInterval(pollTimer);
                records.forEach((record, index) => {
                    if (resultRecords[index].success) {
                        record[statics_1.CONSTANTS.ERRORS_FIELD_NAME] = null;
                        if (self.operation == enumerations_1.OPERATION.Insert && self.updateRecordId) {
                            record["Id"] = resultRecords[index].id;
                        }
                        self.numberJobRecordProcessed++;
                    }
                    else {
                        if (resultRecords[index].errors) {
                            record[statics_1.CONSTANTS.ERRORS_FIELD_NAME] = resultRecords[index].errors.join('; ');
                        }
                        else {
                            record[statics_1.CONSTANTS.ERRORS_FIELD_NAME] = null;
                        }
                        self.numberJobRecordsFailed++;
                        self.numberJobRecordProcessed++;
                    }
                });
                if (progressCallback) {
                    if (self.numberJobRecordsFailed > 0) {
                        progressCallback(new api_models_1.ApiInfo({
                            jobState: "JobComplete",
                            numberRecordsProcessed: self.numberJobRecordProcessed,
                            numberRecordsFailed: self.numberJobRecordsFailed,
                            jobId: job.id,
                            batchId: batch.id
                        }));
                    }
                    progressCallback(new api_models_1.ApiInfo({
                        jobState: "OperationFinished",
                        jobId: job.id,
                        batchId: batch.id
                    }));
                }
                resolve(records);
            });
        });
    }
    _fixRecords(allRecords) {
        allRecords.forEach(record => {
            Object.keys(record).forEach(key => {
                if (record[key] === '#N/A') {
                    record[key] = null;
                }
            });
        });
    }
}
exports.BulkApiV1_0Engine = BulkApiV1_0Engine;
//# sourceMappingURL=bulkApiV1_0Engine.js.map