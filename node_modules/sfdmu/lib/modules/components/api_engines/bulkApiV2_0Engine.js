"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BulkApiV2_0Engine = void 0;
const parse2 = require('csv-parse/lib/sync');
const api_models_1 = require("../../models/api_models");
const ApiResultRecord_1 = require("../../models/api_models/ApiResultRecord");
const common_1 = require("../common_components/common");
const enumerations_1 = require("../common_components/enumerations");
const logger_1 = require("../common_components/logger");
const statics_1 = require("../common_components/statics");
const parse = parse2.parse || parse2;
const request = require('request');
const createJobEndpoint = '/services/data/[v]/jobs/ingest';
const requestTimeout = 10 * 60 * 1000;
const requestHeaderCsv = Object.assign({}, {
    'Content-Type': 'text/csv',
    'Accept': 'application/json'
}, statics_1.CONSTANTS.SFORCE_API_CALL_HEADERS);
const requestHeaderJson = Object.assign({}, {
    'Content-Type': 'application/json; charset=UTF-8',
    'Accept': 'application/json'
}, statics_1.CONSTANTS.SFORCE_API_CALL_HEADERS);
class BulkApiV2_0Engine extends api_models_1.ApiEngineBase {
    constructor(init) {
        super(init);
        this.sourceRecords = new Array();
        this.sourceRecordsHashmap = new Map();
    }
    getEngineName() {
        return "Bulk API V2.0";
    }
    getEngineClassType() {
        return BulkApiV2_0Engine;
    }
    async createCRUDApiJobAsync(allRecords) {
        let chunks = common_1.Common.createCsvStringsFromArray(allRecords, statics_1.CONSTANTS.BULK_API_V2_MAX_CSV_SIZE_IN_BYTES, statics_1.CONSTANTS.BULK_API_V2_BLOCK_SIZE);
        this.apiJobCreateResult = {
            chunks,
            apiInfo: new api_models_1.ApiInfo({
                jobState: "Undefined",
                strOperation: this.getStrOperation(),
                sObjectName: this.sObjectName,
            }),
            allRecords
        };
        return this.apiJobCreateResult;
    }
    async processCRUDApiBatchAsync(csvChunk, progressCallback) {
        let self = this;
        if (progressCallback) {
            progressCallback(new api_models_1.ApiInfo({
                jobState: "OperationStarted"
            }));
        }
        let jobResult = await this.createBulkJobAsync(this.sObjectName, this.getBulkApiStrOperation());
        if (progressCallback) {
            progressCallback(jobResult);
        }
        if (jobResult.resultStatus != enumerations_1.RESULT_STATUSES.JobCreated) {
            return null;
        }
        let batchResult = await this.createBulkBatchAsync(jobResult.contentUrl, csvChunk.csvString, csvChunk.records);
        batchResult.jobId = jobResult.jobId;
        batchResult.batchId = jobResult.jobId;
        if (progressCallback) {
            progressCallback(batchResult);
        }
        if (batchResult.resultStatus != enumerations_1.RESULT_STATUSES.BatchCreated) {
            return null;
        }
        batchResult = await this.closeBulkJobAsync(jobResult.contentUrl);
        batchResult.jobId = jobResult.jobId;
        batchResult.batchId = jobResult.jobId;
        if (progressCallback) {
            progressCallback(batchResult);
        }
        if (batchResult.resultStatus != enumerations_1.RESULT_STATUSES.DataUploaded) {
            return null;
        }
        let numberBatchRecordsProcessed = 0;
        batchResult = await this.waitForBulkJobCompleteAsync(jobResult.contentUrl, this.pollingIntervalMs, function (progress) {
            progress.jobId = jobResult.jobId;
            progress.batchId = jobResult.jobId;
            if (numberBatchRecordsProcessed != progress.numberRecordsProcessed) {
                numberBatchRecordsProcessed = progress.numberRecordsProcessed;
                progress.numberRecordsProcessed += self.numberJobRecordProcessed;
                progress.numberRecordsFailed += self.numberJobRecordsFailed;
                if (progressCallback) {
                    progressCallback(progress);
                }
            }
        });
        batchResult.jobId = jobResult.jobId;
        batchResult.batchId = jobResult.jobId;
        batchResult.numberRecordsProcessed += self.numberJobRecordProcessed;
        batchResult.numberRecordsFailed += self.numberJobRecordsFailed;
        self.numberJobRecordProcessed = batchResult.numberRecordsProcessed;
        self.numberJobRecordsFailed = batchResult.numberRecordsFailed;
        if (progressCallback) {
            progressCallback(batchResult);
        }
        if (batchResult.resultStatus != enumerations_1.RESULT_STATUSES.Completed) {
            return null;
        }
        batchResult = await this.getBulkJobResultAsync(jobResult.contentUrl);
        if (batchResult.resultStatus != enumerations_1.RESULT_STATUSES.Completed) {
            return null;
        }
        csvChunk.records.forEach((record, index) => {
            if (batchResult.resultRecords[index].isSuccess) {
                record[statics_1.CONSTANTS.ERRORS_FIELD_NAME] = null;
                if (self.operation == enumerations_1.OPERATION.Insert && self.updateRecordId) {
                    record["Id"] = batchResult.resultRecords[index].id;
                }
            }
            else {
                if (batchResult.resultRecords[index].errorMessage) {
                    record[statics_1.CONSTANTS.ERRORS_FIELD_NAME] = batchResult.resultRecords[index].errorMessage;
                }
                else {
                    record[statics_1.CONSTANTS.ERRORS_FIELD_NAME] = null;
                }
            }
        });
        if (progressCallback) {
            progressCallback(new api_models_1.ApiInfo({
                jobState: "OperationFinished",
                jobId: jobResult.jobId,
                batchId: jobResult.batchId
            }));
        }
        return csvChunk.records;
    }
    async createBulkJobAsync(objectAPIName, operationType) {
        let self = this;
        this.operationType = operationType;
        return new Promise(resolve => {
            request.post({
                url: this.instanceUrl + this._getCreateJobEndpointUrl(),
                body: JSON.stringify({
                    object: objectAPIName,
                    contentType: 'CSV',
                    operation: operationType,
                    lineEnding: 'LF'
                }),
                auth: {
                    'bearer': this.accessToken
                },
                headers: requestHeaderJson
            }, function (error, response, body) {
                if (!error && response.statusCode == 200) {
                    let info = JSON.parse(body);
                    resolve(new api_models_1.ApiInfo({
                        jobId: info.id,
                        contentUrl: info.contentUrl,
                        sObjectName: self.sObjectName,
                        strOperation: self.getStrOperation(),
                        jobState: info.state,
                        errorMessage: info.errorMessage
                    }));
                }
                else {
                    self._apiRequestErrorHandler(resolve, error, response, body);
                }
            });
        });
    }
    async createBulkBatchAsync(contentUrl, csvContent, records) {
        let self = this;
        this.sourceRecords = records;
        if (this.operationType == "insert") {
            this.sourceRecordsHashmap = common_1.Common.arrayToMapByHashcode(records, undefined);
        }
        else {
            this.sourceRecordsHashmap = common_1.Common.arrayToMapByProperty(records, "Id");
        }
        return new Promise(resolve => {
            request.put({
                timeout: requestTimeout,
                url: this.instanceUrl + '/' + contentUrl,
                body: csvContent,
                auth: {
                    'bearer': this.accessToken
                },
                headers: requestHeaderCsv
            }, function (error, response) {
                if (!error && response.statusCode == 201) {
                    resolve(new api_models_1.ApiInfo({
                        jobState: "UploadStart",
                        sObjectName: self.sObjectName,
                        strOperation: self.getStrOperation(),
                    }));
                }
                else {
                    self._apiRequestErrorHandler(resolve, error, response, undefined);
                }
            });
        });
    }
    async closeBulkJobAsync(contentUrl) {
        let self = this;
        return new Promise(resolve => {
            request.patch({
                url: this.instanceUrl + '/' + contentUrl.replace("/batches", "/"),
                body: JSON.stringify({
                    "state": "UploadComplete"
                }),
                auth: {
                    'bearer': this.accessToken
                },
                headers: requestHeaderJson
            }, function (error, response, body) {
                if (!error && response.statusCode == 200) {
                    let info = JSON.parse(body);
                    resolve(new api_models_1.ApiInfo({
                        jobState: info.state,
                        sObjectName: self.sObjectName,
                        strOperation: self.getStrOperation(),
                    }));
                }
                else {
                    self._apiRequestErrorHandler(resolve, error, response, body);
                }
            });
        });
    }
    async pollBulkJobAsync(contentUrl) {
        let self = this;
        return new Promise(resolve => {
            request.get({
                url: this.instanceUrl + '/' + contentUrl.replace("/batches", "/"),
                auth: {
                    'bearer': this.accessToken
                },
                headers: requestHeaderJson
            }, function (error, response, body) {
                if (!error && response.statusCode == 200) {
                    let info = JSON.parse(body);
                    resolve(new api_models_1.ApiInfo({
                        errorMessage: info.errorMessage,
                        jobState: info.state,
                        numberRecordsFailed: info.numberRecordsFailed,
                        numberRecordsProcessed: info.numberRecordsProcessed,
                        sObjectName: self.sObjectName,
                        strOperation: self.getStrOperation(),
                    }));
                }
                else {
                    self._apiRequestErrorHandler(resolve, error, response, body);
                }
            });
        });
    }
    async waitForBulkJobCompleteAsync(contentUrl, pollInterval, pollCallback) {
        let self = this;
        return new Promise(resolve => {
            let interval = setInterval(async () => {
                try {
                    let res = await self.pollBulkJobAsync(contentUrl);
                    switch (res.resultStatus) {
                        case enumerations_1.RESULT_STATUSES.Completed:
                        case enumerations_1.RESULT_STATUSES.FailedOrAborted:
                            clearInterval(interval);
                            resolve(res);
                            return;
                        case enumerations_1.RESULT_STATUSES.Undefined:
                            throw new Error("Undefined job");
                        case enumerations_1.RESULT_STATUSES.ProcessError:
                            clearInterval(interval);
                            self._apiRequestErrorHandler(resolve, {
                                message: res.errorMessage,
                                stack: res.errorStack
                            }, null, null);
                            return;
                        default:
                            if (pollCallback) {
                                pollCallback(res);
                            }
                            return;
                    }
                }
                catch (e) {
                    clearInterval(interval);
                    self._apiRequestErrorHandler(resolve, e, null, null);
                }
            }, pollInterval);
        });
    }
    async getBulkJobResultAsync(contentUrl) {
        let self = this;
        return new Promise(resolve => {
            request.get({
                timeout: requestTimeout,
                url: this.instanceUrl + '/' + contentUrl.replace("/batches", "/") + 'successfulResults/',
                auth: {
                    'bearer': this.accessToken
                },
                headers: requestHeaderJson
            }, async function (error, response, body) {
                if (!error && response.statusCode >= 200 && response.statusCode < 400) {
                    if (response.statusCode != 200) {
                        resolve(new api_models_1.ApiInfo({
                            jobState: "InProgress",
                            sObjectName: self.sObjectName,
                            strOperation: self.getStrOperation(),
                        }));
                        return;
                    }
                    try {
                        let csv = parse(body, {
                            skip_empty_lines: true,
                            skip_lines_with_error: true,
                            cast: self._csvCast
                        });
                        let allRecords = common_1.Common.transformArrayOfArrays(csv);
                        let failedRecords = await self._getBulkJobUnsuccessfullResultAsync(contentUrl, true);
                        let unprocessedRecords = await self._getBulkJobUnsuccessfullResultAsync(contentUrl, false);
                        allRecords = allRecords.concat(failedRecords, unprocessedRecords);
                        let map;
                        if (self.operationType == "insert") {
                            map = common_1.Common.compareArraysByHashcode(undefined, allRecords, [
                                "sf__Created",
                                "sf__Id",
                                "sf__Error",
                                "sf__Unprocessed"
                            ], self.sourceRecordsHashmap);
                        }
                        else {
                            map = common_1.Common.compareArraysByProperty(undefined, allRecords, "Id", self.sourceRecordsHashmap);
                        }
                        let resultRecords = self.sourceRecords.map(sourceRecord => {
                            let targetRecord = map.get(sourceRecord);
                            let resultRecord = new ApiResultRecord_1.default({
                                sourceRecord,
                                targetRecord,
                                isMissingSourceTargetMapping: !targetRecord,
                                isFailed: targetRecord && !!targetRecord["sf__Error"],
                                isUnprocessed: targetRecord && !!targetRecord["sf__Unprocessed"],
                                errorMessage: targetRecord && targetRecord["sf__Error"],
                                id: targetRecord && (targetRecord["sf__Id"] || targetRecord["Id"]),
                                isCreated: targetRecord && !!targetRecord["sf__Created"]
                            });
                            if (resultRecord.isUnprocessed) {
                                resultRecord.errorMessage = self.logger.getResourceString(logger_1.RESOURCES.unprocessedRecord);
                            }
                            else if (resultRecord.isMissingSourceTargetMapping) {
                                resultRecord.errorMessage = self.logger.getResourceString(logger_1.RESOURCES.invalidRecordHashcode);
                            }
                            return resultRecord;
                        });
                        resolve(new api_models_1.ApiInfo({
                            resultRecords,
                            jobState: "JobComplete",
                            sObjectName: self.sObjectName,
                            strOperation: self.getStrOperation()
                        }));
                    }
                    catch (e) {
                        if (typeof e.message == "string") {
                            self._apiRequestErrorHandler(resolve, e, undefined, undefined);
                        }
                        else {
                            let responseError = JSON.parse(e.message);
                            self._apiRequestErrorHandler(resolve, responseError.error, responseError.response, responseError.body);
                        }
                    }
                }
                else {
                    self._apiRequestErrorHandler(resolve, error, response, body);
                }
            });
        });
    }
    async _getBulkJobUnsuccessfullResultAsync(contentUrl, isGetFailed) {
        let self = this;
        return new Promise(resolve => {
            request.get({
                timeout: requestTimeout,
                url: this.instanceUrl + '/' + contentUrl.replace("/batches", "/") + (isGetFailed ? 'failedResults/' : 'unprocessedrecords/'),
                auth: {
                    'bearer': this.accessToken
                },
                headers: requestHeaderJson
            }, function (error, response, body) {
                if (!error && response.statusCode == 200) {
                    let csv = parse(body, {
                        skip_empty_lines: true,
                        skip_lines_with_error: true,
                        cast: self._csvCast
                    });
                    let unprocessedRecords = common_1.Common.transformArrayOfArrays(csv);
                    if (!isGetFailed) {
                        unprocessedRecords.forEach(record => {
                            record["sf__Unprocessed"] = true;
                        });
                    }
                    resolve(unprocessedRecords);
                }
                else {
                    throw new Error(JSON.stringify({
                        error,
                        response,
                        body
                    }));
                }
            });
        });
    }
    _csvCast(value, context) {
        if (context.header || typeof context.column == "undefined") {
            return value;
        }
        if (value == "#N/A") {
            return null;
        }
        if (value == "TRUE" || value == "true")
            return true;
        else if (value == "FALSE" || value == "false")
            return false;
        if (!value) {
            return null;
        }
        return value;
    }
    _apiRequestErrorHandler(resolve, error, response, body) {
        if (!response) {
            resolve(new api_models_1.ApiInfo({
                errorMessage: error.message,
                errorStack: error.stack,
                sObjectName: this.sObjectName,
                strOperation: this.getStrOperation(),
            }));
        }
        else {
            let info = body && JSON.parse(body)[0] || {
                message: this.logger.getResourceString(logger_1.RESOURCES.unexpectedApiError),
            };
            resolve(new api_models_1.ApiInfo({
                errorMessage: info.message,
                sObjectName: this.sObjectName,
                strOperation: this.getStrOperation(),
            }));
        }
    }
    _getCreateJobEndpointUrl() {
        return createJobEndpoint.replace('[v]', `v${this.version}`);
    }
}
exports.BulkApiV2_0Engine = BulkApiV2_0Engine;
//# sourceMappingURL=bulkApiV2_0Engine.js.map