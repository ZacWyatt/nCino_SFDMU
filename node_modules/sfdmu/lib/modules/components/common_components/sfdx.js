"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Sfdx = void 0;
const fs = require("fs");
const path = require("path");
const soql_parser_js_1 = require("soql-parser-js");
const models_1 = require("../../models");
const common_1 = require("./common");
const enumerations_1 = require("./enumerations");
const logger_1 = require("./logger");
const statics_1 = require("./statics");
var jsforce = require("jsforce");
class Sfdx {
    get logger() {
        return this.org.script.logger;
    }
    constructor(org, targetFieldMapping) {
        this.sourceQueryToTarget = (query, sourceObjectName) => ({ query, targetSObjectName: sourceObjectName });
        this.sourceRecordsToTarget = (records, sourceObjectName) => ({ records, targetSObjectName: sourceObjectName });
        this.targetRecordsToSource = (records, sourceObjectName) => ({ records, targetSObjectName: sourceObjectName });
        this.org = org;
        if (targetFieldMapping) {
            Object.assign(this, targetFieldMapping);
        }
    }
    async queryOrgAsync(soql, useBulkQueryApi, useQueryAll, bulkQueryPollTimeout) {
        let self = this;
        useBulkQueryApi = useBulkQueryApi && !useQueryAll;
        const firstProgressMessageAt = statics_1.CONSTANTS.QUERY_PROGRESS_MESSAGE_PER_RECORDS;
        let nextProgressInfoAtRecord = firstProgressMessageAt;
        let lastProgressMessageAt = 0;
        return (await ___makeQueryAsync(soql)).records;
        function ___fixRecords(records) {
            if (records.length == 0)
                return;
            let props = Object.keys(records[0]);
            records.forEach(record => {
                props.forEach(prop => {
                    if (record[prop] === "") {
                        record[prop] = null;
                    }
                });
            });
        }
        async function ___makeQueryAsync(soql) {
            return new Promise((resolve, reject) => {
                let conn = self.org.getConnection();
                conn.bulk.pollTimeout = bulkQueryPollTimeout;
                let records = [];
                if (useBulkQueryApi) {
                    conn.bulk.query(soql, { headers: statics_1.CONSTANTS.SFORCE_API_CALL_HEADERS }).on("record", function (record) {
                        if (records.length >= nextProgressInfoAtRecord) {
                            nextProgressInfoAtRecord += statics_1.CONSTANTS.QUERY_PROGRESS_MESSAGE_PER_RECORDS;
                            lastProgressMessageAt = records.length + 1;
                            self.logger.infoVerbose(logger_1.RESOURCES.apiCallProgress, String(lastProgressMessageAt));
                        }
                        records.push(record);
                    }).on("end", function () {
                        ___fixRecords(records);
                        ___outputProgress();
                        resolve({
                            done: true,
                            records: records,
                            totalSize: records.length
                        });
                    }).on("error", function (error) {
                        reject(error);
                    });
                }
                else {
                    let query = (useQueryAll ? conn.queryAll(soql, { headers: statics_1.CONSTANTS.SFORCE_API_CALL_HEADERS })
                        : conn.query(soql, { headers: statics_1.CONSTANTS.SFORCE_API_CALL_HEADERS }))
                        .on("record", function (record) {
                        if (records.length >= nextProgressInfoAtRecord) {
                            nextProgressInfoAtRecord += statics_1.CONSTANTS.QUERY_PROGRESS_MESSAGE_PER_RECORDS;
                            lastProgressMessageAt = records.length + 1;
                            self.logger.infoVerbose(logger_1.RESOURCES.apiCallProgress, String(lastProgressMessageAt));
                        }
                        records.push(record);
                    }).on("end", function () {
                        ___fixRecords(records);
                        ___outputProgress();
                        resolve({
                            done: true,
                            records: records,
                            totalSize: query.totalSize
                        });
                    }).on("error", function (error) {
                        reject(error);
                    }).run({
                        autoFetch: true,
                        maxFetch: statics_1.CONSTANTS.MAX_FETCH_SIZE
                    });
                }
                function ___outputProgress() {
                    if (lastProgressMessageAt != records.length && records.length >= firstProgressMessageAt) {
                        self.logger.infoVerbose(logger_1.RESOURCES.apiCallProgress, String(records.length));
                    }
                }
            });
        }
    }
    async queryOrgOrCsvAsync(soql, useBulkQueryApi = false, csvFullFilename, sFieldsDescribeMap, useQueryAll, bulkQueryPollTimeout) {
        let self = this;
        try {
            if (csvFullFilename && sFieldsDescribeMap) {
                return await ___readAndFormatCsvRecordsAsync();
            }
            let parsedQuery = (0, soql_parser_js_1.parseQuery)(soql);
            soql = this.sourceQueryToTarget(soql, parsedQuery.sObject).query;
            if (!useBulkQueryApi) {
                this.logger.infoVerbose(logger_1.RESOURCES.usingRestApi, parsedQuery.sObject);
            }
            else {
                this.logger.infoVerbose(logger_1.RESOURCES.usingBulkAPIQuery, parsedQuery.sObject);
            }
            let records = [].concat(await ___queryAsync(soql));
            if (parsedQuery.sObject == 'User') {
                let parsedGroupQuery = (0, soql_parser_js_1.parseQuery)(soql);
                parsedGroupQuery.sObject = 'Group';
                parsedGroupQuery.where = common_1.Common.composeWhereClause(null, "Type", "Queue", "=", "STRING", "AND");
                soql = (0, soql_parser_js_1.composeQuery)(parsedGroupQuery);
                records = records.concat(await ___queryAsync(soql));
            }
            records = this.targetRecordsToSource(records, parsedQuery.sObject).records;
            return records;
        }
        catch (ex) {
            throw new models_1.CommandExecutionError(ex.message);
        }
        async function ___queryAsync(soql) {
            let hash32 = '';
            let cacheFullFilename = '';
            let sObject = '';
            let cacheFilename = '';
            let messageCacheFilename = '';
            if ((self.org.script.sourceRecordsCache == enumerations_1.DATA_CACHE_TYPES.CleanFileCache
                || self.org.script.sourceRecordsCache == enumerations_1.DATA_CACHE_TYPES.FileCache)
                && self.org.isSource) {
                hash32 = String(common_1.Common.getString32FNV1AHashcode(soql, true));
                cacheFilename = statics_1.CONSTANTS.SOURCE_RECORDS_FILE_CACHE_TEMPLATE(hash32);
                messageCacheFilename = path.join('./' + statics_1.CONSTANTS.SOURCE_RECORDS_CACHE_SUB_DIRECTORY, cacheFilename);
                cacheFullFilename = path.join(self.org.script.sourceRecordsCacheDirectory, cacheFilename);
                sObject = (0, soql_parser_js_1.parseQuery)(soql).sObject;
                if (fs.existsSync(cacheFullFilename)) {
                    let data = fs.readFileSync(cacheFullFilename, 'utf-8');
                    try {
                        self.logger.infoVerbose(logger_1.RESOURCES.readingFromCacheFile, sObject, messageCacheFilename);
                        return JSON.parse(data).records;
                    }
                    catch (e) { }
                }
            }
            let soqlFormat = ___formatSoql(soql);
            soql = soqlFormat[0];
            let records = (await self.queryOrgAsync(soql, useBulkQueryApi, useQueryAll, bulkQueryPollTimeout));
            records = ___parseRecords(records, soql);
            records = ___formatRecords(records, soqlFormat);
            records = await ___retrieveBlobFieldData(records, soqlFormat[3]);
            if ((self.org.script.sourceRecordsCache == enumerations_1.DATA_CACHE_TYPES.CleanFileCache
                || self.org.script.sourceRecordsCache == enumerations_1.DATA_CACHE_TYPES.FileCache)
                && self.org.isSource) {
                let data = JSON.stringify({
                    query: soql,
                    records
                });
                try {
                    self.logger.infoVerbose(logger_1.RESOURCES.writingToCacheFile, sObject, messageCacheFilename);
                    fs.writeFileSync(cacheFullFilename, data, 'utf-8');
                }
                catch (e) { }
            }
            return records;
        }
        function ___formatSoql(soql) {
            let newParsedQuery = (0, soql_parser_js_1.parseQuery)(soql);
            let excludedFields = __getExcludedFields(newParsedQuery.sObject);
            let originalFields = newParsedQuery.fields.map(x => {
                return x;
            });
            let originalFieldNamesToKeep = originalFields.map(newFieldTmp => {
                let newSOQLFieldTmp = newFieldTmp;
                let newRawValueTmp = newSOQLFieldTmp["rawValue"] || newSOQLFieldTmp.field;
                return newRawValueTmp;
            });
            newParsedQuery.fields = [];
            let outputMap = new Map();
            originalFields.forEach(originalField => {
                let rawValueOrig = originalField["rawValue"] || originalField.field;
                if (rawValueOrig.indexOf(statics_1.CONSTANTS.COMPLEX_FIELDS_QUERY_PREFIX) < 0) {
                    if (!newParsedQuery.fields.some(newFieldTmp => {
                        let newSOQLFieldTmp = newFieldTmp;
                        let newRawValueTmp = newSOQLFieldTmp["rawValue"] || newSOQLFieldTmp.field;
                        return newRawValueTmp.toLowerCase() == rawValueOrig.toLowerCase();
                    }) && excludedFields.indexOf(rawValueOrig) < 0) {
                        newParsedQuery.fields.push(originalField);
                    }
                }
                else {
                    let complexFields = rawValueOrig.split(statics_1.CONSTANTS.COMPLEX_FIELDS_QUERY_PREFIX);
                    complexFields[1] = complexFields[1].startsWith('.') ? complexFields[1].substr(1) : complexFields[1];
                    let containedFields = complexFields[1].split(statics_1.CONSTANTS.COMPLEX_FIELDS_QUERY_SEPARATOR);
                    containedFields.forEach((field) => {
                        let newFieldName = complexFields[0] ? complexFields[0] + field : field;
                        if (!newParsedQuery.fields.some(newFieldTmp => {
                            let newSOQLFieldTmp = newFieldTmp;
                            let newRawValueTmp = newSOQLFieldTmp["rawValue"] || newSOQLFieldTmp.field;
                            return newRawValueTmp.toLowerCase() == newFieldName.toLowerCase();
                        })) {
                            newParsedQuery.fields.push((0, soql_parser_js_1.getComposedField)(newFieldName));
                        }
                        if (!outputMap.has(rawValueOrig))
                            outputMap.set(rawValueOrig, [newFieldName]);
                        else
                            outputMap.get(rawValueOrig).push(newFieldName);
                    });
                }
            });
            let newQuery = (0, soql_parser_js_1.composeQuery)(newParsedQuery);
            if (self.transformQuery) {
                newQuery = self.transformQuery(newQuery, newParsedQuery.sObject).query;
            }
            return [newQuery, outputMap, originalFieldNamesToKeep, newParsedQuery.sObject];
        }
        function __getExcludedFields(sObject) {
            let excluded = new Array();
            let fields = statics_1.CONSTANTS.EXCLUDED_QUERY_FIELDS.get(sObject);
            if (fields != null) {
                excluded = excluded.concat(fields);
            }
            return excluded;
        }
        function ___parseRecords(rawRecords, query) {
            const getNestedObject = (nestedObj, pathArr) => {
                return pathArr.reduce((obj, key) => obj && obj[key] !== 'undefined' ? obj[key] : undefined, nestedObj);
            };
            let fieldMapping = {};
            const soqlQuery = (0, soql_parser_js_1.parseQuery)(query);
            soqlQuery.fields.forEach(element => {
                if (element.type == "FieldFunctionExpression") {
                    fieldMapping[element.alias] = [element.alias];
                }
                else if (element.type == "Field")
                    fieldMapping[element.field] = [element.field];
                else if (element.type == "FieldRelationship") {
                    var v = element.relationships.concat(element.field);
                    fieldMapping[element.rawValue] = v;
                }
            });
            var parsedRecords = rawRecords.map(function (record) {
                var o = {};
                for (var prop in fieldMapping) {
                    if (fieldMapping.hasOwnProperty(prop)) {
                        o[prop] = getNestedObject(record, fieldMapping[prop]);
                        if (typeof o[prop] == 'undefined' && record[prop]) {
                            o[prop] = record[prop];
                        }
                    }
                }
                return o;
            });
            return parsedRecords;
        }
        function ___formatRecords(records, soqlFormat) {
            if (soqlFormat[1].size > 0) {
                let complexKeys = [...soqlFormat[1].keys()];
                records.forEach(record => {
                    complexKeys.forEach(complexKey => {
                        let fields = soqlFormat[1].get(complexKey);
                        let value = [];
                        fields.forEach(field => {
                            if (record[field]) {
                                value.push(record[field]);
                            }
                        });
                        record[complexKey.toString()] = value.join(';') || null;
                    });
                    complexKeys.forEach(complexKey => {
                        let fields = soqlFormat[1].get(complexKey);
                        fields.forEach(field => {
                            if (soqlFormat[2].indexOf(field) < 0) {
                                delete record[field];
                            }
                        });
                    });
                });
            }
            let excludedFields = __getExcludedFields(soqlFormat[3]);
            let extraFields = soqlFormat[2].filter(fieldName => excludedFields.indexOf(fieldName) >= 0);
            extraFields.forEach(extraField => {
                records.forEach(record => {
                    record[extraField] = typeof record[extraField] == 'undefined' ? null : record[extraField];
                });
            });
            return records;
        }
        async function ___readAndFormatCsvRecordsAsync() {
            let fieldTypesMap = new Map();
            sFieldsDescribeMap.forEach((value, key) => fieldTypesMap.set(key, value.type));
            let records = await common_1.Common.readCsvFileAsync(csvFullFilename, 0, fieldTypesMap);
            let parsedQuery = (0, soql_parser_js_1.parseQuery)(soql);
            let fields = parsedQuery.fields.map(field => field["rawValue"] || field.field);
            records.forEach(record => {
                fields.forEach(field => {
                    record[field] = typeof record[field] == "undefined" ? null : record[field];
                });
            });
            return records;
        }
        async function ___retrieveBlobFieldData(records, sObjectName) {
            let blobFields = statics_1.CONSTANTS.BLOB_FIELDS.filter(field => records.length > 0
                && field.objectName == sObjectName
                && records[0].hasOwnProperty(field.fieldName));
            if (blobFields.length == 0) {
                return records;
            }
            self.logger.infoVerbose(logger_1.RESOURCES.retrievingBinaryData, sObjectName);
            let recordIdToRecordMap = new Map();
            records.forEach(record => {
                let recordId = record["Id"];
                if (recordId) {
                    recordIdToRecordMap.set(recordId, record);
                }
            });
            const ids = [...recordIdToRecordMap.keys()];
            for (let blobFieldIndex = 0; blobFieldIndex < blobFields.length; blobFieldIndex++) {
                const blobField = blobFields[blobFieldIndex];
                const blobData = await self.downloadBlobFieldDataAsync(ids, blobField);
                blobData.forEach((blobValue, id) => {
                    let record = recordIdToRecordMap.get(id);
                    if (record) {
                        record[blobField.fieldName] = blobValue;
                    }
                });
            }
            return records;
        }
    }
    async describeOrgAsync() {
        let query = `SELECT  QualifiedApiName, Label
                    FROM EntityDefinition
                    WHERE IsDeprecatedAndHidden = false
                    ORDER BY QualifiedApiName`;
        let records = await this.queryOrgAsync(query, false);
        return records.map((record) => {
            return new models_1.SObjectDescribe({
                label: String(record["Label"]),
                name: String(record["QualifiedApiName"]),
                createable: true,
                updateable: true,
                custom: common_1.Common.isCustomObject(String(record["QualifiedApiName"]))
            });
        });
    }
    async getPolymorphicObjectFields(sObjectName) {
        let query = `SELECT QualifiedApiName
                     FROM FieldDefinition
                     WHERE EntityDefinitionId = '${sObjectName}'
                        AND IsPolymorphicForeignKey = true`;
        let records = await this.queryOrgAsync(query, false);
        return records.map(record => record["QualifiedApiName"]);
    }
    async identityAsync() {
        var conn = this.org.getConnection();
        return new Promise((resolve, reject) => {
            conn.identity(function (err, info) {
                if (err)
                    reject(err);
                else {
                    resolve(info);
                }
            });
        });
    }
    async describeSObjectAsync(objectName, objectFieldMapping) {
        var conn = this.org.getConnection();
        const describeAsync = (name) => new Promise((resolve, reject) => conn.sobject(name).describe(function (err, meta) {
            if (err)
                reject(err);
            else
                resolve(meta);
        }));
        let targetObjectName = objectFieldMapping ? objectFieldMapping.targetSObjectName : objectName;
        let describeResult = (await describeAsync(targetObjectName));
        let sObjectDescribe = new models_1.SObjectDescribe({
            name: objectName,
            createable: describeResult.createable,
            custom: describeResult.custom,
            label: describeResult.label,
            updateable: describeResult.createable && describeResult.updateable
        });
        describeResult.fields.forEach(field => {
            let f = new models_1.SFieldDescribe();
            f.objectName = objectName;
            f.name = field.name;
            f.nameField = field.nameField;
            f.unique = field.unique;
            f.type = field.type;
            f.label = field.label;
            f.custom = field.custom;
            f.updateable = field.updateable;
            f.autoNumber = field["autoNumber"];
            f.creatable = field.createable;
            f.calculated = field.calculated;
            f.cascadeDelete = field.cascadeDelete;
            f.lookup = field.referenceTo != null && field.referenceTo.length > 0;
            let referencedObjectType = (statics_1.CONSTANTS.REFERENCED_SOBJECT_TYPE_MAP.get(objectName) || {})[f.name];
            referencedObjectType = statics_1.CONSTANTS.REFERENCED_FIELDS_MAP.get(f.name) || referencedObjectType;
            f.referencedObjectType = referencedObjectType || field.referenceTo[0];
            f.originalReferencedObjectType = referencedObjectType || f.referencedObjectType;
            f.length = field.length || 0;
            f.isDescribed = true;
            sObjectDescribe.fieldsMap.set(f.name, f);
        });
        return sObjectDescribe;
    }
    ;
    static createOrgConnection(connectionData) {
        return new jsforce.Connection({
            instanceUrl: connectionData.instanceUrl,
            accessToken: connectionData.accessToken,
            version: connectionData.apiVersion,
            maxRequest: statics_1.CONSTANTS.MAX_PARALLEL_REQUESTS,
            proxyUrl: connectionData.proxyUrl
        });
    }
    async downloadBlobFieldDataAsync(recordIds, blobField) {
        let self = this;
        let recordsCounter = 0;
        let nextProgressInfoAtRecord = 0;
        let lastProgressMessageAt = 0;
        const queue = recordIds.map(recordId => () => ___getBlobData(recordId, blobField));
        const downloadedBlobs = await common_1.Common.parallelTasksAsync(queue, self.org.script.parallelBinaryDownloads);
        if (lastProgressMessageAt != recordIds.length) {
            self.logger.infoNormal(logger_1.RESOURCES.apiCallProgress, recordIds.length + '/' + recordIds.length);
        }
        return new Map(downloadedBlobs);
        async function ___getBlobData(recordId, blobField) {
            return new Promise(resolve => {
                let cacheFilename = statics_1.CONSTANTS.BINARY_FILE_CACHE_TEMPLATE(recordId);
                let cacheFullFilename = path.join(self.org.script.binaryCacheDirectory, cacheFilename);
                if (self.org.script.binaryDataCache == enumerations_1.DATA_CACHE_TYPES.FileCache
                    || self.org.script.binaryDataCache == enumerations_1.DATA_CACHE_TYPES.CleanFileCache) {
                    if (fs.existsSync(cacheFullFilename)) {
                        resolve([recordId, statics_1.CONSTANTS.BINARY_FILE_CACHE_RECORD_PLACEHOLDER(recordId)]);
                        return;
                    }
                }
                var conn = self.org.getConnection();
                let blob = conn.sobject(blobField.objectName).record(recordId).blob(blobField.fieldName);
                let buffers = new Array();
                blob.on('data', function (data) {
                    buffers.push(data);
                });
                blob.on('end', function () {
                    if (recordsCounter >= nextProgressInfoAtRecord) {
                        nextProgressInfoAtRecord += statics_1.CONSTANTS.DOWNLOAD_BLOB_PROGRESS_MESSAGE_PER_RECORDS;
                        self.logger.infoNormal(logger_1.RESOURCES.apiCallProgress, recordsCounter + '/' + recordIds.length);
                        lastProgressMessageAt = recordsCounter;
                    }
                    recordsCounter++;
                    let data = Buffer.concat(buffers).toString(blobField.dataType);
                    if (self.org.script.binaryDataCache == enumerations_1.DATA_CACHE_TYPES.FileCache
                        || self.org.script.binaryDataCache == enumerations_1.DATA_CACHE_TYPES.CleanFileCache) {
                        self.logger.infoVerbose(logger_1.RESOURCES.writingToCacheFile, blobField.objectName, path.join('./' + statics_1.CONSTANTS.BINARY_CACHE_SUB_DIRECTORY, cacheFilename));
                        fs.writeFileSync(cacheFullFilename, data, 'utf-8');
                        resolve([recordId, statics_1.CONSTANTS.BINARY_FILE_CACHE_RECORD_PLACEHOLDER(recordId)]);
                        return;
                    }
                    resolve([recordId, data]);
                });
            });
        }
    }
}
exports.Sfdx = Sfdx;
//# sourceMappingURL=sfdx.js.map