"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Logger = exports.COMMAND_EXIT_STATUSES = exports.LOG_LEVEL = exports.LOG_MESSAGE_VERBOSITY = exports.LOG_MESSAGE_TYPE = exports.RESOURCES = void 0;
const fs = require("fs");
const path = require("path");
const common_1 = require("./common");
const statics_1 = require("./statics");
var RESOURCES;
(function (RESOURCES) {
    RESOURCES["newLine"] = "";
    RESOURCES["separator"] = "===========";
    RESOURCES["source"] = "Source";
    RESOURCES["target"] = "Target";
    RESOURCES["step1"] = "step1";
    RESOURCES["step2"] = "step2";
    RESOURCES["pass1"] = "pass1";
    RESOURCES["pass2"] = "pass2";
    RESOURCES["pass3"] = "pass3";
    RESOURCES["pass4"] = "pass4";
    RESOURCES["objectSetStarted"] = "objectSetStarted";
    RESOURCES["csvFile"] = "csvFile";
    RESOURCES["org"] = "org";
    RESOURCES["sourceOrg"] = "sourceOrg";
    RESOURCES["targetOrg"] = "targetOrg";
    RESOURCES["scriptFile"] = "scriptFile";
    RESOURCES["noRecords"] = "noRecords";
    RESOURCES["insert"] = "insert";
    RESOURCES["update"] = "update";
    RESOURCES["personContact"] = "personContact";
    RESOURCES["customAddon"] = "customAddon";
    RESOURCES["cantLoad"] = "cantLoad";
    RESOURCES["global"] = "global";
    RESOURCES["cantLoadModule"] = "cantLoadModule";
    RESOURCES["actionNotPermitted"] = "actionNotPermitted";
    RESOURCES["defaultPromptOptions"] = "defaultPromptOptions";
    RESOURCES["defaultNopromptOption"] = "defaultNopromptOption";
    RESOURCES["defaultPromptNoOption"] = "defaultPromptNoOption";
    RESOURCES["userConfirmTemplate"] = "userConfirmTemplate";
    RESOURCES["userTextInputTemplate"] = "userTextInputTemplate";
    RESOURCES["formattedDateLogTemplate"] = "formattedDateLogTemplate";
    RESOURCES["infoLogTemplate"] = "infoLogTemplate";
    RESOURCES["warnLogTemplate"] = "warnLogTemplate";
    RESOURCES["errorLogTemplate"] = "errorLogTemplate";
    RESOURCES["traceLogTemplate"] = "traceLogTemplate";
    RESOURCES["timeElapsedLogTemplate"] = "timeElapsedLogTemplate";
    RESOURCES["commandStartTemplate"] = "commandStartTemplate";
    RESOURCES["commandFinishTemplate"] = "commandFinishTemplate";
    RESOURCES["infoFileLogTemplate"] = "infoFileLogTemplate";
    RESOURCES["warnFileLogTemplate"] = "warnFileLogTemplate";
    RESOURCES["errorFileLogTemplate"] = "errorFileLogTemplate";
    RESOURCES["commandSucceededResult"] = "commandSucceededResult";
    RESOURCES["commandInitializationErrorResult"] = "commandInitializationErrorResult";
    RESOURCES["commandOrgMetadataErrorResult"] = "commandOrgMetadataErrorResult";
    RESOURCES["commandExecutionErrorResult"] = "commandExecutionErrorResult";
    RESOURCES["commandAbortedDueWarningErrorResult"] = "commandAbortedDueWarningErrorResult";
    RESOURCES["commandAbortedByUserErrorResult"] = "commandAbortedByUserErrorResult";
    RESOURCES["commandAbortedByAddOnErrorResult"] = "commandAbortedByAddOnErrorResult";
    RESOURCES["commandAbortedDueUnexpectedErrorResult"] = "commandAbortedDueUnexpectedErrorResult";
    RESOURCES["commandInProgress"] = "commandInProgress";
    RESOURCES["packageScript"] = "packageScript";
    RESOURCES["pluginVersion"] = "pluginVersion";
    RESOURCES["runningVersion"] = "runningVersion";
    RESOURCES["runningAddOnApiVersion"] = "runningAddOnApiVersion";
    RESOURCES["workingPathDoesNotExist"] = "workingPathDoesNotExist";
    RESOURCES["packageFileDoesNotExist"] = "packageFileDoesNotExist";
    RESOURCES["loadingExportJson"] = "loadingExportJson";
    RESOURCES["objectIsExcluded"] = "objectIsExcluded";
    RESOURCES["noObjectsToProcess"] = "noObjectsToProcess";
    RESOURCES["invalidOperation"] = "invalidOperation";
    RESOURCES["noFieldsToUpdate"] = "noFieldsToUpdate";
    RESOURCES["incorrectExportJsonFormat"] = "incorrectExportJsonFormat";
    RESOURCES["exportJsonFileLoadError"] = "exportJsonFileLoadError";
    RESOURCES["runningInSimulationMode"] = "runningInSimulationMode";
    RESOURCES["connectingToOrg"] = "connectingToOrg";
    RESOURCES["connectingToOrgSf"] = "connectingToOrgSf";
    RESOURCES["successfullyConnected"] = "successfullyConnected";
    RESOURCES["connectingFailed"] = "connectingFailed";
    RESOURCES["cannotMigrateFile2File"] = "cannotMigrateFile2File";
    RESOURCES["accessTokenExpired"] = "accessTokenExpired";
    RESOURCES["malformedQuery"] = "malformedQuery";
    RESOURCES["malformedDeleteQuery"] = "malformedDeleteQuery";
    RESOURCES["personAccountSupportWarning"] = "personAccountSupportWarning";
    RESOURCES["retrievingOrgMatadata"] = "retrievingOrgMatadata";
    RESOURCES["retrievingObjectMetadata"] = "retrievingObjectMetadata";
    RESOURCES["noExternalKey"] = "noExternalKey";
    RESOURCES["missingObjectInSource"] = "missingObjectInSource";
    RESOURCES["missingObjectInTarget"] = "missingObjectInTarget";
    RESOURCES["processingObject"] = "processingObject";
    RESOURCES["missingFieldInSource"] = "missingFieldInSource";
    RESOURCES["missingFieldInTarget"] = "missingFieldInTarget";
    RESOURCES["missingFieldsToProcess"] = "missingFieldsToProcess";
    RESOURCES["addedMissingParentLookupObject"] = "addedMissingParentLookupObject";
    RESOURCES["failedToResolveExternalId"] = "failedToResolveExternalId";
    RESOURCES["fieldIsNotOfPolymorphicType"] = "fieldIsNotOfPolymorphicType";
    RESOURCES["fieldMissingPolymorphicDeclaration"] = "fieldMissingPolymorphicDeclaration";
    RESOURCES["theExternalIdNotFoundInTheQuery"] = "theExternalIdNotFoundInTheQuery";
    RESOURCES["loadingCoreAddonManifestFile"] = "loadingCoreAddonManifestFile";
    RESOURCES["loadingAddonModule"] = "loadingAddonModule";
    RESOURCES["dataMigrationProcessStarted"] = "dataMigrationProcessStarted";
    RESOURCES["buildingMigrationStaregy"] = "buildingMigrationStaregy";
    RESOURCES["readingCsvFileError"] = "readingCsvFileError";
    RESOURCES["writingCsvFileError"] = "writingCsvFileError";
    RESOURCES["readingValuesMappingFile"] = "readingValuesMappingFile";
    RESOURCES["readingFieldsMappingFile"] = "readingFieldsMappingFile";
    RESOURCES["mappingCsvValues"] = "mappingCsvValues";
    RESOURCES["mappingValues"] = "mappingValues";
    RESOURCES["processingCsvFiles"] = "processingCsvFiles";
    RESOURCES["processingCsvFilesSkipped"] = "processingCsvFilesSkipped";
    RESOURCES["writingCsvFile"] = "writingCsvFile";
    RESOURCES["correctCsvFiles"] = "correctCsvFiles";
    RESOURCES["incorrectCsvFiles"] = "incorrectCsvFiles";
    RESOURCES["continueTheJob"] = "continueTheJob";
    RESOURCES["missingCsvFile"] = "missingCsvFile";
    RESOURCES["missingColumnsInCsvFile"] = "missingColumnsInCsvFile";
    RESOURCES["missingParentLookupRecords"] = "missingParentLookupRecords";
    RESOURCES["cantUpdateChildLookupCSVColumn"] = "cantUpdateChildLookupCSVColumn";
    RESOURCES["csvFilesWereUpdated"] = "csvFilesWereUpdated";
    RESOURCES["validationCsvFileCompleted"] = "validationCsvFileCompleted";
    RESOURCES["unableToDeleteTargetDirectory"] = "unableToDeleteTargetDirectory";
    RESOURCES["unableToDeleteCacheDirectory"] = "unableToDeleteCacheDirectory";
    RESOURCES["unableToDeleteSourceDirectory"] = "unableToDeleteSourceDirectory";
    RESOURCES["canModifyPrompt"] = "canModifyPrompt";
    RESOURCES["preparingJob"] = "preparingJob";
    RESOURCES["executingJob"] = "executingJob";
    RESOURCES["executionOrder"] = "executionOrder";
    RESOURCES["queryingOrder"] = "queryingOrder";
    RESOURCES["deletingOrder"] = "deletingOrder";
    RESOURCES["unprocessedRecord"] = "unprocessedRecord";
    RESOURCES["invalidRecordHashcode"] = "invalidRecordHashcode";
    RESOURCES["apiOperationFailed"] = "apiOperationFailed";
    RESOURCES["apiOperationFailedWithMessage"] = "apiOperationFailedWithMessage";
    RESOURCES["apiOperationJobCreated"] = "apiOperationJobCreated";
    RESOURCES["apiOperationBatchCreated"] = "apiOperationBatchCreated";
    RESOURCES["apiOperationDataUploaded"] = "apiOperationDataUploaded";
    RESOURCES["apiOperationInProgress"] = "apiOperationInProgress";
    RESOURCES["apiOperationCompleted"] = "apiOperationCompleted";
    RESOURCES["apiOperationWarnCompleted"] = "apiOperationWarnCompleted";
    RESOURCES["apiOperationStarted"] = "apiOperationStarted";
    RESOURCES["apiOperationFinished"] = "apiOperationFinished";
    RESOURCES["invalidApiOperation"] = "invalidApiOperation";
    RESOURCES["unexpectedApiError"] = "unexpectedApiError";
    RESOURCES["simulationMode"] = "simulationMode";
    RESOURCES["analysingData"] = "analysingData";
    RESOURCES["totalRecordsAmountByQueryString"] = "totalRecordsAmountByQueryString";
    RESOURCES["deletingTargetData"] = "deletingTargetData";
    RESOURCES["deletingSourceData"] = "deletingSourceData";
    RESOURCES["deletingTargetSObjectRecords"] = "deletingTargetSObjectRecords";
    RESOURCES["deletingSourceSObjectRecords"] = "deletingSourceSObjectRecords";
    RESOURCES["amountOfRecordsToDelete"] = "amountOfRecordsToDelete";
    RESOURCES["deletingRecordsCompleted"] = "deletingRecordsCompleted";
    RESOURCES["nothingToDelete"] = "nothingToDelete";
    RESOURCES["nothingToDelete2"] = "nothingToDelete2";
    RESOURCES["deletingDataCompleted"] = "deletingDataCompleted";
    RESOURCES["deletingDataSkipped"] = "deletingDataSkipped";
    RESOURCES["mappingQuery"] = "mappingQuery";
    RESOURCES["mappingSourceRecords"] = "mappingSourceRecords";
    RESOURCES["mappingTargetRecords"] = "mappingTargetRecords";
    RESOURCES["retrievingData"] = "retrievingData";
    RESOURCES["retrievingDataCompleted"] = "retrievingDataCompleted";
    RESOURCES["usingRestApi"] = "usingRestApi";
    RESOURCES["usingBulkAPIQuery"] = "usingBulkAPIQuery";
    RESOURCES["queryingAll"] = "queryingAll";
    RESOURCES["queryingIn"] = "queryingIn";
    RESOURCES["queryingIn2"] = "queryingIn2";
    RESOURCES["retrievingBinaryData"] = "retrievingBinaryData";
    RESOURCES["queryingSelfReferenceRecords"] = "queryingSelfReferenceRecords";
    RESOURCES["queryingFinished"] = "queryingFinished";
    RESOURCES["amuntOfRetrievedRecords"] = "amuntOfRetrievedRecords";
    RESOURCES["queryString"] = "queryString";
    RESOURCES["fetchingSummary"] = "fetchingSummary";
    RESOURCES["apiCallProgress"] = "apiCallProgress";
    RESOURCES["updatingTarget"] = "updatingTarget";
    RESOURCES["deletingTarget"] = "deletingTarget";
    RESOURCES["updatePersonAccountsAndContacts"] = "updatePersonAccountsAndContacts";
    RESOURCES["amountOfRecordsTo"] = "amountOfRecordsTo";
    RESOURCES["updatingTargetObjectCompleted"] = "updatingTargetObjectCompleted";
    RESOURCES["updatingTargetCompleted"] = "updatingTargetCompleted";
    RESOURCES["writingToFile"] = "writingToFile";
    RESOURCES["nothingUpdated"] = "nothingUpdated";
    RESOURCES["skippedUpdatesWarning"] = "skippedUpdatesWarning";
    RESOURCES["skippedSourceRecordsFilterWarning"] = "skippedSourceRecordsFilterWarning";
    RESOURCES["skippedTargetRecordsFilterWarning"] = "skippedTargetRecordsFilterWarning";
    RESOURCES["missingParentLookupsPrompt"] = "missingParentLookupsPrompt";
    RESOURCES["updatingSummary"] = "updatingSummary";
    RESOURCES["updatingTotallyUpdated"] = "updatingTotallyUpdated";
    RESOURCES["processingAddon"] = "processingAddon";
    RESOURCES["runAddonMethod"] = "runAddonMethod";
    RESOURCES["nothingToProcess"] = "nothingToProcess";
    RESOURCES["startAddonExecution"] = "startAddonExecution";
    RESOURCES["stopAddonExecution"] = "stopAddonExecution";
    RESOURCES["coreAddonMessageTemplate"] = "coreAddonMessageTemplate";
    RESOURCES["runAddonMethodCompleted"] = "runAddonMethodCompleted";
    RESOURCES["comandAbortedByAddonResult"] = "comandAbortedByAddonResult";
    RESOURCES["writingToCacheFile"] = "writingToCacheFile";
    RESOURCES["readingFromCacheFile"] = "readingFromCacheFile";
})(RESOURCES || (exports.RESOURCES = RESOURCES = {}));
var LOG_MESSAGE_TYPE;
(function (LOG_MESSAGE_TYPE) {
    LOG_MESSAGE_TYPE[LOG_MESSAGE_TYPE["STRING"] = 30] = "STRING";
    LOG_MESSAGE_TYPE[LOG_MESSAGE_TYPE["SUCCESS"] = 31] = "SUCCESS";
    LOG_MESSAGE_TYPE[LOG_MESSAGE_TYPE["FAILURE"] = 32] = "FAILURE";
    LOG_MESSAGE_TYPE[LOG_MESSAGE_TYPE["STDOUT_ONLY"] = 33] = "STDOUT_ONLY";
    LOG_MESSAGE_TYPE[LOG_MESSAGE_TYPE["TABLE"] = 34] = "TABLE";
    LOG_MESSAGE_TYPE[LOG_MESSAGE_TYPE["JSON"] = 35] = "JSON";
    LOG_MESSAGE_TYPE[LOG_MESSAGE_TYPE["OBJECT"] = 36] = "OBJECT";
    LOG_MESSAGE_TYPE[LOG_MESSAGE_TYPE["HEADER"] = 37] = "HEADER";
    LOG_MESSAGE_TYPE[LOG_MESSAGE_TYPE["WARN"] = 40] = "WARN";
    LOG_MESSAGE_TYPE[LOG_MESSAGE_TYPE["ERROR"] = 50] = "ERROR";
})(LOG_MESSAGE_TYPE || (exports.LOG_MESSAGE_TYPE = LOG_MESSAGE_TYPE = {}));
var LOG_MESSAGE_VERBOSITY;
(function (LOG_MESSAGE_VERBOSITY) {
    LOG_MESSAGE_VERBOSITY[LOG_MESSAGE_VERBOSITY["ALWAYS"] = -1] = "ALWAYS";
    LOG_MESSAGE_VERBOSITY[LOG_MESSAGE_VERBOSITY["NONE"] = 0] = "NONE";
    LOG_MESSAGE_VERBOSITY[LOG_MESSAGE_VERBOSITY["MINIMAL"] = 1] = "MINIMAL";
    LOG_MESSAGE_VERBOSITY[LOG_MESSAGE_VERBOSITY["NORMAL"] = 2] = "NORMAL";
    LOG_MESSAGE_VERBOSITY[LOG_MESSAGE_VERBOSITY["VERBOSE"] = 3] = "VERBOSE";
})(LOG_MESSAGE_VERBOSITY || (exports.LOG_MESSAGE_VERBOSITY = LOG_MESSAGE_VERBOSITY = {}));
var LOG_LEVEL;
(function (LOG_LEVEL) {
    LOG_LEVEL[LOG_LEVEL["TRACE"] = 10] = "TRACE";
    LOG_LEVEL[LOG_LEVEL["DEBUG"] = 20] = "DEBUG";
    LOG_LEVEL[LOG_LEVEL["INFO"] = 30] = "INFO";
    LOG_LEVEL[LOG_LEVEL["WARN"] = 40] = "WARN";
    LOG_LEVEL[LOG_LEVEL["ERROR"] = 50] = "ERROR";
    LOG_LEVEL[LOG_LEVEL["FATAL"] = 60] = "FATAL";
})(LOG_LEVEL || (exports.LOG_LEVEL = LOG_LEVEL = {}));
var COMMAND_EXIT_STATUSES;
(function (COMMAND_EXIT_STATUSES) {
    COMMAND_EXIT_STATUSES[COMMAND_EXIT_STATUSES["SUCCESS"] = 0] = "SUCCESS";
    COMMAND_EXIT_STATUSES[COMMAND_EXIT_STATUSES["COMMAND_UNEXPECTED_ERROR"] = 1] = "COMMAND_UNEXPECTED_ERROR";
    COMMAND_EXIT_STATUSES[COMMAND_EXIT_STATUSES["COMMAND_INITIALIZATION_ERROR"] = 2] = "COMMAND_INITIALIZATION_ERROR";
    COMMAND_EXIT_STATUSES[COMMAND_EXIT_STATUSES["ORG_METADATA_ERROR"] = 3] = "ORG_METADATA_ERROR";
    COMMAND_EXIT_STATUSES[COMMAND_EXIT_STATUSES["COMMAND_EXECUTION_ERROR"] = 4] = "COMMAND_EXECUTION_ERROR";
    COMMAND_EXIT_STATUSES[COMMAND_EXIT_STATUSES["COMMAND_ABORTED_BY_USER"] = 5] = "COMMAND_ABORTED_BY_USER";
    COMMAND_EXIT_STATUSES[COMMAND_EXIT_STATUSES["UNRESOLWABLE_WARNING"] = 6] = "UNRESOLWABLE_WARNING";
    COMMAND_EXIT_STATUSES[COMMAND_EXIT_STATUSES["COMMAND_ABORTED_BY_ADDON"] = 7] = "COMMAND_ABORTED_BY_ADDON";
})(COMMAND_EXIT_STATUSES || (exports.COMMAND_EXIT_STATUSES = COMMAND_EXIT_STATUSES = {}));
class FileLogger {
    constructor(resources, filePath, fileName) {
        this.resources = resources;
        if (!fs.existsSync(filePath)) {
            fs.mkdirSync(filePath);
        }
        this.fileName = path.join(filePath, fileName);
    }
    log(message, omitDate) {
        message = message || "";
        const date = !omitDate && this.resources.getMessage(RESOURCES.formattedDateLogTemplate, [common_1.Common.formatDateTimeShort(new Date())]) || '';
        fs.appendFileSync(this.fileName, message.trim() ? this.resources.getMessage(RESOURCES.infoFileLogTemplate, [date, message]) : '\n');
    }
    warn(message, omitDate) {
        message = message || "";
        const date = !omitDate && this.resources.getMessage(RESOURCES.formattedDateLogTemplate, [common_1.Common.formatDateTimeShort(new Date())]) || '';
        fs.appendFileSync(this.fileName, message.trim() ? this.resources.getMessage(RESOURCES.warnFileLogTemplate, [date, message]) : '\n');
    }
    error(message, omitDate) {
        message = message || "";
        const date = !omitDate && this.resources.getMessage(RESOURCES.formattedDateLogTemplate, [common_1.Common.formatDateTimeShort(new Date())]) || '';
        fs.appendFileSync(this.fileName, message.trim() ? this.resources.getMessage(RESOURCES.errorFileLogTemplate, [date, message]) : '\n');
    }
}
class Logger {
    constructor(resources, commandMessages, uxLogger, command, logLevelFlag, rootPath, verboseFlag, conciseFlag, quietFlag, jsonFlag, noPromptFlag, noWarningsFlag, fileLogFlag, commandOutputMode) {
        this._printStackTrace = false;
        this._spinnerIsStarted = false;
        this._messageCache = [];
        this._resources = resources;
        this._commandMessages = commandMessages;
        this._uxLogger = uxLogger;
        this._jsonFlag = jsonFlag;
        this._filelogFlag = fileLogFlag;
        this._noPromptFlag = noPromptFlag;
        this._noWarningsFlag = noWarningsFlag;
        this._silentFlag = quietFlag;
        this._commandOutputMode = commandOutputMode;
        this._startTime = new Date();
        if (quietFlag) {
            this._uxLogVerbosity = LOG_MESSAGE_VERBOSITY.NONE;
        }
        else if (conciseFlag) {
            this._uxLogVerbosity = LOG_MESSAGE_VERBOSITY.MINIMAL;
        }
        else if (verboseFlag) {
            this._uxLogVerbosity = LOG_MESSAGE_VERBOSITY.VERBOSE;
        }
        else {
            this._uxLogVerbosity = LOG_MESSAGE_VERBOSITY.NORMAL;
        }
        this._uxLogLevel = LOG_LEVEL[String(logLevelFlag).toUpperCase()];
        if (this._uxLogLevel == LOG_LEVEL.DEBUG
            || this._uxLogLevel == LOG_LEVEL.TRACE) {
            this._printStackTrace = this._uxLogLevel == LOG_LEVEL.TRACE;
            this._uxLogLevel = LOG_LEVEL.INFO;
        }
        if (this._uxLogLevel == LOG_LEVEL.FATAL) {
            this._uxLogLevel = LOG_LEVEL.ERROR;
        }
        if (command) {
            let pinfo = common_1.Common.getPluginInfo(command);
            this._commandFullName = pinfo.pluginName + ":" + pinfo.commandName;
        }
        else {
            this._commandFullName = "unknown";
        }
        this._fileLogger = new FileLogger(this._resources, path.join(rootPath, statics_1.CONSTANTS.FILE_LOG_SUBDIRECTORY), `${common_1.Common.formatFileDate(new Date())}.${statics_1.CONSTANTS.FILE_LOG_FILEEXTENSION}`);
        this.commandStartMessage();
    }
    log(message, logMessageType, verbosity, ...tokens) {
        logMessageType = logMessageType || LOG_MESSAGE_TYPE.STRING;
        const isSuccess = logMessageType == LOG_MESSAGE_TYPE.SUCCESS;
        const isFailure = logMessageType == LOG_MESSAGE_TYPE.FAILURE;
        const isStdoutOnly = logMessageType == LOG_MESSAGE_TYPE.STDOUT_ONLY;
        logMessageType = isSuccess || isFailure || isStdoutOnly ? LOG_MESSAGE_TYPE.STRING : logMessageType;
        verbosity = typeof verbosity == 'undefined' ? LOG_MESSAGE_VERBOSITY.NORMAL : verbosity;
        if (typeof message == "undefined" || message == null) {
            return;
        }
        message = typeof message == 'string' ? this.getResourceString.apply(this, [message, ...tokens]) : message;
        let allowWriteLogsToMessageCache = true;
        const allowWriteLogsToSTdOut = ((verbosity <= this._uxLogVerbosity || verbosity == LOG_MESSAGE_VERBOSITY.ALWAYS)
            && (!this._jsonFlag
                || this._jsonFlag && logMessageType == LOG_MESSAGE_TYPE.JSON) && this._uxLogVerbosity != LOG_MESSAGE_VERBOSITY.NONE) || isStdoutOnly;
        const allowWriteLogsToFile = this._filelogFlag
            && logMessageType >= this._uxLogLevel
            && (!this._jsonFlag
                || (this._jsonFlag && logMessageType == LOG_MESSAGE_TYPE.JSON));
        const omitDateWhenWriteLogsToFile = true;
        const date = message && !isStdoutOnly ? this.getResourceString(RESOURCES.formattedDateLogTemplate, common_1.Common.formatDateTimeShort(new Date())) : '';
        let logMessage;
        let foreColor = "";
        switch (logMessageType) {
            default:
                foreColor = isSuccess ? "\x1b[32m" : isFailure ? "\x1b[35m" : "\x1b[36m";
                break;
            case LOG_MESSAGE_TYPE.HEADER:
                foreColor = "\x1b[38m";
                break;
            case LOG_MESSAGE_TYPE.ERROR:
                foreColor = "\x1b[31m";
                break;
            case LOG_MESSAGE_TYPE.WARN:
                foreColor = "\x1b[33m";
                break;
        }
        switch (logMessageType) {
            default:
                logMessage = this.getResourceString(RESOURCES.infoLogTemplate, date, message);
                allowWriteLogsToSTdOut && this._uxLogger.log(foreColor + logMessage);
                break;
            case LOG_MESSAGE_TYPE.ERROR:
                logMessage = this.getResourceString(RESOURCES.errorLogTemplate, date, message);
                allowWriteLogsToSTdOut && this._uxLogger.error(foreColor + logMessage);
                break;
            case LOG_MESSAGE_TYPE.WARN:
                logMessage = this.getResourceString(RESOURCES.warnLogTemplate, date, message);
                allowWriteLogsToSTdOut && !this._noWarningsFlag && this._uxLogger.warn(foreColor + logMessage);
                allowWriteLogsToMessageCache = !this._noWarningsFlag;
                break;
            case LOG_MESSAGE_TYPE.TABLE:
                logMessage = String(message);
                allowWriteLogsToSTdOut && this._uxLogger.table(message.tableBody, {
                    columns: message.tableColumns
                });
                break;
            case LOG_MESSAGE_TYPE.JSON:
                logMessage = JSON.stringify(message, null, 3);
                allowWriteLogsToSTdOut && this._uxLogger.styledJSON(message);
                allowWriteLogsToMessageCache = !this._jsonFlag;
                break;
            case LOG_MESSAGE_TYPE.OBJECT:
                logMessage = JSON.stringify(message, null, 3);
                allowWriteLogsToSTdOut && this._uxLogger.styledObject(message);
                break;
            case LOG_MESSAGE_TYPE.HEADER:
                logMessage = String(message).toUpperCase();
                allowWriteLogsToSTdOut && this._uxLogger.styledHeader(foreColor + message);
                break;
        }
        allowWriteLogsToFile && this._fileLogger.log(logMessage, omitDateWhenWriteLogsToFile);
        allowWriteLogsToMessageCache && this._messageCache.push(logMessage);
    }
    infoNormal(message, ...tokens) {
        this.log.apply(this, [message, LOG_MESSAGE_TYPE.STRING, LOG_MESSAGE_VERBOSITY.NORMAL, ...tokens]);
    }
    infoMinimal(message, ...tokens) {
        this.log.apply(this, [message, LOG_MESSAGE_TYPE.STRING, LOG_MESSAGE_VERBOSITY.MINIMAL, ...tokens]);
    }
    infoVerbose(message, ...tokens) {
        this.log.apply(this, [message, LOG_MESSAGE_TYPE.STRING, LOG_MESSAGE_VERBOSITY.VERBOSE, ...tokens]);
    }
    headerMinimal(message, ...tokens) {
        this.log.apply(this, [message, LOG_MESSAGE_TYPE.HEADER, LOG_MESSAGE_VERBOSITY.MINIMAL, ...tokens]);
    }
    headerNormal(message, ...tokens) {
        this.log.apply(this, [message, LOG_MESSAGE_TYPE.HEADER, LOG_MESSAGE_VERBOSITY.NORMAL, ...tokens]);
    }
    headerVerbose(message, ...tokens) {
        this.log.apply(this, [message, LOG_MESSAGE_TYPE.HEADER, LOG_MESSAGE_VERBOSITY.VERBOSE, ...tokens]);
    }
    objectNormal(message) {
        this.log.apply(this, [message, LOG_MESSAGE_TYPE.OBJECT, LOG_MESSAGE_VERBOSITY.NORMAL]);
    }
    objectMinimal(message) {
        this.log.apply(this, [message, LOG_MESSAGE_TYPE.OBJECT, LOG_MESSAGE_VERBOSITY.MINIMAL]);
    }
    warn(message, ...tokens) {
        this.log.apply(this, [message, LOG_MESSAGE_TYPE.WARN, LOG_MESSAGE_VERBOSITY.NORMAL, ...tokens]);
    }
    error(message, ...tokens) {
        this.log.apply(this, [message, LOG_MESSAGE_TYPE.ERROR, LOG_MESSAGE_VERBOSITY.NORMAL, ...tokens]);
    }
    async promptAsync(params, ...tokens) {
        params.nopromptDefault = (typeof params.nopromptDefault == 'undefined' ? this.getResourceString(RESOURCES.defaultNopromptOption) : params.nopromptDefault || "").trim();
        const date = this.getResourceString(RESOURCES.formattedDateLogTemplate, common_1.Common.formatDateTimeShort(new Date()));
        params.options = (typeof params.options == 'undefined' ? this.getResourceString(RESOURCES.defaultPromptOptions) : params.options || "").trim();
        params.default = (typeof params.default == 'undefined' ? this.getResourceString(RESOURCES.defaultPromptNoOption) : params.default || "").trim();
        params.message = date + " " + (this.getResourceString.apply(this, [params.message, ...tokens]) || "").trim();
        params.timeout = params.timeout || (params.options ? statics_1.CONSTANTS.DEFAULT_USER_PROMPT_TIMEOUT_MS : statics_1.CONSTANTS.DEFAULT_USER_PROMT_TEXT_ENTER_TIMEOUT_MS);
        params.message = this.getResourceString(params.options ? RESOURCES.userConfirmTemplate : RESOURCES.userTextInputTemplate, params.message, params.options);
        let result = params.default;
        try {
            if (this._uxLogVerbosity == LOG_MESSAGE_VERBOSITY.NONE
                || this._noPromptFlag
                || this._jsonFlag
                || this._silentFlag) {
                this.infoNormal(params.message + ' ' + params.nopromptDefault);
                result = params.nopromptDefault;
            }
            else {
                this.stopSpinner();
                result = await this._uxLogger.prompt("\x1b[32m" + params.message, {
                    default: params.default,
                    timeout: params.timeout
                });
            }
        }
        catch (ex) { }
        finally {
            this.startSpinner();
        }
        return result;
    }
    async yesNoPromptAsync(message, ...tokens) {
        return (await this.promptAsync.apply(this, [{
                message
            }, ...tokens])) != this.getResourceString(RESOURCES.defaultPromptNoOption);
    }
    async textPromptAsync(message, ...tokens) {
        return (await this.promptAsync.apply(this, [{
                default: "",
                options: "",
                message
            }, ...tokens]));
    }
    commandStartMessage() {
        this.startSpinner();
        this.log(this.getResourceString(RESOURCES.commandStartTemplate, this._commandFullName), LOG_MESSAGE_TYPE.STRING, LOG_MESSAGE_VERBOSITY.MINIMAL);
    }
    commandFinishMessage(message, status, stack, ...tokens) {
        this.stopSpinner();
        if (typeof message == "undefined" || message == null) {
            return;
        }
        this.log('');
        const printStackTrace = this._printStackTrace && status == COMMAND_EXIT_STATUSES.COMMAND_UNEXPECTED_ERROR && stack;
        let statusString = COMMAND_EXIT_STATUSES[status].toString();
        let endTime = new Date();
        let timeElapsedString = common_1.Common.timeDiffString(this._startTime, endTime);
        message = this.getResourceString(message, ...tokens);
        const stackArr = printStackTrace && stack.split('\n');
        if (this._jsonFlag) {
            this.log({
                command: this._commandFullName,
                cliCommandString: common_1.Common.getFullCommandLine(),
                endTime: common_1.Common.convertUTCDateToLocalDate(endTime),
                endTimeUTC: endTime,
                message: message,
                fullLog: this._messageCache,
                stack: printStackTrace ? stackArr : [],
                startTime: common_1.Common.convertUTCDateToLocalDate(this._startTime),
                startTimeUTC: this._startTime,
                status: status,
                statusString: statusString,
                timeElapsedString: timeElapsedString
            }, LOG_MESSAGE_TYPE.JSON, LOG_MESSAGE_VERBOSITY.ALWAYS, ...tokens);
        }
        else {
            this.log(String(message), status == COMMAND_EXIT_STATUSES.SUCCESS ? LOG_MESSAGE_TYPE.SUCCESS : LOG_MESSAGE_TYPE.ERROR, LOG_MESSAGE_VERBOSITY.MINIMAL, ...tokens);
            if (printStackTrace) {
                this.log(this.getResourceString(RESOURCES.traceLogTemplate, stack), LOG_MESSAGE_TYPE.ERROR, LOG_MESSAGE_VERBOSITY.MINIMAL);
            }
            this.log(this.getResourceString(RESOURCES.commandFinishTemplate, this._commandFullName, String(status), statusString), status == COMMAND_EXIT_STATUSES.SUCCESS ? LOG_MESSAGE_TYPE.SUCCESS : LOG_MESSAGE_TYPE.ERROR, LOG_MESSAGE_VERBOSITY.MINIMAL);
            this.log(this.getResourceString(RESOURCES.timeElapsedLogTemplate, timeElapsedString), LOG_MESSAGE_TYPE.STRING, LOG_MESSAGE_VERBOSITY.MINIMAL);
        }
        this._uxLogger.log("\x1b[37m");
    }
    spinner(message, ...tokens) {
        message = this.getResourceString.apply(this, [message, ...tokens]);
        if (!message) {
            this._spinnerIsStarted = false;
            this._uxLogger.stopSpinner();
        }
        else if (!this._spinnerIsStarted) {
            this._uxLogger.startSpinner(message);
            this._spinnerIsStarted = true;
        }
        else {
            this._uxLogger.setSpinnerStatus(message);
        }
    }
    startSpinner() {
        if (!this._commandOutputMode) {
            this.spinner(RESOURCES.commandInProgress);
        }
    }
    stopSpinner() {
        this.spinner();
    }
    getResourceString(message, ...tokens) {
        if (!message || typeof message != "string")
            return message;
        try {
            let mes = this._resources.getMessage(String(message), tokens);
            return mes;
        }
        catch (ex) {
            try {
                let mes = this._commandMessages.getMessage(String(message), tokens);
                return mes;
            }
            catch (ex) {
                return message;
            }
        }
    }
    getStartTime() {
        return this._startTime;
    }
}
exports.Logger = Logger;
//# sourceMappingURL=logger.js.map