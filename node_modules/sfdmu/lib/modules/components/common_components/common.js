"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Common = void 0;
const buffer_1 = require("buffer");
const child_process_1 = require("child_process");
const parse2 = require('csv-parse/lib/sync');
const fs = require("fs");
const glob2 = require("glob");
const path = require("path");
const Throttle = require("promise-parallel-throttle");
const readline = require("readline");
const soql_parser_js_1 = require("soql-parser-js");
const models_1 = require("../../models");
const logger_1 = require("./logger");
const statics_1 = require("./statics");
const stream_1 = require("stream");
const parse = parse2.parse || parse2;
const glob = glob2.glob || glob2;
const { closest } = require('fastest-levenshtein');
const createCsvStringifier = require('csv-writer').createObjectCsvStringifier;
class Common {
    static chunkArray(array, chunkMaxSize) {
        var i, j, arr = new Array();
        for (i = 0, j = array.length; i < j; i += chunkMaxSize) {
            arr.push(array.slice(i, i + chunkMaxSize));
        }
        return arr;
    }
    static formatDateTimeShort(date, addMilliseconds = true) {
        if (addMilliseconds) {
            return `${date.toLocaleTimeString(undefined, { hour12: false })}.${date.getMilliseconds()}`;
        }
        return `${date.toLocaleTimeString(undefined, { hour12: false })}`;
    }
    static formatFileDate(date) {
        return this.formatDateTime(date, false).replace(/[:]/g, "_").replace(/\s/g, "_").replace(/[/]/g, "_");
    }
    static getPluginInfo(command) {
        let statics = command.statics;
        let pjson = require(path.join(statics.plugin.root, '/package.json'));
        let runAddOnApiInfo = pjson.addons.run;
        let info = {
            commandName: statics.name.toLowerCase(),
            pluginName: statics.plugin.name,
            version: pjson.version,
            path: statics.plugin.root,
            runAddOnApiInfo
        };
        info.commandString = `sfdx ${info.pluginName}:${info.commandName} ${command.argv.join(' ')}`;
        info.argv = command.argv;
        return info;
    }
    static formatDateTime(date, addMilliseconds = true) {
        var hours = date.getHours();
        var minutes = date.getMinutes();
        var seconds = date.getSeconds();
        var ms = date.getMilliseconds();
        hours = hours % 24;
        var strTime = this.addLeadnigZeros(hours, 2) + ':' + this.addLeadnigZeros(minutes, 2) + ':' + this.addLeadnigZeros(seconds, 2) + (addMilliseconds ? "." + this.addLeadnigZeros(ms, 3) : "");
        return date.getFullYear() + "-" + this.addLeadnigZeros(date.getMonth() + 1, 2) + "-" + this.addLeadnigZeros(date.getDate(), 2) + "  " + strTime;
    }
    static timeDiffString(dateStart, dateEnd) {
        var duration = Math.abs(dateEnd.getTime() - dateStart.getTime());
        var milliseconds = (duration % 1000), seconds = (duration / 1000) % 60, minutes = (duration / (1000 * 60)) % 60, hours = (duration / (1000 * 60 * 60)) % 24;
        return this.addLeadnigZeros(Math.floor(hours), 2)
            + "h " + this.addLeadnigZeros(Math.floor(minutes), 2)
            + "m " + this.addLeadnigZeros(Math.floor(seconds), 2)
            + "s " + this.addLeadnigZeros(Math.floor(milliseconds), 3)
            + "ms ";
    }
    static getFullCommandLine() {
        if (process.argv.length >= 3)
            return "sfdx " + process.argv.slice(2).join(' ');
        return process.argv.join(' ');
    }
    static convertUTCDateToLocalDate(date) {
        var newDate = new Date(date.getTime() + date.getTimezoneOffset() * 60 * 1000);
        var offset = date.getTimezoneOffset() / 60;
        var hours = date.getHours();
        newDate.setHours(hours - offset);
        return newDate;
    }
    static addLeadnigZeros(num, size) {
        var s = String(num);
        while (s.length < (size || 2)) {
            s = "0" + s;
        }
        return s;
    }
    static transformArrayOfArrays(array) {
        if (!array || array.length == 0)
            return new Array();
        let props = array[0];
        let singleArray = array.slice(1).map((subArray) => {
            return subArray.reduce((item, subArrayItem, propIndex) => {
                item[props[propIndex]] = subArrayItem;
                return item;
            }, {});
        });
        return singleArray;
    }
    static arrayToMapByHashcode(array, propsToExclude) {
        let m = new Map();
        array.forEach(x => {
            let hash = String(this.getObjectHashcode(x, propsToExclude));
            let h = hash;
            let counter = 0;
            while (m.has(hash)) {
                hash = h + "_" + String(counter++);
            }
            m.set(hash, x);
        });
        return m;
    }
    static arrayToMapByProperty(array, propertyName) {
        let m = new Map();
        array.forEach(x => {
            let key = String(x[propertyName]);
            let k = key;
            let counter = 0;
            while (m.has(key)) {
                key = k + "_" + String(counter++);
            }
            m.set(key, x);
        });
        return m;
    }
    static compareArraysByHashcode(arrayOfKeys, arrayOfValues, propsToExclude, mkeys, mvalues) {
        arrayOfKeys = arrayOfKeys || new Array();
        arrayOfValues = arrayOfValues || new Array();
        if (!mkeys) {
            mkeys = this.arrayToMapByHashcode(arrayOfKeys, propsToExclude);
        }
        if (!mvalues) {
            mvalues = this.arrayToMapByHashcode(arrayOfValues, propsToExclude);
        }
        let retMap = new Map();
        [...mkeys.keys()].forEach(hash => {
            retMap.set(mkeys.get(hash), mvalues.get(hash));
        });
        return retMap;
    }
    static compareArraysByProperty(arrayOfKeys, arrayOfValues, propertyName, mkeys, mvalues) {
        arrayOfKeys = arrayOfKeys || new Array();
        arrayOfValues = arrayOfValues || new Array();
        if (!mkeys) {
            mkeys = this.arrayToMapByProperty(arrayOfKeys, propertyName);
        }
        if (!mvalues) {
            mvalues = this.arrayToMapByProperty(arrayOfValues, propertyName);
        }
        let retMap = new Map();
        [...mkeys.keys()].forEach(key => {
            retMap.set(mkeys.get(key), mvalues.get(key));
        });
        return retMap;
    }
    static getStringHashcode(inputString) {
        return !inputString ? 0 : inputString.split("").reduce(function (a, b) { a = ((a << 5) - a) + b.charCodeAt(0); return a & a; }, 0);
    }
    static getString32FNV1AHashcode(inputString, asString, seed) {
        var i, l, hval = (seed === undefined) ? 0x811c9dc5 : seed;
        for (i = 0, l = inputString.length; i < l; i++) {
            hval ^= inputString.charCodeAt(i);
            hval += (hval << 1) + (hval << 4) + (hval << 7) + (hval << 8) + (hval << 24);
        }
        if (asString) {
            return ("0000000" + (hval >>> 0).toString(16)).substr(-8);
        }
        return hval >>> 0;
    }
    static getObjectHashcode(inputObject, propsToExclude = new Array()) {
        if (!inputObject)
            return 0;
        let keys = Object.keys(inputObject).filter(k => propsToExclude.indexOf(k) < 0).sort();
        let str = keys.map(k => {
            let v = inputObject[k];
            return v == "TRUE" || v == true ? "true"
                : v == "FALSE" || v == false ? "false"
                    : !isNaN(v) ? String(+v)
                        : !isNaN(Date.parse(v)) ? String(Date.parse(v))
                            : !v || v == "#N/A" ? '' : String(v).replace(/[\n\r\s]/gi, '');
        }).join('');
        return this.getStringHashcode(str);
    }
    static trimEndStr(str, toTrim) {
        if (str.endsWith(toTrim)) {
            return str.substring(0, str.lastIndexOf(toTrim));
        }
        else {
            return str;
        }
    }
    static replaceLast(original, toReplace, replacement) {
        if (original.endsWith(toReplace)) {
            const startPos = original.length - toReplace.length;
            return original.substring(0, startPos) + replacement;
        }
        return original;
    }
    static execSfdx(command, targetusername) {
        if (typeof targetusername != "undefined")
            return (0, child_process_1.execSync)(`sfdx ${command} --targetusername ${targetusername}`).toString();
        else
            return (0, child_process_1.execSync)(`sfdx ${command}`).toString();
    }
    ;
    static execSf(command, targetusername) {
        if (typeof targetusername != "undefined")
            return (0, child_process_1.execSync)(`sf ${command} --target-org ${targetusername}`).toString();
        else
            return (0, child_process_1.execSync)(`sf ${command}`).toString();
    }
    ;
    static composeWhereClause(where, fieldName, values, operator = "IN", literalType = "STRING", logicalOperator = "OR") {
        let valuesIsArray = Array.isArray(values);
        let values2 = [].concat(values).filter(x => !!x).map(x => x.replace(/\\/g, "\\\\").replace(/'/g, "\\'"));
        if (!valuesIsArray) {
            values2 = values2[0];
        }
        let c = { field: fieldName, operator: operator, value: values2, literalType: literalType };
        if (!where || !where.left) {
            let ret = { left: c };
            ret.left.openParen = 1;
            ret.left.closeParen = 1;
            return ret;
        }
        else {
            where.left.openParen = (where.left.openParen || 0) + 1;
            where.left.closeParen = (where.left.closeParen || 0) + 1;
            c.openParen = 1;
            c.closeParen = 1;
            let ret = { left: c, right: where, operator: logicalOperator };
            return ret;
        }
    }
    static distinctArray(array, distinctByProp, stringIgnoreCase) {
        return array.filter((obj, pos, arr) => {
            if (!stringIgnoreCase) {
                return arr.map(mapObj => mapObj[distinctByProp])
                    .indexOf(obj[distinctByProp]) === pos;
            }
            return arr.map(mapObj => (mapObj[distinctByProp] || '').toLowerCase())
                .indexOf((obj[distinctByProp] || '').toLowerCase()) === pos;
        });
    }
    static distinctStringArray(array, stringIgnoreCase) {
        if (!stringIgnoreCase) {
            return [...new Set(array)];
        }
        let m = new Map(array.map(s => [s.toLowerCase(), s]));
        return [...m.values()];
    }
    static removeBy(arr, field, value) {
        return arr.splice(arr.findIndex(item => item[field] == value), 1);
    }
    static filterMapByArray(keysToFilter, sourceMap, defaultValueCallback, addDefaultValueToSourceMapIfNotExist) {
        return keysToFilter.reduce((mapAccumulator, key) => {
            let obj = sourceMap.get(key);
            if (obj) {
                mapAccumulator.set(key, obj);
            }
            else if (defaultValueCallback) {
                let value = defaultValueCallback(key);
                mapAccumulator.set(key, value);
                if (addDefaultValueToSourceMapIfNotExist) {
                    sourceMap.set(key, value);
                }
            }
            return mapAccumulator;
        }, new Map());
    }
    static isComplexOr__rField(fieldName) {
        return fieldName && (fieldName.indexOf('.') >= 0
            || fieldName.indexOf(statics_1.CONSTANTS.COMPLEX_FIELDS_SEPARATOR) >= 0
            || fieldName.startsWith(statics_1.CONSTANTS.COMPLEX_FIELDS_QUERY_PREFIX));
    }
    static isDescriptionPropertyMatching(fieldDescribeProperty, patternProperty, negative = false) {
        if (!negative)
            return fieldDescribeProperty == patternProperty || typeof patternProperty == "undefined";
        else
            return fieldDescribeProperty != patternProperty && typeof fieldDescribeProperty != "undefined";
    }
    static is__rField(fieldName) {
        return fieldName && fieldName.indexOf('.') >= 0;
    }
    static isComplexField(fieldName) {
        return fieldName && (fieldName.indexOf(statics_1.CONSTANTS.COMPLEX_FIELDS_SEPARATOR) >= 0
            || fieldName.startsWith(statics_1.CONSTANTS.COMPLEX_FIELDS_QUERY_PREFIX));
    }
    static isContainsComplexField(fieldName) {
        return fieldName && fieldName.indexOf(statics_1.CONSTANTS.COMPLEX_FIELDS_QUERY_PREFIX) >= 0;
    }
    static getComplexField(fieldName) {
        if (!fieldName)
            return fieldName;
        if (fieldName.indexOf(statics_1.CONSTANTS.COMPLEX_FIELDS_SEPARATOR) >= 0) {
            return statics_1.CONSTANTS.COMPLEX_FIELDS_QUERY_PREFIX
                + fieldName.replace(new RegExp(`[${statics_1.CONSTANTS.COMPLEX_FIELDS_SEPARATOR}]`, 'g'), statics_1.CONSTANTS.COMPLEX_FIELDS_QUERY_SEPARATOR);
        }
        return fieldName;
    }
    static getFieldFromComplexField(fieldName) {
        if (!fieldName || !Common.isContainsComplexField(fieldName))
            return fieldName;
        return fieldName.replace(statics_1.CONSTANTS.COMPLEX_FIELDS_QUERY_PREFIX, '')
            .replace(new RegExp(`[${statics_1.CONSTANTS.COMPLEX_FIELDS_QUERY_SEPARATOR}]`, 'g'), statics_1.CONSTANTS.COMPLEX_FIELDS_SEPARATOR);
    }
    static async readCsvFileAsync(filePath, linesAmountToRead = 0, columnToColumnDataTypeMap) {
        return new Promise(resolve => {
            if (!fs.existsSync(filePath)) {
                resolve(new Array());
                return;
            }
            try {
                if (linesAmountToRead == 0) {
                    let input = fs.readFileSync(filePath, 'utf8');
                    input = input.replace(/^\uFEFF/, '');
                    const records = parse(input, {
                        columns: ___columns,
                        delimiter: Common.csvReadFileDelimiter,
                        skip_empty_lines: true,
                        skip_lines_with_error: true,
                        cast: ___csvCast
                    });
                    resolve([...records]);
                }
                else {
                    let lineReader = readline.createInterface({
                        input: fs.createReadStream(filePath, { encoding: 'utf8' })
                    });
                    let lineCounter = 0;
                    let wantedLines = [];
                    lineReader.on('line', function (line) {
                        lineCounter++;
                        wantedLines.push(line);
                        if (lineCounter == linesAmountToRead) {
                            lineReader.close();
                        }
                    });
                    lineReader.on('close', function () {
                        if (wantedLines.length == 1) {
                            let output = [wantedLines[0].split(',').reduce((acc, field) => {
                                    acc[field] = null;
                                    return acc;
                                }, {})];
                            resolve(output);
                            return;
                        }
                        let input = wantedLines.join('\n');
                        const records = parse(input, {
                            columns: true,
                            skip_empty_lines: true,
                            skip_lines_with_error: true,
                            cast: ___csvCast
                        });
                        resolve([...records]);
                    });
                }
            }
            catch (ex) {
                throw new models_1.CommandExecutionError(this.logger.getResourceString(logger_1.RESOURCES.readingCsvFileError, filePath, ex.message));
            }
        });
        function ___csvCast(value, context) {
            if (context.header || typeof context.column == "undefined") {
                return value;
            }
            let fieldType = columnToColumnDataTypeMap && columnToColumnDataTypeMap.get(context.column);
            if (fieldType == "boolean") {
                if (value == "1" || value == "TRUE" || value == "true")
                    return true;
                else
                    return false;
            }
            if (!value) {
                return null;
            }
            return value;
        }
        function ___columns(header) {
            if (!columnToColumnDataTypeMap) {
                return header;
            }
            return header.map((column) => {
                if (column.indexOf('.') >= 0
                    || column.indexOf(statics_1.CONSTANTS.COMPLEX_FIELDS_QUERY_SEPARATOR) >= 0
                    || column.indexOf(statics_1.CONSTANTS.COMPLEX_FIELDS_SEPARATOR) >= 0
                    || columnToColumnDataTypeMap.has(column))
                    return column;
                else {
                    return undefined;
                }
            });
        }
    }
    static async writeCsvFileAsync(filePath, array, createEmptyFileOnEmptyArray = false, columns) {
        try {
            if (!array || array.length == 0) {
                if (createEmptyFileOnEmptyArray) {
                    fs.writeFileSync(filePath, "");
                }
                return;
            }
            class CsvTransformStream extends stream_1.Transform {
                constructor() {
                    super({ objectMode: true });
                    this._first = true;
                    this._stringifier = createCsvStringifier({
                        fieldDelimiter: Common.csvWriteFileDelimiter,
                        header: (columns || Object.keys(array[0])).map(x => {
                            return {
                                id: x,
                                title: x
                            };
                        }).sort((a, b) => { return a.id.localeCompare(b.id); }),
                    });
                }
                _transform(record, encoding, callback) {
                    const line = this._stringifier.stringifyRecords([record]);
                    if (this._first) {
                        this._first = false;
                        callback(null, this._stringifier.getHeaderString() + line);
                    }
                    else {
                        callback(null, line);
                    }
                }
            }
            const fileStream = fs.createWriteStream(filePath);
            const csvTransformStream = new CsvTransformStream();
            csvTransformStream.pipe(fileStream);
            for (const record of array) {
                csvTransformStream.write(record);
            }
            csvTransformStream.end();
            return new Promise((resolve, reject) => {
                fileStream.on('finish', resolve);
                fileStream.on('error', reject);
            });
        }
        catch (ex) {
            throw new models_1.CommandExecutionError(this.logger.getResourceString(logger_1.RESOURCES.writingCsvFileError, filePath, ex.message));
        }
    }
    static async mergeCsvFilesAsync(source1FilePath, source2FilePath, targetFilePath, deleteSourceFiles, ...columns) {
        let totalRows = new Array();
        await ___addRowsFromFile(source1FilePath);
        await ___addRowsFromFile(source2FilePath);
        await this.writeCsvFileAsync(targetFilePath, totalRows);
        async function ___addRowsFromFile(file) {
            if (fs.existsSync(file)) {
                let rows = await Common.readCsvFileAsync(file);
                rows.forEach(row => {
                    let thisRow = columns.reduce((acc, column) => {
                        if (typeof row[column] != "undefined") {
                            acc[column] = row[column];
                        }
                        else {
                            acc[column] = null;
                        }
                        return acc;
                    }, {});
                    totalRows.push(thisRow);
                });
                if (deleteSourceFiles) {
                    fs.unlinkSync(file);
                }
            }
        }
    }
    static createCsvStringsFromArray(array, maxCsvStringSizeInBytes, blockSize, lineDelimiter = '\n', encoding = 'utf-8') {
        if (!array || array.length == 0)
            return new models_1.CsvChunks();
        const arrayBlocks = this.chunkArray(array, blockSize);
        const headerArray = Object.keys(array[0]).map(key => {
            return {
                id: key,
                title: key
            };
        }).sort((a, b) => { return a.id.localeCompare(b.id); });
        const csvStringifier = createCsvStringifier({
            header: headerArray,
            alwaysQuote: true,
            recordDelimiter: lineDelimiter
        });
        let header = csvStringifier.getHeaderString();
        let csvStrings = new Array();
        let buffer = buffer_1.Buffer.from('', encoding);
        let totalCsvChunkSize = 0;
        let csvBlock;
        let arrayBuffer = new Array();
        for (let index = 0; index < arrayBlocks.length; index++) {
            const arrayBlock = arrayBlocks[index];
            csvBlock = buffer_1.Buffer.from(csvStringifier.stringifyRecords(arrayBlock), encoding);
            let csvBlockSize = csvBlock.toString('base64').length;
            if (totalCsvChunkSize + csvBlockSize <= maxCsvStringSizeInBytes) {
                buffer = buffer_1.Buffer.concat([buffer, csvBlock]);
                arrayBuffer = arrayBuffer.concat(arrayBlock);
            }
            else {
                if (arrayBuffer.length > 0) {
                    csvStrings.push([arrayBuffer, (header + buffer.toString(encoding)).trim()]);
                }
                buffer = csvBlock;
                arrayBuffer = arrayBlock;
                totalCsvChunkSize = 0;
            }
            totalCsvChunkSize += csvBlockSize;
        }
        if (arrayBuffer.length > 0) {
            csvStrings.push([arrayBuffer, (header + buffer.toString('utf-8')).trim()]);
        }
        return new models_1.CsvChunks({
            chunks: csvStrings.map(x => {
                return {
                    records: x[0],
                    csvString: x[1]
                };
            }),
            header: headerArray.map(x => x.id)
        });
    }
    static async readCsvFileOnceAsync(csvDataCacheMap, fileName, indexFieldName, indexValueLength, useRowIndexAutonumber, addIndexKeyValues) {
        indexFieldName = indexFieldName || "Id";
        indexValueLength = indexValueLength || 18;
        useRowIndexAutonumber = typeof useRowIndexAutonumber == "undefined" || useRowIndexAutonumber == null ? false : useRowIndexAutonumber;
        addIndexKeyValues = typeof addIndexKeyValues == "undefined" || addIndexKeyValues == null ? true : addIndexKeyValues;
        let currentFileMap = csvDataCacheMap.get(fileName);
        if (!currentFileMap) {
            if (!fs.existsSync(fileName)) {
                return new Map();
            }
            let csvRows = await Common.readCsvFileAsync(fileName);
            currentFileMap = new Map();
            csvRows.forEach((row, index) => {
                let indexKey = useRowIndexAutonumber ? String(index + 1) : Common.makeId(indexValueLength).toUpperCase();
                if (!row[indexFieldName] && addIndexKeyValues) {
                    row[indexFieldName] = indexKey;
                }
                currentFileMap.set(row[indexFieldName] || indexKey, row);
            });
            csvDataCacheMap.set(fileName, currentFileMap);
        }
        return currentFileMap;
    }
    static listDirAsync(fileDirectory, fileMask = "*") {
        return new Promise(resolve => {
            let fn = path.join(fileDirectory, fileMask);
            glob(fn, undefined, function (er, files) {
                resolve(files);
            });
        });
    }
    static async abortWithPrompt(warnMessage, showPrompt, promptMessage, errorMessage, onBeforeAbortAsync, ...warnTokens) {
        this.logger.warn.apply(this.logger, [warnMessage, ...warnTokens]);
        if (showPrompt) {
            if (!(await this.logger.yesNoPromptAsync(promptMessage))) {
                this.logger.log(logger_1.RESOURCES.newLine);
                if (onBeforeAbortAsync) {
                    await onBeforeAbortAsync();
                }
                throw new models_1.CommandAbortedByUserError(errorMessage);
            }
            this.logger.log(logger_1.RESOURCES.newLine);
        }
    }
    static makeId(length = 10) {
        var result = '';
        var characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
        var charactersLength = characters.length;
        for (var i = 0; i < length; i++) {
            result += characters.charAt(Math.floor(Math.random() * charactersLength));
        }
        return result;
    }
    static isCustomObject(objectName) {
        if (!objectName)
            return false;
        return objectName.endsWith('__c')
            || objectName.endsWith('__pc')
            || objectName.endsWith('__s');
    }
    static splitMulti(str, separators) {
        var tempChar = 't3mp';
        var regex = new RegExp('\\b(' + separators.join('|') + ')\\b', "g");
        let temp = str.replace(regex, tempChar).split(tempChar);
        return temp.map(el => el.trim()).filter(el => el.length > 0);
    }
    static extractWhereClause(query) {
        if ((query || '').match(/WHERE/i)) {
            return query.match(/^.*?WHERE.*?(.+?(?=LIMIT|OFFSET|GROUP|ORDER|$))/i)[1].trim();
        }
        return null;
    }
    static createFieldInQueries(selectFields, fieldName = "Id", sObjectName, valuesIN, whereClause, orderByClause) {
        if (valuesIN.length == 0) {
            return new Array();
        }
        const whereClauseLength = (whereClause || '').length;
        let tempQuery = {
            fields: selectFields.map(field => (0, soql_parser_js_1.getComposedField)(field)),
            where: {},
            sObject: sObjectName
        };
        let whereValuesCounter = 0;
        let whereValues = new Array();
        let parsedWhere;
        if (whereClause) {
            parsedWhere = (0, soql_parser_js_1.parseQuery)('SELECT Id FROM Account WHERE (' + whereClause + ')');
        }
        let parsedOrderBy;
        if (orderByClause) {
            parsedOrderBy = (0, soql_parser_js_1.parseQuery)('SELECT Id FROM Account ORDER BY ' + orderByClause + '');
        }
        function* queryGen() {
            while (true) {
                for (let whereClausLength = whereClauseLength; whereClausLength < statics_1.CONSTANTS.MAX_SOQL_WHERE_CLAUSE_CHARACTER_LENGTH;) {
                    let value = String(valuesIN[whereValuesCounter] || "").replace(/(['\\])/g, "\\$1");
                    whereValues.push(value);
                    whereClausLength += value.length + 4;
                    whereValuesCounter++;
                    if (whereValuesCounter == valuesIN.length)
                        break;
                }
                let c = {
                    field: fieldName,
                    operator: "IN",
                    value: whereValues,
                    literalType: "STRING"
                };
                tempQuery.where.left = c;
                if (parsedWhere) {
                    tempQuery.where.left.openParen = 1;
                    tempQuery.where.left.closeParen = 1;
                    tempQuery.where.right = parsedWhere.where;
                    tempQuery.where.operator = "AND";
                }
                if (parsedOrderBy) {
                    tempQuery.orderBy = parsedOrderBy.orderBy;
                }
                yield (0, soql_parser_js_1.composeQuery)(tempQuery);
                whereValues = new Array();
                if (whereValuesCounter == valuesIN.length)
                    break;
            }
        }
        return [...queryGen()];
    }
    static flattenArrays(arrays) {
        return arrays.reduce(function (flat, toFlatten) {
            return flat.concat(Array.isArray(toFlatten) ? Common.flattenArrays(toFlatten) : toFlatten);
        }, []);
    }
    static cloneArrayOfObjects(objects, propsToInclude = new Array()) {
        let cloneToOriginalMap = new Map();
        objects.forEach(original => {
            let cloned = Object.assign({}, original);
            if (propsToInclude.length == 0) {
                cloneToOriginalMap.set(cloned, original);
                return;
            }
            Object.keys(cloned).forEach(key => {
                if (propsToInclude.indexOf(key) < 0) {
                    delete cloned[key];
                }
            });
            cloneToOriginalMap.set(cloned, original);
        });
        return cloneToOriginalMap;
    }
    static cloneObjectIncludeProps(objectToClone, ...propsToInclude) {
        if (!objectToClone || Array.isArray(objectToClone) || typeof objectToClone != 'object')
            return objectToClone;
        return Object.keys(objectToClone)
            .filter(key => propsToInclude.indexOf(key) >= 0)
            .reduce((outObject, key) => (outObject[key] = objectToClone[key], outObject), {});
    }
    static cloneObjectExcludeProps(objectToClone, ...propsToExclude) {
        if (!objectToClone || Array.isArray(objectToClone) || typeof objectToClone != 'object')
            return objectToClone;
        return Object.keys(objectToClone)
            .filter(key => propsToExclude.indexOf(key) < 0)
            .reduce((outObject, key) => (outObject[key] = objectToClone[key], outObject), {});
    }
    static deleteFolderRecursive(pth, throwIOErrors, removeSelfDirectory = true) {
        if (fs.existsSync(pth)) {
            fs.readdirSync(pth).forEach(file => {
                var curPath = path.join(pth, file);
                if (fs.lstatSync(curPath).isDirectory()) {
                    this.deleteFolderRecursive(curPath, throwIOErrors);
                }
                else {
                    try {
                        fs.unlinkSync(curPath);
                    }
                    catch (ex) {
                        if (throwIOErrors) {
                            throw new Error(ex.message);
                        }
                    }
                }
            });
            try {
                if (removeSelfDirectory) {
                    fs.rmdirSync(pth);
                }
            }
            catch (ex) {
                if (throwIOErrors) {
                    throw new Error(ex.message);
                }
            }
        }
    }
    static getFieldName__r(fieldDescribe, fieldName) {
        if (fieldDescribe) {
            let name = fieldDescribe.name.split('.')[0];
            if (fieldDescribe.custom) {
                name = Common.replaceLast(name, "__pc", "__pr");
                name = Common.replaceLast(name, "__c", "__r");
                return name;
            }
            else {
                return Common.trimEndStr(name, "Id");
            }
        }
        else if (fieldName) {
            let name = fieldName.split('.')[0];
            if (!name.endsWith("Id")) {
                name = Common.replaceLast(name, "__pc", "__pr");
                name = Common.replaceLast(name, "__c", "__r");
                return name;
            }
            else {
                return Common.trimEndStr(name, "Id");
            }
        }
        else {
            return "";
        }
    }
    static getFieldNameId(fieldDescribe, fieldName) {
        if (fieldDescribe) {
            let parts = fieldDescribe.name.split('.');
            if (!fieldDescribe.is__r || parts.length < 2) {
                return fieldDescribe.name;
            }
            if (fieldDescribe.custom) {
                let name = Common.replaceLast(parts[0], "__pc", "__pr");
                name = Common.replaceLast(name, "__c", "__r");
                return name;
            }
            else {
                return parts[0] + "Id";
            }
        }
        else if (fieldName) {
            fieldName = fieldName.split('.')[0];
            if (fieldName.endsWith("Id")) {
                return fieldName;
            }
            else if (fieldName.endsWith("__pr") || fieldName.endsWith("__r")) {
                fieldName = Common.replaceLast(fieldName, "__pc", "__pr");
                fieldName = Common.replaceLast(fieldName, "__c", "__r");
                return fieldName;
            }
            else if (!fieldName.endsWith("__pc") && !fieldName.endsWith("__c")
                && !fieldName.endsWith("__s")) {
                return fieldName + "Id";
            }
            else {
                return fieldName;
            }
        }
        else {
            return "";
        }
    }
    static searchClosest(itemToSearchFor, arrayToSearchIn, exactlyCaseInsensitiveMatch = false) {
        if (!itemToSearchFor)
            return itemToSearchFor;
        if (exactlyCaseInsensitiveMatch) {
            return arrayToSearchIn.find(item => item && item.toLowerCase() == itemToSearchFor.toLowerCase());
        }
        return closest(itemToSearchFor, arrayToSearchIn);
    }
    static getObjectProperties(instance, type = "function") {
        let members = [];
        let keys = Reflect.ownKeys(instance.__proto__).filter(name => name != "constructor");
        keys.forEach(member => {
            if (typeof instance[member] == type) {
                members.push(member);
            }
        });
        return members;
    }
    static extractObjectMembers(object, propertiesToExtract) {
        return (function (value) {
            let result = {};
            for (const property of Object.keys(propertiesToExtract)) {
                result[property] = value[property];
            }
            return result;
        })(object);
    }
    static getCSVFilename(rootPath, sObjectName, pattern) {
        let suffix = `${pattern || ''}.csv`;
        if (sObjectName == "User" || sObjectName == "Group") {
            return path.join(rootPath, statics_1.CONSTANTS.USER_AND_GROUP_FILENAME) + suffix;
        }
        else {
            return path.join(rootPath, sObjectName) + suffix;
        }
    }
    static bind(fn, thisArg, ...boundArgs) {
        const func = function (...args) {
            return fn.call(thisArg, ...boundArgs, ...args);
        };
        Object.defineProperties(func, {
            __boundArgs: { value: boundArgs },
            __thisArg: { value: thisArg },
            __boundFunction: { value: fn }
        });
        return func;
    }
    static async parallelTasksAsync(tasks, maxParallelTasks = 5) {
        return await Throttle.all(tasks, {
            maxInProgress: maxParallelTasks
        });
    }
    static async parallelExecAsync(fns, thisArg, maxParallelTasks = 10) {
        thisArg = thisArg || this;
        const queue = fns.map(fn => () => fn.call(thisArg));
        const result = await Common.parallelTasksAsync(queue, maxParallelTasks || statics_1.CONSTANTS.DEFAULT_MAX_PARALLEL_EXEC_TASKS);
        return result;
    }
    static async serialExecAsync(fns, thisArg) {
        thisArg = thisArg || this;
        let result = [];
        const queue = fns.map(fn => async () => fn.bind(thisArg, ...fn.arguments));
        for (let index = 0; index < queue.length; index++) {
            const fn = queue[index];
            result = result.concat(await fn());
        }
        return result;
    }
    static arrayToMapMulti(array, keyProps, keyDelimiter = '|', defaultValue = '', valueProps) {
        let out = new Map();
        array.forEach(item => {
            let key = keyProps.map(keyProp => String(item[keyProp] || defaultValue)).join(keyDelimiter);
            if (!out.has(key)) {
                out.set(key, []);
            }
            if (!valueProps)
                out.get(key).push(item);
            else
                out.get(key).push(valueProps.map(valueProp => String(item[valueProp] || '')));
        });
        return out;
    }
    static arrayToMap(array, keyProps, keyDelimiter = '|', defaultValue = '', valueProps) {
        let out = new Map();
        array.forEach(item => {
            let key = keyProps.map(keyProp => String(item[keyProp] || defaultValue)).join(keyDelimiter);
            if (!valueProps)
                out.set(key, item);
            else
                out.set(key, valueProps.map(valueProp => String(item[valueProp] || '')));
        });
        return out;
    }
    static arrayToPropsArray(array, keyProps, keyDelimiter = '|', defaultValue = '') {
        return array.map(item => {
            let key = keyProps.map(keyProp => String(item[keyProp] || defaultValue)).join(keyDelimiter);
            return key;
        });
    }
    static formatStringObject(inputString, placeholderObject) {
        return inputString.replace(/{(\w+)}/g, (placeholderWithDelimiters, placeholderWithoutDelimiters) => placeholderObject.hasOwnProperty(placeholderWithoutDelimiters) ?
            placeholderObject[placeholderWithoutDelimiters] : placeholderWithDelimiters);
    }
    static formatStringLog(...args) {
        var argum = Array.prototype.slice.call(args);
        var rep = argum.slice(1, argum.length);
        var i = 0;
        var output = argum[0].replace(/%s/g, () => {
            var subst = rep.slice(i, ++i);
            return subst;
        });
        return output;
    }
    static extractDomainFromUrlString(url) {
        if (!url)
            return url;
        const matches = url.match(/^https?\:\/\/([^\/?#]+)(?:[\/?#]|$)/i);
        return matches && matches[1];
    }
    static addOrRemoveQueryFields(query, fieldsToAdd = [], fieldsToRemove = []) {
        let fields = [].concat(query.fields.map(f => {
            let field = f;
            return field.field || field["rawValue"];
        }));
        fieldsToAdd.forEach(field => {
            if (field && fields.indexOf(field) < 0) {
                fields.push(field);
            }
        });
        query.fields = new Array();
        fields.forEach(field => {
            if (field && fieldsToRemove.indexOf(field) < 0) {
                query.fields.push((0, soql_parser_js_1.getComposedField)(field));
            }
        });
    }
    static trimChar(str, charToTrim) {
        while (str.charAt(0) == charToTrim) {
            str = str.substring(1);
        }
        while (str.charAt(str.length - 1) == charToTrim) {
            str = str.substring(0, str.length - 1);
        }
        return str;
    }
    static parseArgv(...argv) {
        argv = argv || [];
        let argvObject = {};
        let index = 0;
        while (index < argv.length) {
            let command = argv[index] || "";
            if (command) {
                if (command.startsWith('-')) {
                    command = Common.trimChar(Common.trimChar(command.trim(), "-"), "\"");
                    let value = argv[index + 1] || "";
                    if (value.startsWith("-")) {
                        value = true;
                    }
                    else {
                        value = value || true;
                        index++;
                    }
                    argvObject[command] = value;
                }
                index++;
            }
        }
        return argvObject;
    }
    static getEnumValues(enumType) {
        const entryNames = Object.keys(enumType).filter(key => !/[0-9]+/.test(key[0]));
        return entryNames.map(name => enumType[name]);
    }
    static async delayAsync(time) {
        return new Promise(resolve => setTimeout(resolve, time));
    }
    static wrapWhereClauseInParenthesis(clause) {
        const clone = JSON.parse(JSON.stringify(clause));
        clone.left.openParen = (clone.left.openParen ?? 0) + 1;
        let current = clone;
        while (current.right) {
            current = current.right;
        }
        current.left.closeParen = (current.left.closeParen || 0) + 1;
        return { beginClause: clone, endClause: current };
    }
    static mergeWhereClauses(where1, where2, operator = 'AND') {
        if (!where1 || !where2)
            return where1 || where2;
        const { beginClause: wrappedWhere1, endClause: endClause1 } = Common.wrapWhereClauseInParenthesis(where1);
        const { beginClause: wrappedWhere2 } = Common.wrapWhereClauseInParenthesis(where2);
        endClause1.operator = operator;
        endClause1.right = wrappedWhere2;
        return wrappedWhere1;
    }
}
exports.Common = Common;
Common.csvReadFileDelimiter = ",";
Common.csvWriteFileDelimiter = ",";
Common.flatMap = (arr, f) => arr.reduce((x, y) => [...x, ...f(y)], []);
//# sourceMappingURL=common.js.map