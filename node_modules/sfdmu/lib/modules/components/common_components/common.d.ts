import * as Throttle from 'promise-parallel-throttle';
import { LiteralType, LogicalOperator, Operator, Query, WhereClause } from 'soql-parser-js';
import { CsvChunks, SFieldDescribe } from '../../models';
import IPluginInfo from '../../models/common_models/IPluginInfo';
import ISfdmuCommand from '../../models/common_models/ISfdxCommand';
import { Logger } from './logger';
export declare class Common {
    static logger: Logger;
    static csvReadFileDelimiter: ',' | ';';
    static csvWriteFileDelimiter: ',' | ';';
    static chunkArray(array: Array<any>, chunkMaxSize: number): Array<Array<any>>;
    static formatDateTimeShort(date: Date, addMilliseconds?: boolean): string;
    static formatFileDate(date: Date): string;
    static getPluginInfo(command: ISfdmuCommand): IPluginInfo;
    static formatDateTime(date: Date, addMilliseconds?: boolean): string;
    static timeDiffString(dateStart: Date, dateEnd: Date): string;
    static getFullCommandLine(): string;
    static convertUTCDateToLocalDate(date: Date): Date;
    static addLeadnigZeros(num: number, size: number): string;
    static transformArrayOfArrays(array: Array<any>): Array<object>;
    static arrayToMapByHashcode(array: Array<object>, propsToExclude?: Array<string>): Map<string, object>;
    static arrayToMapByProperty(array: Array<object>, propertyName: string): Map<string, object>;
    static compareArraysByHashcode(arrayOfKeys: Array<object>, arrayOfValues: Array<object>, propsToExclude?: Array<string>, mkeys?: Map<string, object>, mvalues?: Map<string, object>): Map<object, object>;
    static compareArraysByProperty(arrayOfKeys: Array<object>, arrayOfValues: Array<object>, propertyName: string, mkeys?: Map<string, object>, mvalues?: Map<string, object>): Map<object, object>;
    static getStringHashcode(inputString: string): number;
    static getString32FNV1AHashcode(inputString: string, asString?: boolean, seed?: number): string | number;
    static getObjectHashcode(inputObject: object, propsToExclude?: Array<string>): number;
    static trimEndStr(str: string, toTrim: string): string;
    static replaceLast(original: string, toReplace: string, replacement: string): string;
    static execSfdx(command: String, targetusername: String): string;
    static execSf(command: String, targetusername: String): string;
    static composeWhereClause(where: WhereClause, fieldName: string, values: Array<string> | string, operator?: Operator, literalType?: LiteralType, logicalOperator?: LogicalOperator): WhereClause;
    static distinctArray<T>(array: Array<T>, distinctByProp: string, stringIgnoreCase?: boolean): Array<T>;
    static distinctStringArray(array: string[], stringIgnoreCase?: boolean): Array<string>;
    static removeBy(arr: Array<object>, field: string, value: string): Array<object>;
    static filterMapByArray<T>(keysToFilter: Array<string>, sourceMap: Map<string, T>, defaultValueCallback?: (key: string) => T, addDefaultValueToSourceMapIfNotExist?: boolean): Map<string, T>;
    static isComplexOr__rField(fieldName: string): boolean;
    static isDescriptionPropertyMatching(fieldDescribeProperty: any, patternProperty: any, negative?: boolean): boolean;
    static is__rField(fieldName: string): boolean;
    static isComplexField(fieldName: string): boolean;
    static isContainsComplexField(fieldName: string): boolean;
    static getComplexField(fieldName: string): string;
    static getFieldFromComplexField(fieldName: string): string;
    static readCsvFileAsync(filePath: string, linesAmountToRead?: number, columnToColumnDataTypeMap?: Map<string, string>): Promise<Array<object>>;
    static writeCsvFileAsync(filePath: string, array: Array<object>, createEmptyFileOnEmptyArray?: boolean, columns?: Array<string>): Promise<void>;
    static mergeCsvFilesAsync(source1FilePath: string, source2FilePath: string, targetFilePath: string, deleteSourceFiles: boolean, ...columns: Array<string>): Promise<void>;
    static createCsvStringsFromArray(array: Array<object>, maxCsvStringSizeInBytes: number, blockSize: number, lineDelimiter?: string, encoding?: string): CsvChunks;
    static readCsvFileOnceAsync(csvDataCacheMap: Map<string, Map<string, any>>, fileName: string, indexFieldName?: string, indexValueLength?: number, useRowIndexAutonumber?: boolean, addIndexKeyValues?: boolean): Promise<Map<string, any>>;
    static listDirAsync(fileDirectory: string, fileMask?: string): Promise<Array<string>>;
    static abortWithPrompt(warnMessage: string, showPrompt: boolean, promptMessage: string, errorMessage: string, onBeforeAbortAsync: () => Promise<void>, ...warnTokens: string[]): Promise<void>;
    static makeId(length?: number): string;
    static isCustomObject(objectName: string): boolean;
    static splitMulti(str: string, separators: Array<string>): string[];
    static extractWhereClause(query: string): string;
    static createFieldInQueries(selectFields: Array<string>, fieldName: string, sObjectName: string, valuesIN: Array<string>, whereClause?: string, orderByClause?: string): Array<string>;
    static flatMap: (arr: Array<any>, f: any) => any;
    static flattenArrays(arrays: Array<any>): Array<any>;
    static cloneArrayOfObjects(objects: Array<any>, propsToInclude?: Array<string>): Map<any, any>;
    static cloneObjectIncludeProps(objectToClone: object, ...propsToInclude: string[]): {};
    static cloneObjectExcludeProps(objectToClone: object, ...propsToExclude: string[]): {};
    static deleteFolderRecursive(pth: string, throwIOErrors?: boolean, removeSelfDirectory?: boolean): void;
    static getFieldName__r(fieldDescribe?: SFieldDescribe, fieldName?: string): string;
    static getFieldNameId(fieldDescribe?: SFieldDescribe, fieldName?: string): string;
    static searchClosest(itemToSearchFor: string, arrayToSearchIn: Array<string>, exactlyCaseInsensitiveMatch?: boolean): string;
    static getObjectProperties(instance: any, type?: "function" | "object" | "string"): string[];
    static extractObjectMembers<T>(object: T, propertiesToExtract: Record<keyof T, boolean>): T;
    static getCSVFilename(rootPath: string, sObjectName: string, pattern?: string): string;
    static bind(fn: Function, thisArg: any, ...boundArgs: any[]): (...args: any[]) => any;
    static parallelTasksAsync(tasks: Array<Throttle.Task<any>>, maxParallelTasks?: number): Promise<Array<any>>;
    static parallelExecAsync(fns: Array<(...args: any[]) => Promise<any>>, thisArg?: any, maxParallelTasks?: number): Promise<any[]>;
    static serialExecAsync(fns: Array<(...args: any[]) => Promise<any>>, thisArg?: any): Promise<any[]>;
    static arrayToMapMulti(array: Array<any>, keyProps: Array<string>, keyDelimiter?: string, defaultValue?: string, valueProps?: Array<string>): Map<string, Array<any>>;
    static arrayToMap(array: Array<any>, keyProps: Array<string>, keyDelimiter?: string, defaultValue?: string, valueProps?: Array<string>): Map<string, any>;
    static arrayToPropsArray(array: Array<any>, keyProps: Array<string>, keyDelimiter?: string, defaultValue?: string): Array<string>;
    static formatStringObject(inputString: string, placeholderObject: any): string;
    static formatStringLog(...args: string[]): string;
    static extractDomainFromUrlString(url: string): string;
    static addOrRemoveQueryFields(query: Query, fieldsToAdd?: Array<string>, fieldsToRemove?: Array<string>): void;
    static trimChar(str: string, charToTrim: string): string;
    static parseArgv(...argv: string[]): any;
    static getEnumValues<T>(enumType: T): (T extends {
        [k: string]: infer X;
    } ? Exclude<X, string> : any)[];
    static delayAsync(time: number): Promise<void>;
    private static wrapWhereClauseInParenthesis;
    static mergeWhereClauses(where1?: WhereClause, where2?: WhereClause, operator?: LogicalOperator): WhereClause | undefined;
}
