import { Logger } from "../../../modules/components/common_components/logger";
import { SFDMU_RUN_ADDON_MESSAGES } from "../../messages/sfdmuRunAddonMessages";
import ICommandRunInfo from "../../../modules/models/common_models/ICommandRunInfo";
import { ITableMessage } from "../../../modules/models/common_models/helper_interfaces";
import AddonModule from "./addonModule";
import { BUILTIN_MESSAGES } from "../../../modules/components/common_components/bulitinMessages";
import { ADDON_EVENTS } from "../../../modules/components/common_components/enumerations";
export default class AddonRuntime {
    #private;
    runInfo: ICommandRunInfo;
    constructor(logger: Logger, runInfo: ICommandRunInfo);
    createFormattedMessage(module: AddonModule, message: SFDMU_RUN_ADDON_MESSAGES | BUILTIN_MESSAGES | string, ...tokens: string[]): string;
    logFormattedInfo(module: AddonModule, message: SFDMU_RUN_ADDON_MESSAGES | string, ...tokens: string[]): void;
    logFormattedInfoVerbose(module: AddonModule, message: SFDMU_RUN_ADDON_MESSAGES | string, ...tokens: string[]): void;
    logFormattedWarning(module: AddonModule, message: SFDMU_RUN_ADDON_MESSAGES | string, ...tokens: string[]): void;
    logFormattedError(module: AddonModule, message: SFDMU_RUN_ADDON_MESSAGES | string, ...tokens: string[]): void;
    logFormatted(module: AddonModule, message: BUILTIN_MESSAGES | string, messageType?: "INFO" | "WARNING" | "ERROR", ...tokens: string[]): void;
    log(message: string | object | ITableMessage, messageType?: "INFO" | "WARNING" | "ERROR" | "OBJECT" | "TABLE" | "JSON" | "INFO_VERBOSE", ...tokens: string[]): void;
    logAddonExecutionStarted(module: AddonModule): void;
    validateSupportedEvents(module: AddonModule, supportedEvents: ADDON_EVENTS[]): boolean;
    logAddonExecutionFinished(module: AddonModule): void;
    parallelExecAsync(fns: ((...args: any[]) => Promise<any>)[], thisArg?: any, maxParallelTasks?: number): Promise<any[]>;
    serialExecAsync(fns: ((...args: any[]) => Promise<any>)[], thisArg?: any): Promise<any[]>;
    deleteFolderRecursive(path: string, throwIOErrors?: boolean): void;
    readCsvFileAsync(filePath: string, linesToRead?: number, columnDataTypeMap?: Map<string, string>): Promise<any[]>;
    writeCsvFileAsync(filePath: string, records: any[], createEmptyFileOnEmptyArray?: boolean): Promise<void>;
}
