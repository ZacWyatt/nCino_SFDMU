"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _SfdmuRunAddonRuntime_script, _SfdmuRunAddonRuntime_logger;
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const fs = require("fs");
const bulkApiV1_0Engine_1 = require("../../../modules/components/api_engines/bulkApiV1_0Engine");
const restApiEngine_1 = require("../../../modules/components/api_engines/restApiEngine");
const common_1 = require("../../../modules/components/common_components/common");
const sfdx_1 = require("../../../modules/components/common_components/sfdx");
const statics_1 = require("../../../modules/components/common_components/statics");
const models_1 = require("../../../modules/models");
const sfdmuRunAddonMessages_1 = require("../../messages/sfdmuRunAddonMessages");
const addonRuntime_1 = require("../common/addonRuntime");
const sfdmuRunAddonJob_1 = require("./sfdmuRunAddonJob");
const enumerations_1 = require("../../../modules/components/common_components/enumerations");
const custom_1 = require("./custom");
const bulkApiV2_0Engine_1 = require("../../../modules/components/api_engines/bulkApiV2_0Engine");
class SfdmuRunAddonRuntime extends addonRuntime_1.default {
    constructor(script) {
        super(script.logger, script.runInfo);
        _SfdmuRunAddonRuntime_script.set(this, void 0);
        _SfdmuRunAddonRuntime_logger.set(this, void 0);
        __classPrivateFieldSet(this, _SfdmuRunAddonRuntime_script, script, "f");
        __classPrivateFieldSet(this, _SfdmuRunAddonRuntime_logger, script.logger, "f");
        this.service = new custom_1.SfdmuRunCustomAddonService(this);
    }
    getScript() {
        return __classPrivateFieldGet(this, _SfdmuRunAddonRuntime_script, "f");
    }
    createSfdmuPluginJob() {
        this.pluginJob = new sfdmuRunAddonJob_1.default(__classPrivateFieldGet(this, _SfdmuRunAddonRuntime_script, "f").job);
    }
    getPluginTask(module) {
        return this.pluginJob.tasks.find(task => task.sObjectName == module.context.objectName);
    }
    get basePath() {
        return __classPrivateFieldGet(this, _SfdmuRunAddonRuntime_script, "f").basePath;
    }
    get sourcePath() {
        return __classPrivateFieldGet(this, _SfdmuRunAddonRuntime_script, "f").sourceDirectory;
    }
    get targetPath() {
        return __classPrivateFieldGet(this, _SfdmuRunAddonRuntime_script, "f").targetDirectory;
    }
    getConnection(isSource) {
        return isSource ? __classPrivateFieldGet(this, _SfdmuRunAddonRuntime_script, "f").sourceOrg.getConnection() : __classPrivateFieldGet(this, _SfdmuRunAddonRuntime_script, "f").targetOrg.getConnection();
    }
    getOrgInfo(isSource) {
        return isSource ? Object.assign(__classPrivateFieldGet(this, _SfdmuRunAddonRuntime_script, "f").sourceOrg.connectionData, {
            isFile: __classPrivateFieldGet(this, _SfdmuRunAddonRuntime_script, "f").sourceOrg.media == enumerations_1.DATA_MEDIA_TYPE.File
        }) : Object.assign(__classPrivateFieldGet(this, _SfdmuRunAddonRuntime_script, "f").targetOrg.connectionData, {
            isFile: __classPrivateFieldGet(this, _SfdmuRunAddonRuntime_script, "f").targetOrg.media == enumerations_1.DATA_MEDIA_TYPE.File
        });
    }
    async queryAsync(isSource, soql, useBulkQueryApi = false) {
        let apiSf = new sfdx_1.Sfdx(isSource ? __classPrivateFieldGet(this, _SfdmuRunAddonRuntime_script, "f").sourceOrg : __classPrivateFieldGet(this, _SfdmuRunAddonRuntime_script, "f").targetOrg);
        let ret = await apiSf.queryOrgAsync(soql, useBulkQueryApi, undefined, __classPrivateFieldGet(this, _SfdmuRunAddonRuntime_script, "f").pollingQueryTimeoutMs);
        return ret;
    }
    async queryMultiAsync(isSource, soqls, useBulkQueryApi = false) {
        let records = [];
        for (let index = 0; index < soqls.length; index++) {
            const soql = soqls[index];
            records = records.concat(await this.queryAsync(isSource, soql, useBulkQueryApi));
        }
        return records;
    }
    createFieldInQueries(selectFields, fieldName = "Id", sObjectName, valuesIN, whereClause, orderBy) {
        return common_1.Common.createFieldInQueries(selectFields, fieldName, sObjectName, valuesIN, whereClause, orderBy);
    }
    getApiEngine(recordsAmount, preferredEngine) {
        preferredEngine = preferredEngine || enumerations_1.API_ENGINE.DEFAULT_ENGINE;
        if (preferredEngine != enumerations_1.API_ENGINE.DEFAULT_ENGINE) {
            return preferredEngine;
        }
        if (recordsAmount > __classPrivateFieldGet(this, _SfdmuRunAddonRuntime_script, "f").bulkThreshold) {
            switch (__classPrivateFieldGet(this, _SfdmuRunAddonRuntime_script, "f").bulkApiVersionNumber) {
                case 2:
                    return enumerations_1.API_ENGINE.BULK_API_V2;
                default:
                    return enumerations_1.API_ENGINE.BULK_API_V1;
            }
        }
        return enumerations_1.API_ENGINE.REST_API;
    }
    async updateTargetRecordsAsync(sObjectName, operation, records, engine = enumerations_1.API_ENGINE.DEFAULT_ENGINE, updateRecordId = true) {
        if (!records || records.length == 0 || __classPrivateFieldGet(this, _SfdmuRunAddonRuntime_script, "f").job.tasks.length == 0) {
            return [];
        }
        let resultRecords;
        let task = __classPrivateFieldGet(this, _SfdmuRunAddonRuntime_script, "f").job.tasks.find(task => task.sObjectName == sObjectName);
        if (task) {
            task.createApiEngine(task.targetData.org, operation, records.length, false);
            resultRecords = await task.apiEngine.executeCRUDMultithreaded(records, task.apiProgressCallback, task.getParallelThreadCount());
        }
        else {
            let apiEngine;
            engine = this.getApiEngine(records.length, engine);
            task = __classPrivateFieldGet(this, _SfdmuRunAddonRuntime_script, "f").job.createDummyJobTask(sObjectName);
            switch (engine) {
                case enumerations_1.API_ENGINE.BULK_API_V1:
                    apiEngine = new bulkApiV1_0Engine_1.BulkApiV1_0Engine({
                        logger: __classPrivateFieldGet(this, _SfdmuRunAddonRuntime_logger, "f"),
                        connectionData: __classPrivateFieldGet(this, _SfdmuRunAddonRuntime_script, "f").targetOrg.connectionData,
                        sObjectName,
                        operation,
                        pollingIntervalMs: __classPrivateFieldGet(this, _SfdmuRunAddonRuntime_script, "f").pollingIntervalMs,
                        concurrencyMode: __classPrivateFieldGet(this, _SfdmuRunAddonRuntime_script, "f").concurrencyMode,
                        updateRecordId,
                        bulkApiV1BatchSize: task.scriptObject.batchSizes.bulkV1BatchSize,
                        targetCSVFullFilename: models_1.TaskData.getTargetCSVFilename(__classPrivateFieldGet(this, _SfdmuRunAddonRuntime_script, "f").targetDirectory, sObjectName, operation),
                        createTargetCSVFiles: __classPrivateFieldGet(this, _SfdmuRunAddonRuntime_script, "f").createTargetCSVFiles,
                        targetFieldMapping: null
                    });
                    break;
                case enumerations_1.API_ENGINE.BULK_API_V2:
                    apiEngine = new bulkApiV2_0Engine_1.BulkApiV2_0Engine({
                        logger: __classPrivateFieldGet(this, _SfdmuRunAddonRuntime_logger, "f"),
                        connectionData: __classPrivateFieldGet(this, _SfdmuRunAddonRuntime_script, "f").targetOrg.connectionData,
                        sObjectName,
                        operation,
                        pollingIntervalMs: __classPrivateFieldGet(this, _SfdmuRunAddonRuntime_script, "f").pollingIntervalMs,
                        concurrencyMode: __classPrivateFieldGet(this, _SfdmuRunAddonRuntime_script, "f").concurrencyMode,
                        updateRecordId,
                        targetCSVFullFilename: models_1.TaskData.getTargetCSVFilename(__classPrivateFieldGet(this, _SfdmuRunAddonRuntime_script, "f").targetDirectory, sObjectName, operation),
                        createTargetCSVFiles: __classPrivateFieldGet(this, _SfdmuRunAddonRuntime_script, "f").createTargetCSVFiles,
                        targetFieldMapping: null
                    });
                    break;
                default:
                    apiEngine = new restApiEngine_1.RestApiEngine({
                        logger: __classPrivateFieldGet(this, _SfdmuRunAddonRuntime_logger, "f"),
                        connectionData: __classPrivateFieldGet(this, _SfdmuRunAddonRuntime_script, "f").targetOrg.connectionData,
                        sObjectName,
                        operation,
                        pollingIntervalMs: __classPrivateFieldGet(this, _SfdmuRunAddonRuntime_script, "f").pollingIntervalMs,
                        concurrencyMode: __classPrivateFieldGet(this, _SfdmuRunAddonRuntime_script, "f").concurrencyMode,
                        updateRecordId,
                        targetCSVFullFilename: models_1.TaskData.getTargetCSVFilename(__classPrivateFieldGet(this, _SfdmuRunAddonRuntime_script, "f").targetDirectory, sObjectName, operation),
                        createTargetCSVFiles: __classPrivateFieldGet(this, _SfdmuRunAddonRuntime_script, "f").createTargetCSVFiles,
                        targetFieldMapping: null,
                        restApiBatchSize: task.scriptObject.batchSizes.restBatchSize,
                        binaryDataCache: __classPrivateFieldGet(this, _SfdmuRunAddonRuntime_script, "f").binaryDataCache,
                        binaryCacheDirectory: __classPrivateFieldGet(this, _SfdmuRunAddonRuntime_script, "f").binaryCacheDirectory
                    });
                    break;
            }
            task.setApiEngine(apiEngine);
            resultRecords = await apiEngine.executeCRUDMultithreaded(records, task.apiProgressCallback, task.getParallelThreadCount());
        }
        return resultRecords;
    }
    async downloadBlobDataAsync(isSource, recordIds, blobField) {
        let apiSf = new sfdx_1.Sfdx(isSource ? __classPrivateFieldGet(this, _SfdmuRunAddonRuntime_script, "f").sourceOrg : __classPrivateFieldGet(this, _SfdmuRunAddonRuntime_script, "f").targetOrg);
        return await apiSf.downloadBlobFieldDataAsync(recordIds, blobField);
    }
    async transferContentVersions(module, sourceVersions, maxChunkSize) {
        let _self = this;
        maxChunkSize = maxChunkSize || statics_1.CONSTANTS.DEFAULT_MAX_CHUNK_SIZE;
        let urlUploadJobs = new Array();
        let totalSize = 0;
        let totalCount = 0;
        let totalUrls = 0;
        let fileUploadJobs = [...(function* () {
                let versions = new Array();
                let size = 0;
                for (let index = 0; index < sourceVersions.length; index++) {
                    const version = sourceVersions[index];
                    if (version.isUrlContent) {
                        totalUrls++;
                        urlUploadJobs.push(version);
                        continue;
                    }
                    versions.push(version);
                    totalCount++;
                    size += version.ContentSize;
                    totalSize += version.ContentSize;
                    if (version.ContentSize + size > maxChunkSize) {
                        yield versions;
                        size = 0;
                        versions = new Array();
                    }
                }
                ;
                if (versions.length > 0) {
                    yield versions;
                }
            })()];
        if (fileUploadJobs.length > 0) {
            this.logFormattedInfo(module, sfdmuRunAddonMessages_1.SFDMU_RUN_ADDON_MESSAGES.ExportFiles_TotalDataVolume, String(totalCount + totalUrls), String((totalSize / 1000000).toFixed(2)));
            this.logFormattedInfo(module, sfdmuRunAddonMessages_1.SFDMU_RUN_ADDON_MESSAGES.ExportFiles_DataWillBeProcessedInChunksOfSize, String(fileUploadJobs.length), String((maxChunkSize / 1000000).toFixed(2)));
        }
        for (let index = 0; index < fileUploadJobs.length; index++) {
            const fileJob = fileUploadJobs[index];
            let idToContentVersionMap = common_1.Common.arrayToMap(fileJob, ['Id']);
            this.logFormattedInfo(module, sfdmuRunAddonMessages_1.SFDMU_RUN_ADDON_MESSAGES.ExportFiles_ProcessingChunk, String(index + 1), String(idToContentVersionMap.size));
            let idToContentVersionBlobMap = await this.downloadBlobDataAsync(true, [...idToContentVersionMap.keys()], {
                fieldName: 'VersionData',
                objectName: 'ContentVersion',
                dataType: "base64"
            });
            let newToSourceVersionMap = new Map();
            let versionsToUpload = [...idToContentVersionBlobMap.keys()].map(versionId => {
                let blobData = idToContentVersionBlobMap.get(versionId);
                let sourceContentVersion = idToContentVersionMap.get(versionId);
                let newContentVersion = common_1.Common.cloneObjectIncludeProps(sourceContentVersion, 'Title', 'Description', 'PathOnClient');
                newContentVersion['VersionData'] = blobData;
                newContentVersion['ReasonForChange'] = sourceContentVersion.reasonForChange;
                newContentVersion['ContentDocumentId'] = sourceContentVersion.targetContentDocumentId;
                newToSourceVersionMap.set(newContentVersion, sourceContentVersion);
                return newContentVersion;
            });
            await ___upload(versionsToUpload, newToSourceVersionMap, false);
        }
        {
            let newToSourceVersionMap = new Map();
            let versionsToUpload = urlUploadJobs.map(sourceContentVersion => {
                let newContentVersion = common_1.Common.cloneObjectIncludeProps(sourceContentVersion, 'Title', 'Description', 'ContentUrl');
                newContentVersion['ReasonForChange'] = sourceContentVersion.reasonForChange;
                newContentVersion['ContentDocumentId'] = sourceContentVersion.targetContentDocumentId;
                newToSourceVersionMap.set(newContentVersion, sourceContentVersion);
                return newContentVersion;
            });
            await ___upload(versionsToUpload, newToSourceVersionMap, true);
        }
        async function ___upload(versionsToUpload, newToSourceVersionMap, isUrl) {
            let records = await _self.updateTargetRecordsAsync('ContentVersion', enumerations_1.OPERATION.Insert, versionsToUpload, isUrl ? enumerations_1.API_ENGINE.DEFAULT_ENGINE : enumerations_1.API_ENGINE.REST_API, true);
            if (records) {
                let newRecordIdToSourceVersionMap = new Map();
                records.forEach((newRecord) => {
                    let sourceVersion = newToSourceVersionMap.get(newRecord);
                    if (sourceVersion) {
                        sourceVersion.targetId = newRecord["Id"];
                        if (newRecord[statics_1.CONSTANTS.ERRORS_FIELD_NAME]) {
                            sourceVersion.isError = true;
                        }
                        if (!sourceVersion.targetContentDocumentId) {
                            newRecordIdToSourceVersionMap.set(sourceVersion.targetId, sourceVersion);
                        }
                    }
                });
                let queries = _self.createFieldInQueries(['Id', 'ContentDocumentId'], 'Id', 'ContentVersion', [...newRecordIdToSourceVersionMap.keys()]);
                records = await _self.queryMultiAsync(false, queries);
                records.forEach((newRecord) => {
                    let sourceVersion = newRecordIdToSourceVersionMap.get(newRecord["Id"]);
                    if (sourceVersion) {
                        sourceVersion.targetContentDocumentId = newRecord['ContentDocumentId'];
                        if (newRecord[statics_1.CONSTANTS.ERRORS_FIELD_NAME]) {
                            sourceVersion.isError = true;
                        }
                    }
                });
            }
            else {
                versionsToUpload.forEach(uploadVersion => newToSourceVersionMap.get(uploadVersion).isError = true);
            }
        }
        ;
        return sourceVersions;
    }
    getOrCreateTempPath(module) {
        let tmp = path.normalize(this.basePath
            + '/'
            + common_1.Common.formatStringLog(statics_1.CONSTANTS.ADDON_TEMP_RELATIVE_FOLDER, module.context.moduleDisplayName.replace(/[^\w\d]/g, '-')) + '/');
        if (!fs.existsSync(tmp)) {
            fs.mkdirSync(tmp);
        }
        return tmp;
    }
    destroyTempPath(module, removeParentFolder) {
        if (typeof removeParentFolder == 'undefined')
            removeParentFolder = false;
        let tmp = this.getOrCreateTempPath(module);
        common_1.Common.deleteFolderRecursive(tmp, false, removeParentFolder);
    }
}
_SfdmuRunAddonRuntime_script = new WeakMap(), _SfdmuRunAddonRuntime_logger = new WeakMap();
exports.default = SfdmuRunAddonRuntime;
//# sourceMappingURL=sfdmuRunAddonRuntime.js.map