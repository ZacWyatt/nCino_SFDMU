"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const sfdmuRunAddonModule_1 = require("../../../components/sfdmu-run/sfdmuRunAddonModule");
const enumerations_1 = require("../../../../modules/components/common_components/enumerations");
const sfdmuRunAddonMessages_1 = require("../../../messages/sfdmuRunAddonMessages");
const soql_parser_js_1 = require("soql-parser-js");
const common_1 = require("../../../../modules/components/common_components/common");
const package_1 = require("../custom-addons/package");
const CONST = {
    SUPPORTED_EVENTS: [
        enumerations_1.ADDON_EVENTS.onDataRetrieved,
        enumerations_1.ADDON_EVENTS.onBeforeUpdate
    ]
};
class RecordsTransform extends sfdmuRunAddonModule_1.default {
    async onInit(context, args) {
        let script = this.runtime.getScript();
        let objects = script.objects.map(object => {
            return {
                object,
                parsedQuery: (0, soql_parser_js_1.parseQuery)(object.query)
            };
        });
        args.fields.forEach(field => {
            let object = objects.find(ob => ob.parsedQuery.sObject == field.sourceObject);
            if (!object) {
                object = __addScriptObject(script, {
                    objectName: field.sourceObject,
                    operation: package_1.OPERATION.Readonly
                });
                objects.push(object);
            }
            common_1.Common.addOrRemoveQueryFields(object.parsedQuery, [field.sourceField]);
            const includeFields = field.includeFields || field.includeLookupFields;
            if (includeFields) {
                includeFields.forEach(field => {
                    if (field) {
                        let parts = field.split('.');
                        if (parts.length == 1) {
                            common_1.Common.addOrRemoveQueryFields(object.parsedQuery, [field]);
                        }
                        else {
                            let obj = objects.find(ob => ob.parsedQuery.sObject == parts[0]);
                            if (!obj) {
                                obj = __addScriptObject(script, {
                                    objectName: parts[0],
                                    operation: package_1.OPERATION.Readonly
                                });
                                objects.push(obj);
                            }
                            common_1.Common.addOrRemoveQueryFields(obj.parsedQuery, [parts.splice(1).join('.')]);
                        }
                    }
                });
            }
        });
        args.transformations.forEach(transformation => {
            let object = objects.find(ob => ob.parsedQuery.sObject == transformation.targetObject);
            if (!object) {
                object = __addScriptObject(script, {
                    objectName: transformation.targetObject,
                    operation: package_1.OPERATION.Readonly
                });
                objects.push(object);
            }
            common_1.Common.addOrRemoveQueryFields(object.parsedQuery, [transformation.targetField]);
            if (transformation.includeLookupFields) {
                transformation.includeLookupFields.forEach(field => {
                    if (field) {
                        let parts = field.split('.');
                        if (parts.length == 1) {
                            common_1.Common.addOrRemoveQueryFields(object.parsedQuery, [field]);
                        }
                        else {
                            let obj = objects.find(ob => ob.parsedQuery.sObject == parts[0]);
                            if (!obj) {
                                obj = __addScriptObject(script, {
                                    objectName: parts[0],
                                    operation: package_1.OPERATION.Readonly
                                });
                                objects.push(obj);
                            }
                            common_1.Common.addOrRemoveQueryFields(obj.parsedQuery, [parts[1]]);
                        }
                    }
                });
            }
            let scriptObject = script.objects.find(object => object.name == transformation.targetObject);
            if (scriptObject) {
                if (scriptObject.extraFieldsToUpdate.indexOf(transformation.targetField) < 0) {
                    scriptObject.extraFieldsToUpdate = scriptObject.extraFieldsToUpdate.concat(transformation.targetField);
                }
            }
        });
        objects.forEach(object => {
            object.object.query = (0, soql_parser_js_1.composeQuery)(object.parsedQuery);
        });
        return null;
        function __addScriptObject(script, object) {
            let newObject = script.addScriptObject({
                objectName: object.objectName,
                operation: package_1.OPERATION.Readonly
            });
            return {
                object: newObject,
                parsedQuery: (0, soql_parser_js_1.parseQuery)(newObject.query)
            };
        }
    }
    async onExecute(context, args) {
        const self = this;
        this.runtime.logAddonExecutionStarted(this);
        if (!this.runtime.validateSupportedEvents(this, CONST.SUPPORTED_EVENTS)) {
            this.runtime.logFormattedWarning(this, sfdmuRunAddonMessages_1.SFDMU_RUN_ADDON_MESSAGES.General_EventNotSupported, context.eventName, context.moduleDisplayName, CONST.SUPPORTED_EVENTS.join());
            return null;
        }
        const job = this.runtime.pluginJob;
        const fieldsMap = new Map();
        const transformsMap = new Map();
        this.runtime.logFormattedInfo(this, sfdmuRunAddonMessages_1.SFDMU_RUN_ADDON_MESSAGES.General_CheckingArgs);
        if (!args) {
            this.runtime.logFormattedWarning(this, sfdmuRunAddonMessages_1.SFDMU_RUN_ADDON_MESSAGES.General_ArgumentsCannotBeParsed);
            return null;
        }
        this.runtime.logFormattedInfo(this, sfdmuRunAddonMessages_1.SFDMU_RUN_ADDON_MESSAGES.RecordsTransform_CreatingMappingScheme);
        try {
            args.fields.forEach(field => {
                let task = job.tasks.find(task => task.sObjectName == field.sourceObject);
                if (!task) {
                    this.runtime.logFormattedInfo(this, sfdmuRunAddonMessages_1.SFDMU_RUN_ADDON_MESSAGES.RecordsTransform_SourceTaskNotFound, field.sourceField, field.sourceObject);
                }
                else {
                    if (task.sourceTaskData.records.length
                        && !task.sourceTaskData.records[0].hasOwnProperty(field.sourceField)) {
                        this.runtime.logFormattedInfo(this, sfdmuRunAddonMessages_1.SFDMU_RUN_ADDON_MESSAGES.RecordsTransform_SourceFieldNotFound, field.sourceField, field.sourceObject);
                    }
                    else {
                        if (task.fieldsInQuery.indexOf(field.sourceField) < 0) {
                            this.runtime.logFormattedInfo(this, sfdmuRunAddonMessages_1.SFDMU_RUN_ADDON_MESSAGES.RecordsTransform_SourceFieldNotFound, field.sourceField, field.sourceObject);
                        }
                        else {
                            fieldsMap.set(field.alias, Object.assign(field, {
                                sourceTask: task,
                                lookupFieldMap: __getLookups(task.fieldsInQueryMap),
                                targetToSourceRecordMap: new Map()
                            }));
                        }
                        task.sourceToTargetRecordMap.forEach((targetRecord, sourceRecord) => {
                            fieldsMap.get(field.alias).targetToSourceRecordMap.set(targetRecord, sourceRecord);
                        });
                    }
                }
            });
            args.transformations.forEach(transformation => {
                let task = job.tasks.find(task => task.sObjectName == transformation.targetObject);
                if (!task) {
                    this.runtime.logFormattedInfo(this, sfdmuRunAddonMessages_1.SFDMU_RUN_ADDON_MESSAGES.RecordsTransform_TargetFieldNotFound, transformation.targetField, transformation.targetObject);
                }
                else {
                    transformsMap.set(transformation.targetField, Object.assign(transformation, {
                        targetTask: task,
                        lookupFieldMap: __getLookups(task.fieldsInQueryMap)
                    }));
                }
            });
            this.runtime.logFormattedInfo(this, sfdmuRunAddonMessages_1.SFDMU_RUN_ADDON_MESSAGES.RecordsTransform_Tranforming);
            let totallyTransformed = 0;
            transformsMap.forEach((transformation) => {
                let transformedRecords = ___getTaskRecords(transformation.targetTask);
                totallyTransformed += transformedRecords.length;
                transformedRecords.forEach(transformedRecord => {
                    let formula = {};
                    let transformationSourceRecord = transformation.targetTask.sourceTaskData.idRecordsMap.get(transformedRecord["___Id"]);
                    let tranformationTargetRecord = transformation.targetTask.sourceToTargetRecordMap.get(transformationSourceRecord);
                    fieldsMap.forEach((field) => {
                        let sourceRecords = field.sourceTask.sourceTaskData.records;
                        let targetRecords = field.sourceTask.targetTaskData.records;
                        let sourceRecord = field.sourceTask.sourceTaskData.idRecordsMap.get(transformedRecord["___Id"]);
                        if (transformation.targetObject == field.sourceObject || !!field.lookupExpression) {
                            let targetRecord = field.sourceTask.sourceToTargetRecordMap.get(sourceRecord);
                            const tempSourceRecord = field.valueSource != 'target' ? sourceRecord : targetRecord;
                            __setFormulaValue(formula, tempSourceRecord, transformedRecord, field, sourceRecords, targetRecords);
                        }
                        else {
                            let sourceIdFields = transformation.lookupFieldMap.get(field.sourceObject);
                            if (sourceIdFields) {
                                sourceIdFields.forEach(sourceIdField => {
                                    let targetId = transformedRecord[sourceIdField];
                                    let targetRecord = field.sourceTask.targetTaskData.idRecordsMap.get(targetId);
                                    sourceRecord = field.targetToSourceRecordMap.get(targetRecord);
                                    const tempSourceRecord = field.valueSource != 'target' ? sourceRecord : targetRecord;
                                    __setFormulaValue(formula, tempSourceRecord, transformedRecord, field, sourceRecords, targetRecords);
                                });
                            }
                            else {
                                let targetIdFields = field.lookupFieldMap.get(transformation.targetObject);
                                if (targetIdFields) {
                                    let targetId = tranformationTargetRecord["Id"];
                                    if (targetId) {
                                        for (let index = 0; index < targetRecords.length; index++) {
                                            let targetRecord = targetRecords[index];
                                            if (Object.keys(targetRecord).some(fieldName => {
                                                return sourceRecord[fieldName] == targetId;
                                            })) {
                                                sourceRecord = field.targetToSourceRecordMap.get(targetRecord);
                                                const tempSourceRecord = field.valueSource != 'target' ? sourceRecord : targetRecord;
                                                __setFormulaValue(formula, tempSourceRecord, transformedRecord, field, sourceRecords, targetRecords);
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        formula[field.alias] = formula[field.alias] || null;
                    });
                    if (transformation.expressions) {
                        transformation.expressions.forEach(expression => eval(expression));
                    }
                    transformedRecord[transformation.targetField] = eval(transformation.formula);
                });
            });
            this.runtime.logFormattedInfo(this, sfdmuRunAddonMessages_1.SFDMU_RUN_ADDON_MESSAGES.RecordsTransform_TotallyTranformed, String(totallyTransformed));
        }
        catch (e) {
            this.runtime.logFormattedWarning(this, sfdmuRunAddonMessages_1.SFDMU_RUN_ADDON_MESSAGES.General_AddOnRuntimeError, context.moduleDisplayName);
            return null;
        }
        this.runtime.logAddonExecutionFinished(this);
        return null;
        function __getLookups(fieldsInQueryMap) {
            const m = new Map();
            fieldsInQueryMap.forEach(field => {
                if (field.referencedObjectType) {
                    m.set(field.referencedObjectType, (m.get(field.referencedObjectType) || []).concat(field.name));
                }
            });
            return m;
        }
        function __setFormulaValue(formula, source, target, field, sourceRecords, targetRecords) {
            source = source || {};
            target = target || {};
            if (field.isConstant && field.constantValue) {
                formula[field.alias] = field.constantValue;
                return;
            }
            let value;
            if (!field.lookupExpression) {
                value = source[field.sourceField];
            }
            else {
                const updateWithRecord = field.lookupSource != 'target'
                    ? sourceRecords.find(source => eval(field.lookupExpression))
                    : targetRecords.find(source => eval(field.lookupExpression));
                value = updateWithRecord && updateWithRecord[field.sourceField];
            }
            formula[field.alias] = field.constantValue = value;
        }
        function ___getTaskRecords(task) {
            return self.context.eventName == enumerations_1.ADDON_EVENTS.onBeforeUpdate
                ? task.processedData.recordsToInsert.concat(task.processedData.recordsToUpdate) : task.sourceTaskData.records;
        }
    }
}
exports.default = RecordsTransform;
//# sourceMappingURL=index.js.map