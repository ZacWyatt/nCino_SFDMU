"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const common_1 = require("../../../../modules/components/common_components/common");
const statics_1 = require("../../../../modules/components/common_components/statics");
const sfdmuRunAddonMessages_1 = require("../../../messages/sfdmuRunAddonMessages");
const enumerations_1 = require("../../../../modules/components/common_components/enumerations");
const contentVersion_1 = require("../../../../modules/models/sf_models/contentVersion");
const sfdmuRunAddonModule_1 = require("../../../components/sfdmu-run/sfdmuRunAddonModule");
const soql_parser_js_1 = require("soql-parser-js");
class ExportFiles extends sfdmuRunAddonModule_1.default {
    async onInit(context, args) {
        let script = this.runtime.getScript();
        let object = script.objects.find(ob => ob.name == context.objectName);
        switch (context.objectName) {
            case 'FeedItem':
                const parsedQuery = (0, soql_parser_js_1.parseQuery)(object.query);
                common_1.Common.addOrRemoveQueryFields(parsedQuery, ['Type']);
                object.query = (0, soql_parser_js_1.composeQuery)(parsedQuery);
                break;
            default:
                break;
        }
        return null;
    }
    async onExecute(context, args) {
        const _self = this;
        this.runtime.logAddonExecutionStarted(this);
        this.runtime.logFormattedInfo(this, sfdmuRunAddonMessages_1.SFDMU_RUN_ADDON_MESSAGES.ExportFiles_Initializing);
        if (this.runtime.getOrgInfo(false).isFile || this.runtime.getOrgInfo(true).isFile) {
            this.runtime.logFormattedWarning(this, sfdmuRunAddonMessages_1.SFDMU_RUN_ADDON_MESSAGES.ExportFiles_TargetIsFileWarning);
            this.runtime.logAddonExecutionFinished(this);
            return;
        }
        args.maxFileSize = args.maxFileSize || statics_1.CONSTANTS.DEFAULT_MAX_FILE_SIZE;
        if (args.maxFileSize > statics_1.CONSTANTS.MAX_FILE_SIZE) {
            args.maxFileSize = statics_1.CONSTANTS.MAX_FILE_SIZE;
        }
        args.maxChunkSize = args.maxChunkSize || statics_1.CONSTANTS.DEFAULT_MAX_CHUNK_SIZE;
        if (args.maxChunkSize > statics_1.CONSTANTS.MAX_CHUNK_SIZE) {
            args.maxChunkSize = statics_1.CONSTANTS.MAX_CHUNK_SIZE;
        }
        let task = this.runtime.pluginJob.tasks.find(task => task.sObjectName == context.objectName);
        args.operation = !args.operation ? task.operation : enumerations_1.OPERATION[args.operation.toString()];
        args.externalId = args.externalId || 'Title';
        if (!task) {
            this.runtime.logFormattedWarning(this, sfdmuRunAddonMessages_1.SFDMU_RUN_ADDON_MESSAGES.ExportFiles_CouldNotFindObjectToProcessWarning);
            this.runtime.logAddonExecutionFinished(this);
            return;
        }
        if (args.operation == enumerations_1.OPERATION.Readonly) {
            this.runtime.logFormattedWarning(this, sfdmuRunAddonMessages_1.SFDMU_RUN_ADDON_MESSAGES.ExportFiles_ReadonlyOperationWarning);
            this.runtime.logAddonExecutionFinished(this);
            return;
        }
        let sourceFiles = {
            recIdToDocLinks: new Map(),
            docIds: [],
            recordIds: ___filterRecords(task.sourceTaskData.idRecordsMap),
            docIdToDocVersion: new Map()
        };
        let targetFiles = {
            recIdToDocLinks: new Map(),
            docIds: [],
            recordIds: ___filterRecords(task.targetTaskData.idRecordsMap),
            docIdToDocVersion: new Map()
        };
        let exportedFilesMap = new Map();
        let isDeleted = false;
        switch (task.sObjectName) {
            case 'FeedItem':
                await ___readFeedAttachmentSourceRecordsAsync();
                break;
            default:
                await ___readFileSourceRecordsAsync();
                break;
        }
        let versionsToProcess = [...exportedFilesMap.values()].filter(exportItem => exportItem.isVersionChanged).map(exportItem => exportItem.version);
        if (versionsToProcess.length > 0) {
            this.runtime.logFormattedInfo(this, sfdmuRunAddonMessages_1.SFDMU_RUN_ADDON_MESSAGES.ExportFiles_ExportingContentVersions);
            this.runtime.logFormattedInfo(this, sfdmuRunAddonMessages_1.SFDMU_RUN_ADDON_MESSAGES.ExportFiles_RecordsToBeProcessed, String(versionsToProcess.length));
            await this.runtime.transferContentVersions(this, versionsToProcess, args.maxChunkSize);
            const failedRecordsCount = versionsToProcess.filter(item => item.isError).length;
            this.runtime.logFormattedInfo(this, sfdmuRunAddonMessages_1.SFDMU_RUN_ADDON_MESSAGES.ExportFiles_ProcessedRecords, String(versionsToProcess.length), String(failedRecordsCount));
            if (failedRecordsCount == versionsToProcess.length) {
                exportedFilesMap.clear();
                versionsToProcess = [];
            }
        }
        let exportedFiles = [...exportedFilesMap.values()].filter(exportedFile => exportedFile.recordsToBeLinked.length > 0);
        switch (task.sObjectName) {
            case 'FeedItem':
                await __writeFeedAttachmentTargetRecordsAsync();
                break;
            default:
                await __writeFileTargetRecordsAsync();
                break;
        }
        if (exportedFiles.length == 0 && versionsToProcess.length == 0) {
            this.runtime.logFormattedInfo(this, sfdmuRunAddonMessages_1.SFDMU_RUN_ADDON_MESSAGES.ExportFiles_NothingToProceed);
        }
        this.runtime.logAddonExecutionFinished(this);
        async function ___readFileSourceRecordsAsync() {
            if ((args.operation != enumerations_1.OPERATION.Insert || args.deleteOldData) && targetFiles.recordIds.length > 0) {
                _self.runtime.logFormattedInfo(_self, sfdmuRunAddonMessages_1.SFDMU_RUN_ADDON_MESSAGES.ExportFiles_ReadTargetContentDocumentLinks);
                let queries = _self.runtime.createFieldInQueries(['Id', 'LinkedEntityId', 'ContentDocumentId', 'ShareType', 'Visibility'], 'LinkedEntityId', 'ContentDocumentLink', targetFiles.recordIds);
                let contentDocLinks = await _self.runtime.queryMultiAsync(false, queries);
                targetFiles.recIdToDocLinks = common_1.Common.arrayToMapMulti(contentDocLinks, ['LinkedEntityId']);
                targetFiles.docIds = common_1.Common.distinctStringArray(common_1.Common.arrayToPropsArray(contentDocLinks, ['ContentDocumentId']));
                _self.runtime.logFormattedInfo(_self, sfdmuRunAddonMessages_1.SFDMU_RUN_ADDON_MESSAGES.ExportFiles_RetrievedRecords, String(contentDocLinks.length));
            }
            await __readTargetContentVersionsAsync();
            if (await ___deleteTargetFilesAsync(targetFiles.docIds)) {
                return;
            }
            if (sourceFiles.recordIds.length == 0) {
                _self.runtime.logFormattedInfo(_self, sfdmuRunAddonMessages_1.SFDMU_RUN_ADDON_MESSAGES.ExportFiles_NoSourceRecords);
                return;
            }
            if (args.operation == enumerations_1.OPERATION.Update && isDeleted) {
                _self.runtime.logFormattedInfo(_self, sfdmuRunAddonMessages_1.SFDMU_RUN_ADDON_MESSAGES.ExportFiles_NothingToUpdate);
                return;
            }
            if (args.operation == enumerations_1.OPERATION.Upsert && isDeleted) {
                args.operation = enumerations_1.OPERATION.Insert;
            }
            {
                _self.runtime.logFormattedInfo(_self, sfdmuRunAddonMessages_1.SFDMU_RUN_ADDON_MESSAGES.ExportFiles_ReadSourceContentDocumentLinks);
                let queries = _self.runtime.createFieldInQueries(['Id', 'LinkedEntityId', 'ContentDocumentId', 'ShareType', 'Visibility'], 'LinkedEntityId', 'ContentDocumentLink', [...task.sourceTaskData.idRecordsMap.keys()], '', args.contentDocumentLinkOrderBy);
                let contentDocLinks = await _self.runtime.queryMultiAsync(true, queries);
                sourceFiles.recIdToDocLinks = common_1.Common.arrayToMapMulti(contentDocLinks, ['LinkedEntityId']);
                sourceFiles.docIds = common_1.Common.distinctStringArray(common_1.Common.arrayToPropsArray(contentDocLinks, ['ContentDocumentId']));
                _self.runtime.logFormattedInfo(_self, sfdmuRunAddonMessages_1.SFDMU_RUN_ADDON_MESSAGES.ExportFiles_RetrievedRecords, String(contentDocLinks.length));
            }
            await ___readSourceContentVersionsAsync();
            _self.runtime.logFormattedInfo(_self, sfdmuRunAddonMessages_1.SFDMU_RUN_ADDON_MESSAGES.ExportFiles_Comparing);
            await __compareContentVersionsAsync();
        }
        async function ___readFeedAttachmentSourceRecordsAsync() {
            if ((args.operation != enumerations_1.OPERATION.Insert || args.deleteOldData) && targetFiles.recordIds.length > 0) {
                _self.runtime.logFormattedInfo(_self, sfdmuRunAddonMessages_1.SFDMU_RUN_ADDON_MESSAGES.ExportFiles_ReadTargetFeedAttachments);
                let queries = _self.runtime.createFieldInQueries(['Id', 'RecordId', 'FeedEntityId'], 'FeedEntityId', 'FeedAttachment', targetFiles.recordIds, "Type = 'Content'");
                let contentDocLinks = await _self.runtime.queryMultiAsync(false, queries);
                targetFiles.recIdToDocLinks = common_1.Common.arrayToMapMulti(contentDocLinks, ['FeedEntityId']);
                targetFiles.docIds = common_1.Common.distinctStringArray(common_1.Common.arrayToPropsArray(contentDocLinks, ['RecordId']));
                _self.runtime.logFormattedInfo(_self, sfdmuRunAddonMessages_1.SFDMU_RUN_ADDON_MESSAGES.ExportFiles_RetrievedRecords, String(contentDocLinks.length));
            }
            await __readTargetContentVersionsAsync('Id');
            if (await ___deleteTargetFilesAsync(targetFiles.docIds)) {
                return;
            }
            if (sourceFiles.recordIds.length == 0) {
                _self.runtime.logFormattedInfo(_self, sfdmuRunAddonMessages_1.SFDMU_RUN_ADDON_MESSAGES.ExportFiles_NoSourceRecords);
                return;
            }
            if (args.operation == enumerations_1.OPERATION.Update && isDeleted) {
                _self.runtime.logFormattedInfo(_self, sfdmuRunAddonMessages_1.SFDMU_RUN_ADDON_MESSAGES.ExportFiles_NothingToUpdate);
                return;
            }
            if (args.operation == enumerations_1.OPERATION.Upsert && isDeleted) {
                args.operation = enumerations_1.OPERATION.Insert;
            }
            {
                _self.runtime.logFormattedInfo(_self, sfdmuRunAddonMessages_1.SFDMU_RUN_ADDON_MESSAGES.ExportFiles_ReadSourceFeedAttachments);
                let queries = _self.runtime.createFieldInQueries(['Id', 'RecordId', 'FeedEntityId'], 'FeedEntityId', 'FeedAttachment', sourceFiles.recordIds, "Type = 'Content'");
                let feedAttachments = await _self.runtime.queryMultiAsync(true, queries);
                sourceFiles.recIdToDocLinks = common_1.Common.arrayToMapMulti(feedAttachments, ['FeedEntityId']);
                sourceFiles.docIds = common_1.Common.distinctStringArray(common_1.Common.arrayToPropsArray(feedAttachments, ['RecordId']));
                _self.runtime.logFormattedInfo(_self, sfdmuRunAddonMessages_1.SFDMU_RUN_ADDON_MESSAGES.ExportFiles_RetrievedRecords, String(feedAttachments.length));
            }
            await ___readSourceContentVersionsAsync('Id');
            _self.runtime.logFormattedInfo(_self, sfdmuRunAddonMessages_1.SFDMU_RUN_ADDON_MESSAGES.ExportFiles_Comparing);
            await __compareContentVersionsAsync('RecordId');
        }
        async function ___readSourceContentVersionsAsync(filteredByDocIdsByField = "ContentDocumentId") {
            if (sourceFiles.docIds.length > 0) {
                _self.runtime.logFormattedInfo(_self, sfdmuRunAddonMessages_1.SFDMU_RUN_ADDON_MESSAGES.ExportFiles_ReadSourceContentVersions);
                let fields = common_1.Common.distinctStringArray([
                    'Id', args.externalId, 'ContentDocumentId',
                    'Title', 'Description', 'PathOnClient', 'VersionData',
                    'ContentModifiedDate', 'ContentSize', 'Checksum',
                    'ContentUrl', 'ContentBodyId'
                ]);
                let queries = _self.runtime.createFieldInQueries(fields, filteredByDocIdsByField, 'ContentVersion', sourceFiles.docIds, `(IsLatest = true) AND (ContentDocument.ContentSize <= ${args.maxFileSize})`);
                if (args.sourceWhere) {
                    queries = queries.map(query => query.replace('WHERE', 'WHERE (' + args.sourceWhere + ') AND (') + ')');
                }
                let contentVersions = await _self.runtime.queryMultiAsync(true, queries);
                sourceFiles.docIdToDocVersion = common_1.Common.arrayToMap(contentVersions, [filteredByDocIdsByField]);
                sourceFiles.docIds = [...sourceFiles.docIdToDocVersion.keys()];
                _self.runtime.logFormattedInfo(_self, sfdmuRunAddonMessages_1.SFDMU_RUN_ADDON_MESSAGES.ExportFiles_RetrievedRecords, String(contentVersions.length));
            }
        }
        async function __readTargetContentVersionsAsync(filteredByDocIdsByField = "ContentDocumentId") {
            if (args.operation != enumerations_1.OPERATION.Insert && targetFiles.docIds.length > 0) {
                _self.runtime.logFormattedInfo(_self, sfdmuRunAddonMessages_1.SFDMU_RUN_ADDON_MESSAGES.ExportFiles_ReadTargetContentVersions);
                let fields = common_1.Common.distinctStringArray([
                    'Id', args.externalId, 'ContentDocumentId',
                    'ContentModifiedDate', 'Title',
                    'Checksum', 'ContentUrl'
                ]);
                let queries = _self.runtime.createFieldInQueries(fields, filteredByDocIdsByField, 'ContentVersion', targetFiles.docIds, 'IsLatest = true');
                if (args.targetWhere) {
                    queries = queries.map(query => query.replace('WHERE', 'WHERE (' + args.targetWhere + ') AND (') + ')');
                }
                let contentVersions = await _self.runtime.queryMultiAsync(false, queries);
                targetFiles.docIdToDocVersion = common_1.Common.arrayToMap(contentVersions, [filteredByDocIdsByField]);
                targetFiles.docIds = [...targetFiles.docIdToDocVersion.keys()];
                _self.runtime.logFormattedInfo(_self, sfdmuRunAddonMessages_1.SFDMU_RUN_ADDON_MESSAGES.ExportFiles_RetrievedRecords, String(contentVersions.length));
            }
        }
        async function __compareContentVersionsAsync(compareByDocIdsByField = "ContentDocumentId") {
            sourceFiles.recIdToDocLinks.forEach((sourceDocLinks, recordId) => {
                sourceDocLinks.forEach(sourceDocLink => {
                    let sourceContentVersion = sourceFiles.docIdToDocVersion.get(sourceDocLink[compareByDocIdsByField]);
                    if (sourceContentVersion) {
                        let targetRecord = task.sourceToTargetRecordMap.get(task.sourceTaskData.idRecordsMap.get(recordId));
                        if (!exportedFilesMap.has(sourceContentVersion)) {
                            exportedFilesMap.set(sourceContentVersion, {
                                version: new contentVersion_1.default(sourceContentVersion),
                                recordsToBeLinked: new Array(),
                                isVersionChanged: false,
                                targetVersion: null
                            });
                        }
                        let exportedFiles = exportedFilesMap.get(sourceContentVersion);
                        if (targetRecord) {
                            let targetDocLinks = targetFiles.recIdToDocLinks.get(targetRecord["Id"]);
                            let found = false;
                            (targetDocLinks || []).forEach(targetDocLink => {
                                let targetContentVersion = exportedFiles.targetVersion || new contentVersion_1.default(targetFiles.docIdToDocVersion.get(targetDocLink[compareByDocIdsByField]));
                                if (exportedFiles.version[args.externalId] == targetContentVersion[args.externalId]) {
                                    found = true;
                                    exportedFiles.targetVersion = targetContentVersion;
                                    if (!exportedFiles.version.targetContentDocumentId) {
                                        exportedFiles.version.targetContentDocumentId = String(targetContentVersion[compareByDocIdsByField]);
                                    }
                                    if (exportedFiles.version.isNewer(targetContentVersion)) {
                                        exportedFiles.isVersionChanged = true;
                                    }
                                }
                            });
                            if (!found && args.operation != enumerations_1.OPERATION.Update) {
                                exportedFiles.recordsToBeLinked.push({
                                    Id: targetRecord["Id"],
                                    sourceDocLink
                                });
                            }
                        }
                    }
                });
            });
            exportedFilesMap.forEach((exportedFile) => {
                if (!exportedFile.targetVersion) {
                    exportedFile.isVersionChanged = true;
                }
            });
        }
        async function __writeFileTargetRecordsAsync() {
            if (exportedFiles.length > 0) {
                _self.runtime.logFormattedInfo(_self, sfdmuRunAddonMessages_1.SFDMU_RUN_ADDON_MESSAGES.ExportFiles_ExportingContentDocumentLinks);
                let docLinks = common_1.Common.flattenArrays(exportedFiles.map(fileToExport => fileToExport.recordsToBeLinked.map(record => {
                    return {
                        LinkedEntityID: record.Id,
                        ContentDocumentID: fileToExport.version.targetContentDocumentId,
                        ShareType: record.sourceDocLink.ShareType,
                        Visibility: record.sourceDocLink.Visibility
                    };
                })));
                _self.runtime.logFormattedInfo(_self, sfdmuRunAddonMessages_1.SFDMU_RUN_ADDON_MESSAGES.ExportFiles_RecordsToBeProcessed, String(docLinks.length));
                let data = await _self.runtime.updateTargetRecordsAsync('ContentDocumentLink', enumerations_1.OPERATION.Insert, docLinks, enumerations_1.API_ENGINE.DEFAULT_ENGINE, true);
                _self.runtime.logFormattedInfo(_self, sfdmuRunAddonMessages_1.SFDMU_RUN_ADDON_MESSAGES.ExportFiles_ProcessedRecords, String(data.length), String(data.filter(item => !!item[statics_1.CONSTANTS.ERRORS_FIELD_NAME]).length));
            }
        }
        async function __writeFeedAttachmentTargetRecordsAsync() {
            if (exportedFiles.length > 0) {
                _self.runtime.logFormattedInfo(_self, sfdmuRunAddonMessages_1.SFDMU_RUN_ADDON_MESSAGES.ExportFiles_ExportingFeedAttachments);
                let docLinks = common_1.Common.flattenArrays(exportedFiles.map(fileToExport => fileToExport.recordsToBeLinked.map(record => {
                    return {
                        FeedEntityId: record.Id,
                        RecordId: fileToExport.version.targetId,
                        Type: 'Content',
                        Title: fileToExport.version.Title
                    };
                })));
                _self.runtime.logFormattedInfo(_self, sfdmuRunAddonMessages_1.SFDMU_RUN_ADDON_MESSAGES.ExportFiles_RecordsToBeProcessed, String(docLinks.length));
                let data = await _self.runtime.updateTargetRecordsAsync('FeedAttachment', enumerations_1.OPERATION.Insert, docLinks, enumerations_1.API_ENGINE.DEFAULT_ENGINE, true);
                _self.runtime.logFormattedInfo(_self, sfdmuRunAddonMessages_1.SFDMU_RUN_ADDON_MESSAGES.ExportFiles_ProcessedRecords, String(data.length), String(data.filter(item => !!item[statics_1.CONSTANTS.ERRORS_FIELD_NAME]).length));
            }
        }
        async function ___deleteTargetFilesAsync(docIdsToDelete) {
            if (args.deleteOldData || args.operation == enumerations_1.OPERATION.Delete) {
                isDeleted = true;
                if (docIdsToDelete.length > 0) {
                    _self.runtime.logFormattedInfo(_self, sfdmuRunAddonMessages_1.SFDMU_RUN_ADDON_MESSAGES.ExportFiles_DeleteTargetContentDocuments);
                    let data = await _self.runtime.updateTargetRecordsAsync('ContentDocument', enumerations_1.OPERATION.Delete, docIdsToDelete.map(item => {
                        return {
                            Id: item
                        };
                    }));
                    _self.runtime.logFormattedInfo(_self, sfdmuRunAddonMessages_1.SFDMU_RUN_ADDON_MESSAGES.ExportFiles_ProcessedRecords, String(data.length), String(data.filter(item => !!item[statics_1.CONSTANTS.ERRORS_FIELD_NAME]).length));
                }
                if (args.operation == enumerations_1.OPERATION.Delete) {
                    return true;
                }
            }
            return false;
        }
        function ___filterRecords(idRecordsMap) {
            switch (_self.context.objectName) {
                case 'FeedItem':
                    return [...idRecordsMap]
                        .filter(idToRecord => idToRecord[1].Type == 'ContentPost')
                        .map(idToRecord => idToRecord[0]);
                default:
                    return [...idRecordsMap.keys()];
            }
        }
        return null;
    }
}
exports.default = ExportFiles;
//# sourceMappingURL=index.js.map