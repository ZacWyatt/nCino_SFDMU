import * as SoqlModels from './models/SoqlQuery.model';
import { isSubquery } from './utils';
export interface ComposeField {
    field: string;
    objectPrefix?: string;
}
export interface ComposeFieldFunction {
    fn: string;
    parameters?: string | string[] | SoqlModels.FieldFunctionExpression | SoqlModels.FieldFunctionExpression[];
    alias?: string;
}
export interface ComposeFieldRelationship {
    field: string;
    relationships: string[];
    objectPrefix?: string;
}
export interface ComposeFieldSubquery {
    subquery?: SoqlModels.Subquery;
}
export interface ComposeFieldTypeof {
    field: string;
    conditions: SoqlModels.FieldTypeOfCondition[];
}
export declare type ComposeFieldInput = ComposeField | ComposeFieldFunction | ComposeFieldRelationship | ComposeFieldSubquery | ComposeFieldTypeof;
export { isSubquery };
/**
 * Pass any a basic string or populate required properties on the ComposeField object
 * and a constructed field will be returned
 * @param input string | ComposeFieldInput
 * @returns FieldType
 */
export declare function getComposedField(input: string | ComposeFieldInput): SoqlModels.FieldType;
/**
 * Gets flattened fields - this will turn a Query into a list of fields that can be used to parse results from a returned dataset from SFDC
 * Subqueries only include the child SObject relationship name
 * @param query
 * @param [isAggregateResult] pass in true to force expr0...1 for all non-aliased functions even if field is not explicitly an aggregate expression
 * @returns flattened fields
 */
export declare function getFlattenedFields(query: SoqlModels.Query, isAggregateResult?: boolean): string[];
