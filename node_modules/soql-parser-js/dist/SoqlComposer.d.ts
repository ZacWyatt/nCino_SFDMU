import { FieldType, GroupByClause, HavingClause, OrderByClause, Query, WhereClause, WithDataCategoryClause, FieldTypeOf, Subquery } from './models/SoqlQuery.model';
import { Formatter, FormatOptions } from './SoqlFormatter';
export interface SoqlComposeConfig {
    logging: boolean;
    format: boolean;
    formatOptions?: FormatOptions;
    autoCompose: boolean;
}
/**
 * Formats query - This will compose and then parse a query with the provided format options
 * or the defaults if omitted
 * @param soql
 * @param [formatOptions]
 * @returns
 */
export declare function formatQuery(soql: string, formatOptions?: FormatOptions): string;
/**
 * Composes a parsed query back to a SOQL query
 * The parsing methods are public in case there is a need to parse just a part of a query,
 * but the common case is to call the "start()" method
 * @param soql
 * @param [config]
 * @returns query
 */
export declare function composeQuery(soql: Query, config?: Partial<SoqlComposeConfig>): string;
/**
 * Compose
 * This class handles all the logic for turning a Query into a SOQL query
 * This depends on the Format class for parts of the processing
 */
export declare class Compose {
    private soql;
    logging: boolean;
    format: boolean;
    query: string;
    formatter: Formatter;
    constructor(soql: Query, config?: Partial<SoqlComposeConfig>);
    /**
     * Starts compose
     */
    start(): void;
    /**
     * If logging is enabled, print the query to the console
     * @param soql
     */
    private log(soql);
    /**
     * Parses query
     * Base entry point for the query
     * this may be called multiple times recursively for subqueries and WHERE queries
     * @param query
     * @returns query
     */
    parseQuery(query: Query | Subquery): string;
    /**
     * Parses fields
     * e.x.: SELECT amount, FORMAT(amount) Amt, (SELECT Id, Name FROM Contacts)
     * @param fields
     * @returns fields
     */
    parseFields(fields: FieldType[]): string[];
    /**
     * Parses type of Field
     * e.x.: TYPEOF What WHEN Account THEN Phone, NumberOfEmployees WHEN Opportunity THEN Amount, CloseDate ELSE Name
     * @param typeOfField
     * @returns type of field
     */
    parseTypeOfField(typeOfField: FieldTypeOf): string;
    /**
     * Parses fn from a WHERE clause
     * @param fn
     * @returns fn
     */
    private parseFn(fn);
    /**
     * Parses where clause
     * e.x.: WHERE LoginTime > 2010-09-20T22:16:30.000Z AND LoginTime < 2010-09-21T22:16:30.000Z
     * WHERE Id IN (SELECT AccountId FROM Contact WHERE LastName LIKE 'apple%') AND Id IN (SELECT AccountId FROM Opportunity WHERE isClosed = false)
     * @param where
     * @returns where clause
     */
    parseWhereClause(where: WhereClause): string;
    /**
     * Parses group by clause
     * e.x.: GROUP BY CampaignId
     * @param groupBy
     * @returns group by clause
     */
    parseGroupByClause(groupBy: GroupByClause): string;
    /**
     * Parses having clause
     * e.x.: HAVING COUNT(Name) > 100 and LeadSource > 'Phone'
     * @param having
     * @returns having clause
     */
    parseHavingClause(having: HavingClause): string;
    /**
     * Parses order by
     * e.x.: ORDER BY BillingPostalCode ASC NULLS LAST
     * @param orderBy
     * @returns order by
     */
    parseOrderBy(orderBy: OrderByClause | OrderByClause[]): string;
    /**
     * Parses with data category
     * e.x.: WITH DATA CATEGORY Geography__c AT (usa__c, uk__c)
     * @param withDataCategory
     * @returns with data category
     */
    parseWithDataCategory(withDataCategory: WithDataCategoryClause): string;
}
