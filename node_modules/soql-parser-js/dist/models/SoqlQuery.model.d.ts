export declare type LogicalOperator = 'AND' | 'OR';
export declare type Operator = '=' | '!=' | '<=' | '>=' | '>' | '<' | 'LIKE' | 'IN' | 'NOT IN' | 'INCLUDES' | 'EXCLUDES';
export declare type FieldTypeOfConditionType = 'WHEN' | 'ELSE';
export declare type GroupSelector = 'ABOVE' | 'AT' | 'BELOW' | 'ABOVE_OR_BELOW';
export declare type LogicalPrefix = 'NOT';
export declare type ForClause = 'VIEW' | 'UPDATE' | 'REFERENCE';
export declare type UpdateClause = 'TRACKING' | 'VIEWSTAT';
export declare type LiteralType = 'STRING' | 'INTEGER' | 'DECIMAL' | 'BOOLEAN' | 'NULL' | 'DATETIME' | 'DATE' | 'DATE_LITERAL' | 'DATE_N_LITERAL';
export declare type FieldType = Field | FieldFunctionExpression | FieldRelationship | FieldSubquery | FieldTypeOf;
export declare type OrderByCriterion = 'ASC' | 'DESC';
export declare type NullsOrder = 'FIRST' | 'LAST';
export declare type GroupByType = 'CUBE' | 'ROLLUP';
export interface Field {
    type: 'Field';
    field: string;
    objectPrefix?: string;
}
export interface FieldFunctionExpression {
    type: 'FieldFunctionExpression';
    fn: string;
    parameters?: string[] | FieldFunctionExpression[];
    alias?: string;
    isAggregateFn?: boolean;
    rawValue?: string;
}
export interface FieldRelationship {
    type: 'FieldRelationship';
    field: string;
    relationships: string[];
    objectPrefix?: string;
    rawValue?: string;
}
export interface FieldSubquery {
    type: 'FieldSubquery';
    subquery: Subquery;
    from?: string;
}
export interface FieldTypeOf {
    type: 'FieldTypeof';
    field: string;
    conditions: FieldTypeOfCondition[];
}
export interface FieldTypeOfCondition {
    type: FieldTypeOfConditionType;
    objectType?: string;
    fieldList: string[];
}
export interface QueryBase {
    fields: FieldType[];
    sObjectAlias?: string;
    where?: WhereClause;
    limit?: number;
    offset?: number;
    groupBy?: GroupByClause;
    having?: HavingClause;
    orderBy?: OrderByClause | OrderByClause[];
    withDataCategory?: WithDataCategoryClause;
    withSecurityEnforced?: boolean;
    for?: ForClause;
    update?: UpdateClause;
}
export interface Query extends QueryBase {
    sObject: string;
}
export interface Subquery extends QueryBase {
    relationshipName: string;
    sObjectPrefix?: string[];
}
export interface WhereClause {
    left: Condition;
    right?: WhereClause;
    operator?: LogicalOperator;
}
export interface Condition {
    openParen?: number;
    closeParen?: number;
    logicalPrefix?: LogicalPrefix;
    field?: string;
    fn?: FunctionExp;
    operator: Operator;
    value?: string | string[];
    valueQuery?: Query;
    literalType?: LiteralType;
    dateLiteralVariable?: number;
}
export interface OrderByClause {
    field?: string;
    fn?: FunctionExp;
    order?: OrderByCriterion;
    nulls?: NullsOrder;
}
export interface GroupByClause {
    field: string | string[];
    type?: GroupByType;
}
export interface HavingClause {
    left: HavingCondition;
    right?: HavingClause;
    operator?: LogicalOperator;
}
export interface HavingCondition {
    openParen?: number;
    closeParen?: number;
    field?: string;
    fn?: FunctionExp;
    operator: string;
    value: string | number;
}
export interface FunctionExp {
    text?: string;
    name?: string;
    alias?: string;
    parameter?: string | string[];
    isAggregateFn?: boolean;
    fn?: FunctionExp;
}
export interface WithDataCategoryClause {
    conditions: WithDataCategoryCondition[];
}
export interface WithDataCategoryCondition {
    groupName: string;
    selector: GroupSelector;
    parameters: string[];
}
