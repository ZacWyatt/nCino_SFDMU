import { TerminalNode } from 'antlr4ts/tree';
import { SOQLListener } from './generated/SOQLListener';
import * as Parser from './generated/SOQLParser';
import { FieldType, GroupByClause, HavingClause, OrderByClause, Query, WhereClause, ForClause, UpdateClause, WithDataCategoryClause, FieldFunctionExpression, Subquery } from './models/SoqlQuery.model';
import { SoqlQueryConfig } from './SoqlParser';
export declare type CurrItem = 'field' | 'typeof' | 'from' | 'where' | 'groupby' | 'orderby' | 'having' | 'withDataCategory';
export interface Context {
    /**
     * True if currently in a subquery
     */
    isSubQuery: boolean;
    /**
     * Current subquery being processed
     */
    currentSubquery: Query;
    /**
     * If a FunctionExpression is being parsed, this is the root query
     * that will be added the parse SOQL
     */
    rootFieldFn?: FieldFunctionExpression;
    /**
     * Current FieldFunctionExpression being processed
     * This will be the same as rootFieldFn unless there are nested functions within field parameters
     */
    currentFieldFn?: FieldFunctionExpression;
    /**
     * Previous FieldFunctionExpression
     * Only used if there are nested functions within field parameters
     */
    previousFieldFn?: FieldFunctionExpression;
    /**
     * True if the current context is in a WHERE clause query (semi-join / anti-join)
     */
    isWhereSubQuery: boolean;
    /**
     * Query for current WHERE clause
     */
    whereSubquery: Query;
    /**
     * Current item being processed
     * This is used so that when a listener is called, the correct action can be taken
     * since there are many elements shared between parts of the query
     */
    currentItem: CurrItem;
    /**
     * True if a processing a group within a WHERE clause
     */
    inWhereClauseGroup: boolean;
    /**
     * This is used to store the current data that will eventually be added to the query
     * The shape of this data varies based on the current item being processed
     */
    tempData: any;
    /**
     * This is used to store the previous context when in a WHILE subquery
     * Once the subquery is done being processed, then this is set back to tempData
     */
    tempDataBackup: any;
}
/**
 * Soql query
 * This is the base query that will be built as the query is parsed
 */
export declare class SoqlQuery implements Query {
    fields: FieldType[];
    sObject: string;
    sObjectAlias?: string;
    sObjectPrefix?: string[];
    sObjectRelationshipName?: string;
    where?: WhereClause;
    limit?: number;
    offset?: number;
    groupBy?: GroupByClause;
    having?: HavingClause;
    orderBy?: OrderByClause | OrderByClause[];
    withDataCategory?: WithDataCategoryClause;
    withSecurityEnforced?: boolean;
    for?: ForClause;
    update?: UpdateClause;
    constructor();
}
/**
 * Used to check the validity of a query without building a SoqlQuery
 */
export declare class ListenerQuick implements SOQLListener {
}
/**
 * Listener
 * All the listener methods called here are overrides from SOQLListener - generated from ANTLR
 * As each listener function is called, the context is used to build the parsed data structure.
 *
 */
export declare class Listener implements SOQLListener {
    private config;
    context: Context;
    soqlQuery: SoqlQuery;
    constructor(config?: Partial<SoqlQueryConfig>);
    /**
     * LISTENER METHODS
     */
    visitTerminal(ctx: TerminalNode): void;
    getSoqlQuery(): Query | Subquery;
    enterKeywords_alias_allowed(ctx: Parser.Keywords_alias_allowedContext): void;
    exitKeywords_alias_allowed(ctx: Parser.Keywords_alias_allowedContext): void;
    enterKeywords_name_allowed(ctx: Parser.Keywords_name_allowedContext): void;
    exitKeywords_name_allowed(ctx: Parser.Keywords_name_allowedContext): void;
    enterName(ctx: Parser.NameContext): void;
    exitName(ctx: Parser.NameContext): void;
    enterObject_name(ctx: Parser.Object_nameContext): void;
    exitObject_name(ctx: Parser.Object_nameContext): void;
    enterField_name(ctx: Parser.Field_nameContext): void;
    exitField_name(ctx: Parser.Field_nameContext): void;
    enterFilter_scope_name(ctx: Parser.Filter_scope_nameContext): void;
    exitFilter_scope_name(ctx: Parser.Filter_scope_nameContext): void;
    enterData_category_group_name(ctx: Parser.Data_category_group_nameContext): void;
    exitData_category_group_name(ctx: Parser.Data_category_group_nameContext): void;
    enterData_category_name(ctx: Parser.Data_category_nameContext): void;
    exitData_category_name(ctx: Parser.Data_category_nameContext): void;
    enterAlias_name(ctx: Parser.Alias_nameContext): void;
    exitAlias_name(ctx: Parser.Alias_nameContext): void;
    enterAlias(ctx: Parser.AliasContext): void;
    exitAlias(ctx: Parser.AliasContext): void;
    enterLiteral(ctx: Parser.LiteralContext): void;
    exitLiteral(ctx: Parser.LiteralContext): void;
    enterDate_formula_literal(ctx: Parser.Date_formula_literalContext): void;
    exitDate_formula_literal(ctx: Parser.Date_formula_literalContext): void;
    enterDate_formula_n_literal_name(ctx: Parser.Date_formula_n_literal_nameContext): void;
    exitDate_formula_n_literal_name(ctx: Parser.Date_formula_n_literal_nameContext): void;
    enterDate_formula_n_literal(ctx: Parser.Date_formula_n_literalContext): void;
    exitDate_formula_n_literal(ctx: Parser.Date_formula_n_literalContext): void;
    enterDatetime_literal(ctx: Parser.Datetime_literalContext): void;
    exitDatetime_literal(ctx: Parser.Datetime_literalContext): void;
    enterDate_literal(ctx: Parser.Date_literalContext): void;
    exitDate_literal(ctx: Parser.Date_literalContext): void;
    enterInteger_literal(ctx: Parser.Integer_literalContext): void;
    exitInteger_literal(ctx: Parser.Integer_literalContext): void;
    enterReal_literal(ctx: Parser.Real_literalContext): void;
    exitReal_literal(ctx: Parser.Real_literalContext): void;
    enterString_literal(ctx: Parser.String_literalContext): void;
    exitString_literal(ctx: Parser.String_literalContext): void;
    enterBoolean_literal(ctx: Parser.Boolean_literalContext): void;
    exitBoolean_literal(ctx: Parser.Boolean_literalContext): void;
    enterNull_literal(ctx: Parser.Null_literalContext): void;
    exitNull_literal(ctx: Parser.Null_literalContext): void;
    enterFunction_name(ctx: Parser.Function_nameContext): void;
    exitFunction_name(ctx: Parser.Function_nameContext): void;
    enterFunction_date(ctx: Parser.Function_dateContext): void;
    exitFunction_date(ctx: Parser.Function_dateContext): void;
    enterFunction_aggregate(ctx: Parser.Function_aggregateContext): void;
    exitFunction_aggregate(ctx: Parser.Function_aggregateContext): void;
    enterFunction_location(ctx: Parser.Function_locationContext): void;
    exitFunction_location(ctx: Parser.Function_locationContext): void;
    enterFunction_other(ctx: Parser.Function_otherContext): void;
    exitFunction_other(ctx: Parser.Function_otherContext): void;
    enterSoql_query(ctx: Parser.Soql_queryContext): void;
    exitSoql_query(ctx: Parser.Soql_queryContext): void;
    enterSelect_clause(ctx: Parser.Select_clauseContext): void;
    exitSelect_clause(ctx: Parser.Select_clauseContext): void;
    enterFrom_clause(ctx: Parser.From_clauseContext): void;
    exitFrom_clause(ctx: Parser.From_clauseContext): void;
    enterUsing_clause(ctx: Parser.Using_clauseContext): void;
    exitUsing_clause(ctx: Parser.Using_clauseContext): void;
    enterWhere_clause(ctx: Parser.Where_clauseContext): void;
    exitWhere_clause(ctx: Parser.Where_clauseContext): void;
    enterGroupby_clause(ctx: Parser.Groupby_clauseContext): void;
    exitGroupby_clause(ctx: Parser.Groupby_clauseContext): void;
    enterHaving_clause(ctx: Parser.Having_clauseContext): void;
    exitHaving_clause(ctx: Parser.Having_clauseContext): void;
    enterOrderby_clause(ctx: Parser.Orderby_clauseContext): void;
    exitOrderby_clause(ctx: Parser.Orderby_clauseContext): void;
    enterLimit_clause(ctx: Parser.Limit_clauseContext): void;
    exitLimit_clause(ctx: Parser.Limit_clauseContext): void;
    enterOffset_clause(ctx: Parser.Offset_clauseContext): void;
    exitOffset_clause(ctx: Parser.Offset_clauseContext): void;
    enterFor_clause(ctx: Parser.For_clauseContext): void;
    exitFor_clause(ctx: Parser.For_clauseContext): void;
    enterUpdate_clause(ctx: Parser.Update_clauseContext): void;
    exitUpdate_clause(ctx: Parser.Update_clauseContext): void;
    enterSoql_subquery(ctx: Parser.Soql_subqueryContext): void;
    exitSoql_subquery(ctx: Parser.Soql_subqueryContext): void;
    enterSubquery_select_clause(ctx: Parser.Subquery_select_clauseContext): void;
    exitSubquery_select_clause(ctx: Parser.Subquery_select_clauseContext): void;
    enterSelect_spec(ctx: Parser.Select_specContext): void;
    exitSelect_spec(ctx: Parser.Select_specContext): void;
    enterSubquery_select_spec(ctx: Parser.Subquery_select_specContext): void;
    exitSubquery_select_spec(ctx: Parser.Subquery_select_specContext): void;
    enterField_spec(ctx: Parser.Field_specContext): void;
    enterFunction_call_spec(ctx: Parser.Function_call_specContext): void;
    exitFunction_call_spec(ctx: Parser.Function_call_specContext): void;
    enterField(ctx: Parser.FieldContext): void;
    exitField(ctx: Parser.FieldContext): void;
    enterFunction_call(ctx: Parser.Function_callContext): void;
    exitFunction_call(ctx: Parser.Function_callContext): void;
    enterFunction_parameter_list(ctx: Parser.Function_parameter_listContext): void;
    exitFunction_parameter_list(ctx: Parser.Function_parameter_listContext): void;
    enterFunction_parameter(ctx: Parser.Function_parameterContext): void;
    exitFunction_parameter(ctx: Parser.Function_parameterContext): void;
    enterTypeof_spec(ctx: Parser.Typeof_specContext): void;
    exitTypeof_spec(ctx: Parser.Typeof_specContext): void;
    enterTypeof_when_then_clause_list(ctx: Parser.Typeof_when_then_clause_listContext): void;
    exitTypeof_when_then_clause_list(ctx: Parser.Typeof_when_then_clause_listContext): void;
    enterTypeof_when_then_clause(ctx: Parser.Typeof_when_then_clauseContext): void;
    exitTypeof_when_then_clause(ctx: Parser.Typeof_when_then_clauseContext): void;
    enterTypeof_then_clause(ctx: Parser.Typeof_then_clauseContext): void;
    exitTypeof_then_clause(ctx: Parser.Typeof_then_clauseContext): void;
    enterTypeof_else_clause(ctx: Parser.Typeof_else_clauseContext): void;
    exitTypeof_else_clause(ctx: Parser.Typeof_else_clauseContext): void;
    enterField_list(ctx: Parser.Field_listContext): void;
    exitField_list(ctx: Parser.Field_listContext): void;
    enterObject_spec(ctx: Parser.Object_specContext): void;
    exitObject_spec(ctx: Parser.Object_specContext): void;
    enterObject_prefix(ctx: Parser.Object_prefixContext): void;
    exitObject_prefix(ctx: Parser.Object_prefixContext): void;
    enterComparison_operator(ctx: Parser.Comparison_operatorContext): void;
    exitComparison_operator(ctx: Parser.Comparison_operatorContext): void;
    enterSet_operator(ctx: Parser.Set_operatorContext): void;
    exitSet_operator(ctx: Parser.Set_operatorContext): void;
    enterCondition(ctx: Parser.ConditionContext): void;
    exitCondition(ctx: Parser.ConditionContext): void;
    enterCondition1(ctx: Parser.Condition1Context): void;
    exitCondition1(ctx: Parser.Condition1Context): void;
    enterParenthesis(ctx: Parser.ParenthesisContext): void;
    exitParenthesis(ctx: Parser.ParenthesisContext): void;
    enterSimple_condition(ctx: Parser.Simple_conditionContext): void;
    exitSimple_condition(ctx: Parser.Simple_conditionContext): void;
    enterField_based_condition(ctx: Parser.Field_based_conditionContext): void;
    exitField_based_condition(ctx: Parser.Field_based_conditionContext): void;
    enterSet_based_condition(ctx: Parser.Set_based_conditionContext): void;
    exitSet_based_condition(ctx: Parser.Set_based_conditionContext): void;
    enterLike_based_condition(ctx: Parser.Like_based_conditionContext): void;
    exitLike_based_condition(ctx: Parser.Like_based_conditionContext): void;
    enterCondition_field(ctx: Parser.Condition_fieldContext): void;
    exitCondition_field(ctx: Parser.Condition_fieldContext): void;
    enterSet_values(ctx: Parser.Set_valuesContext): void;
    exitSet_values(ctx: Parser.Set_valuesContext): void;
    enterSet_value_list(ctx: Parser.Set_value_listContext): void;
    exitSet_value_list(ctx: Parser.Set_value_listContext): void;
    enterWith_clause(ctx: Parser.With_clauseContext): void;
    exitWith_clause(ctx: Parser.With_clauseContext): void;
    enterWith_plain_clause(ctx: Parser.With_plain_clauseContext): void;
    exitWith_plain_clause(ctx: Parser.With_plain_clauseContext): void;
    enterWith_data_category_clause(ctx: Parser.With_data_category_clauseContext): void;
    exitWith_data_category_clause(ctx: Parser.With_data_category_clauseContext): void;
    enterData_category_spec_list(ctx: Parser.Data_category_spec_listContext): void;
    enterWith_security_enforced_clause(ctx: Parser.With_security_enforced_clauseContext): void;
    exitWith_security_enforced_clause(ctx: Parser.With_security_enforced_clauseContext): void;
    exitData_category_spec_list(ctx: Parser.Data_category_spec_listContext): void;
    enterData_category_spec(ctx: Parser.Data_category_specContext): void;
    exitData_category_spec(ctx: Parser.Data_category_specContext): void;
    enterData_category_parameter_list(ctx: Parser.Data_category_parameter_listContext): void;
    exitData_category_parameter_list(ctx: Parser.Data_category_parameter_listContext): void;
    enterData_category_selector(ctx: Parser.Data_category_selectorContext): void;
    exitData_category_selector(ctx: Parser.Data_category_selectorContext): void;
    enterGroup_by_plain_clause(ctx: Parser.Group_by_plain_clauseContext): void;
    exitGroup_by_plain_clause(ctx: Parser.Group_by_plain_clauseContext): void;
    enterGroup_by_rollup_clause(ctx: Parser.Group_by_rollup_clauseContext): void;
    exitGroup_by_rollup_clause(ctx: Parser.Group_by_rollup_clauseContext): void;
    enterGroup_by_cube_clause(ctx: Parser.Group_by_cube_clauseContext): void;
    exitGroup_by_cube_clause(ctx: Parser.Group_by_cube_clauseContext): void;
    enterGroup_by_list(ctx: Parser.Group_by_listContext): void;
    exitGroup_by_list(ctx: Parser.Group_by_listContext): void;
    enterGroup_by_spec(ctx: Parser.Group_by_specContext): void;
    exitGroup_by_spec(ctx: Parser.Group_by_specContext): void;
    enterOrder_by_list(ctx: Parser.Order_by_listContext): void;
    exitOrder_by_list(ctx: Parser.Order_by_listContext): void;
    enterOrder_by_spec(ctx: Parser.Order_by_specContext): void;
    exitOrder_by_spec(ctx: Parser.Order_by_specContext): void;
    enterOrder_by_direction_clause(ctx: Parser.Order_by_direction_clauseContext): void;
    exitOrder_by_direction_clause(ctx: Parser.Order_by_direction_clauseContext): void;
    enterOrder_by_nulls_clause(ctx: Parser.Order_by_nulls_clauseContext): void;
    exitOrder_by_nulls_clause(ctx: Parser.Order_by_nulls_clauseContext): void;
    enterOrder_by_field(ctx: Parser.Order_by_fieldContext): void;
    exitOrder_by_field(ctx: Parser.Order_by_fieldContext): void;
    enterFor_value(ctx: Parser.For_valueContext): void;
    exitFor_value(ctx: Parser.For_valueContext): void;
    enterUpdate_value(ctx: Parser.Update_valueContext): void;
    exitUpdate_value(ctx: Parser.Update_valueContext): void;
}
